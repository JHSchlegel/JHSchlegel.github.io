<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jan Schlegel">
<meta name="dcterms.date" content="2025-07-29">

<title>Jan Schlegel – Copulas: Theory, Applications, and Implementation in Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="color-scheme" content="dark light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jan Schlegel</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jan-heinrich-schlegel/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JHSchlegel"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Copulas: Theory, Applications, and Implementation in Python</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Statistics</div>
                <div class="quarto-category">Finance</div>
                <div class="quarto-category">Python</div>
                <div class="quarto-category">Risk Management</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jan Schlegel </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 29, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">Abstract</div>
      This comprehensive exploration of copula theory covers fundamental concepts from Sklar’s theorem to advanced applications in finance and risk management. We examine Archimedean and elliptical copulas, parameter estimation methods, goodness-of-fit testing, and vine copulas, with extensive Python implementations and publication-ready visualizations throughout.
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-introduction" id="toc-sec-introduction" class="nav-link active" data-scroll-target="#sec-introduction"><span class="header-section-number">1</span> Introduction</a>
  <ul class="collapse">
  <li><a href="#historical-development-and-motivation" id="toc-historical-development-and-motivation" class="nav-link" data-scroll-target="#historical-development-and-motivation"><span class="header-section-number">1.1</span> Historical Development and Motivation</a></li>
  <li><a href="#scope-and-structure" id="toc-scope-and-structure" class="nav-link" data-scroll-target="#scope-and-structure"><span class="header-section-number">1.2</span> Scope and Structure</a></li>
  </ul></li>
  <li><a href="#sec-sklar" id="toc-sec-sklar" class="nav-link" data-scroll-target="#sec-sklar"><span class="header-section-number">2</span> Sklar’s Theorem and Fundamental Properties</a>
  <ul class="collapse">
  <li><a href="#sklars-theorem-the-foundation-of-copula-theory" id="toc-sklars-theorem-the-foundation-of-copula-theory" class="nav-link" data-scroll-target="#sklars-theorem-the-foundation-of-copula-theory"><span class="header-section-number">2.1</span> Sklar’s Theorem: The Foundation of Copula Theory</a></li>
  <li><a href="#mathematical-definition-and-properties" id="toc-mathematical-definition-and-properties" class="nav-link" data-scroll-target="#mathematical-definition-and-properties"><span class="header-section-number">2.2</span> Mathematical Definition and Properties</a></li>
  <li><a href="#fréchet-hoeffding-bounds" id="toc-fréchet-hoeffding-bounds" class="nav-link" data-scroll-target="#fréchet-hoeffding-bounds"><span class="header-section-number">2.3</span> Fréchet-Hoeffding Bounds</a></li>
  <li><a href="#copula-density-and-conditional-distributions" id="toc-copula-density-and-conditional-distributions" class="nav-link" data-scroll-target="#copula-density-and-conditional-distributions"><span class="header-section-number">2.4</span> Copula Density and Conditional Distributions</a></li>
  <li><a href="#dependence-measures" id="toc-dependence-measures" class="nav-link" data-scroll-target="#dependence-measures"><span class="header-section-number">2.5</span> Dependence Measures</a></li>
  </ul></li>
  <li><a href="#sec-archimedean" id="toc-sec-archimedean" class="nav-link" data-scroll-target="#sec-archimedean"><span class="header-section-number">3</span> Archimedean Copulas</a>
  <ul class="collapse">
  <li><a href="#definition-and-mathematical-structure" id="toc-definition-and-mathematical-structure" class="nav-link" data-scroll-target="#definition-and-mathematical-structure"><span class="header-section-number">3.1</span> Definition and Mathematical Structure</a></li>
  <li><a href="#major-archimedean-copula-families" id="toc-major-archimedean-copula-families" class="nav-link" data-scroll-target="#major-archimedean-copula-families"><span class="header-section-number">3.2</span> Major Archimedean Copula Families</a></li>
  <li><a href="#simulation-from-archimedean-copulas" id="toc-simulation-from-archimedean-copulas" class="nav-link" data-scroll-target="#simulation-from-archimedean-copulas"><span class="header-section-number">3.3</span> Simulation from Archimedean Copulas</a></li>
  <li><a href="#multivariate-extensions" id="toc-multivariate-extensions" class="nav-link" data-scroll-target="#multivariate-extensions"><span class="header-section-number">3.4</span> Multivariate Extensions</a></li>
  </ul></li>
  <li><a href="#sec-elliptical" id="toc-sec-elliptical" class="nav-link" data-scroll-target="#sec-elliptical"><span class="header-section-number">4</span> Elliptical Copulas</a>
  <ul class="collapse">
  <li><a href="#gaussian-copula" id="toc-gaussian-copula" class="nav-link" data-scroll-target="#gaussian-copula"><span class="header-section-number">4.1</span> Gaussian Copula</a></li>
  <li><a href="#students-t-copula" id="toc-students-t-copula" class="nav-link" data-scroll-target="#students-t-copula"><span class="header-section-number">4.2</span> Student’s t Copula</a></li>
  </ul></li>
  <li><a href="#sec-estimation" id="toc-sec-estimation" class="nav-link" data-scroll-target="#sec-estimation"><span class="header-section-number">5</span> Parameter Estimation</a>
  <ul class="collapse">
  <li><a href="#estimation-approaches" id="toc-estimation-approaches" class="nav-link" data-scroll-target="#estimation-approaches"><span class="header-section-number">5.1</span> Estimation Approaches</a></li>
  <li><a href="#practical-considerations" id="toc-practical-considerations" class="nav-link" data-scroll-target="#practical-considerations"><span class="header-section-number">5.2</span> Practical Considerations</a></li>
  </ul></li>
  <li><a href="#sec-vine" id="toc-sec-vine" class="nav-link" data-scroll-target="#sec-vine"><span class="header-section-number">6</span> Vine Copulas</a>
  <ul class="collapse">
  <li><a href="#theoretical-foundation" id="toc-theoretical-foundation" class="nav-link" data-scroll-target="#theoretical-foundation"><span class="header-section-number">6.1</span> Theoretical Foundation</a></li>
  <li><a href="#regular-vine-structures" id="toc-regular-vine-structures" class="nav-link" data-scroll-target="#regular-vine-structures"><span class="header-section-number">6.2</span> Regular Vine Structures</a></li>
  <li><a href="#construction-and-estimation" id="toc-construction-and-estimation" class="nav-link" data-scroll-target="#construction-and-estimation"><span class="header-section-number">6.3</span> Construction and Estimation</a></li>
  <li><a href="#model-selection-and-specification" id="toc-model-selection-and-specification" class="nav-link" data-scroll-target="#model-selection-and-specification"><span class="header-section-number">6.4</span> Model Selection and Specification</a></li>
  <li><a href="#applications-and-extensions" id="toc-applications-and-extensions" class="nav-link" data-scroll-target="#applications-and-extensions"><span class="header-section-number">6.5</span> Applications and Extensions</a></li>
  </ul></li>
  <li><a href="#sec-applications" id="toc-sec-applications" class="nav-link" data-scroll-target="#sec-applications"><span class="header-section-number">7</span> Applications in Finance and Risk Management</a>
  <ul class="collapse">
  <li><a href="#portfolio-risk-management-and-value-at-risk" id="toc-portfolio-risk-management-and-value-at-risk" class="nav-link" data-scroll-target="#portfolio-risk-management-and-value-at-risk"><span class="header-section-number">7.1</span> Portfolio Risk Management and Value-at-Risk</a></li>
  <li><a href="#spatial-data-analysis-with-copulas" id="toc-spatial-data-analysis-with-copulas" class="nav-link" data-scroll-target="#spatial-data-analysis-with-copulas"><span class="header-section-number">7.2</span> Spatial Data Analysis with Copulas</a></li>
  </ul></li>
  <li><a href="#sec-conclusion" id="toc-sec-conclusion" class="nav-link" data-scroll-target="#sec-conclusion"><span class="header-section-number">8</span> Conclusion and Future Directions</a>
  <ul class="collapse">
  <li><a href="#key-insights-and-contributions" id="toc-key-insights-and-contributions" class="nav-link" data-scroll-target="#key-insights-and-contributions"><span class="header-section-number">8.1</span> Key Insights and Contributions</a></li>
  <li><a href="#methodological-considerations" id="toc-methodological-considerations" class="nav-link" data-scroll-target="#methodological-considerations"><span class="header-section-number">8.2</span> Methodological Considerations</a></li>
  <li><a href="#future-research-directions" id="toc-future-research-directions" class="nav-link" data-scroll-target="#future-research-directions"><span class="header-section-number">8.3</span> Future Research Directions</a></li>
  <li><a href="#final-thoughts" id="toc-final-thoughts" class="nav-link" data-scroll-target="#final-thoughts"><span class="header-section-number">8.4</span> Final Thoughts</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/copula_theory_thumbnail.png" class="img-fluid figure-img"></p>
<figcaption>Copulas provide a powerful framework for modeling complex dependence structures while separating marginal distributions from their joint behavior</figcaption>
</figure>
</div>
<section id="sec-introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>Copulas represent one of the most elegant and mathematically rigorous frameworks in modern multivariate statistics and financial econometrics. The term “copula,” derived from the Latin word meaning “link” or “tie,” aptly describes their fundamental purpose: they provide a mechanism for modeling the dependence structure between random variables independently of their marginal distributions <span class="citation" data-cites="sklar1959 nelsen2006">(<a href="#ref-sklar1959" role="doc-biblioref">Sklar 1959</a>; <a href="#ref-nelsen2006" role="doc-biblioref">Nelsen 2006</a>)</span>.</p>
<p>The theoretical foundation of copula theory rests on the profound insight that any multivariate distribution can be decomposed into two distinct components: the marginal distributions of individual variables and a copula function that captures their dependence structure. This separation principle, formalized in Sklar’s theorem, has revolutionized multivariate modeling across numerous disciplines, particularly in finance, insurance, hydrology, and actuarial science <span class="citation" data-cites="joe1997 durante2015">(<a href="#ref-joe1997" role="doc-biblioref">Joe 1997</a>; <a href="#ref-durante2015" role="doc-biblioref">Durante and Sempi 2015</a>)</span>.</p>
<section id="historical-development-and-motivation" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="historical-development-and-motivation"><span class="header-section-number">1.1</span> Historical Development and Motivation</h3>
<p>The development of copula theory emerged from the limitations of traditional approaches to multivariate modeling. Classical methods often imposed restrictive distributional assumptions, such as multivariate normality, which failed to capture the complex dependence patterns observed in real-world data. Financial markets, in particular, exhibit phenomena that cannot be adequately modeled by linear correlation:</p>
<ul>
<li><strong>Tail dependence</strong>: The tendency for extreme events to occur simultaneously</li>
<li><strong>Asymmetric dependence</strong>: Different dependence patterns in bull versus bear markets<br>
</li>
<li><strong>Non-linear relationships</strong>: Complex dependence structures beyond linear correlation</li>
<li><strong>Time-varying dependence</strong>: Evolving correlation patterns over time</li>
</ul>
<p>Copulas address these limitations by providing a flexible framework that separates the modeling of marginal behavior from dependence structure, allowing practitioners to:</p>
<ol type="1">
<li>Model each variable’s distribution independently using the most appropriate marginal distribution</li>
<li>Capture complex, non-linear dependence patterns through the copula function</li>
<li>Handle extreme events and tail dependence explicitly</li>
<li>Construct multivariate distributions by combining any marginal distributions with any dependence structure</li>
</ol>
</section>
<section id="scope-and-structure" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="scope-and-structure"><span class="header-section-number">1.2</span> Scope and Structure</h3>
<p>This treatise provides a comprehensive, mathematically rigorous treatment of copula theory and applications, designed for PhD-level students and researchers. We progress systematically from fundamental theoretical concepts to advanced practical implementations:</p>
<p><strong>Theoretical Foundations</strong> (Sections 2-3): We begin with Sklar’s theorem and fundamental properties, establishing the mathematical framework and key results that underpin copula theory.</p>
<p><strong>Copula Families</strong> (Sections 4-5): We examine the two major classes of copulas—Archimedean and elliptical—providing detailed mathematical characterizations, properties, and implementation algorithms.</p>
<p><strong>Statistical Inference</strong> (Sections 6-7): We cover parameter estimation methods including maximum likelihood, method of moments, and rank-based estimators, followed by comprehensive goodness-of-fit testing procedures.</p>
<p><strong>Advanced Topics</strong> (Section 8): We explore vine copulas for high-dimensional modeling, including regular vine structures and construction algorithms.</p>
<p><strong>Applications</strong> (Section 9): We demonstrate practical applications in financial risk management, including portfolio optimization, Value-at-Risk estimation, and credit risk modeling.</p>
<p>Throughout, we provide rigorous mathematical proofs, comprehensive Python implementations, and publication-quality visualizations that illustrate key concepts and facilitate practical application.</p>
<div id="cell-fig-motivation" class="cell" data-fig-height="9" data-fig-width="18" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate data with different marginal distributions but same dependence</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.random.multivariate_normal([<span class="dv">0</span>, <span class="dv">0</span>], [[<span class="dv">1</span>, rho], [rho, <span class="dv">1</span>]], n)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Transform to different margins while preserving dependence</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> stats.norm.cdf(Z[:, <span class="dv">0</span>])  <span class="co"># Uniform margins</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> stats.norm.cdf(Z[:, <span class="dv">1</span>])</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply different marginal transformations</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>Y1 <span class="op">=</span> stats.norm.ppf(X1)  <span class="co"># Normal margins (original)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>Y2_normal <span class="op">=</span> stats.norm.ppf(X2)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>Y2_t <span class="op">=</span> stats.t.ppf(X2, df<span class="op">=</span><span class="dv">3</span>)  <span class="co"># t-distribution margins</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>Y2_exp <span class="op">=</span> stats.expon.ppf(X2)  <span class="co"># Exponential margins</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">9</span>))</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data (bivariate normal)</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].scatter(Y1, Y2_normal, alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Bivariate Normal</span><span class="ch">\n</span><span class="st">(Traditional Approach)'</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'X₁ ~ N(0,1)'</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'X₂ ~ N(0,1)'</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Same copula, different margins</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].scatter(Y1, Y2_t, alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Normal-t Copula</span><span class="ch">\n</span><span class="st">(Copula Approach)'</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X₁ ~ N(0,1)'</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'X₂ ~ t(3)'</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].scatter(Y1, Y2_exp, alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="st">'Normal-Exponential Copula</span><span class="ch">\n</span><span class="st">(Copula Approach)'</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'X₁ ~ N(0,1)'</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'X₂ ~ Exp(1)'</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Copula data (uniform margins)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].scatter(X1, X2, alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Underlying Copula</span><span class="ch">\n</span><span class="st">(Dependence Structure)'</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'U₁ ~ U(0,1)'</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'U₂ ~ U(0,1)'</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Marginal distributions</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(Y2_t, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>x_t <span class="op">=</span> np.linspace(Y2_t.<span class="bu">min</span>(), Y2_t.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(x_t, stats.t.pdf(x_t, df<span class="op">=</span><span class="dv">3</span>), <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'t-distribution Margin'</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X₂'</span>)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].hist(Y2_exp, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>x_exp <span class="op">=</span> np.linspace(<span class="dv">0</span>, Y2_exp.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].plot(x_exp, stats.expon.pdf(x_exp), <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'Exponential Margin'</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'X₂'</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.08</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.92</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-motivation" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-motivation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-motivation-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-motivation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Motivation for copula modeling: Traditional vs.&nbsp;copula-based approaches
</figcaption>
</figure>
</div>
</div>
</div>
<p>This introductory example demonstrates the fundamental principle of copula modeling: the same dependence structure (copula) can be combined with different marginal distributions to create flexible multivariate models that would be impossible to construct using traditional methods.</p>
</section>
</section>
<section id="sec-sklar" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-sklar"><span class="header-section-number">2</span> Sklar’s Theorem and Fundamental Properties</h2>
<section id="sklars-theorem-the-foundation-of-copula-theory" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="sklars-theorem-the-foundation-of-copula-theory"><span class="header-section-number">2.1</span> Sklar’s Theorem: The Foundation of Copula Theory</h3>
<p>The cornerstone of copula theory is Sklar’s theorem, published by Abe Sklar in 1959 <span class="citation" data-cites="sklar1959">(<a href="#ref-sklar1959" role="doc-biblioref">Sklar 1959</a>)</span>. This profound result establishes the theoretical foundation for separating marginal distributions from dependence structure and provides the mathematical justification for copula-based modeling.</p>
<p><strong>Theorem 2.1 (Sklar’s Theorem)</strong>: Let <span class="math inline">\(F\)</span> be a <span class="math inline">\(d\)</span>-dimensional joint distribution function with marginal distribution functions <span class="math inline">\(F_1, F_2, \ldots, F_d\)</span>. Then there exists a copula <span class="math inline">\(C: [0,1]^d \to [0,1]\)</span> such that for all <span class="math inline">\(\mathbf{x} = (x_1, x_2, \ldots, x_d) \in \overline{\mathbb{R}}^d\)</span>:</p>
<p><span class="math display">\[F(x_1, x_2, \ldots, x_d) = C(F_1(x_1), F_2(x_2), \ldots, F_d(x_d))\]</span></p>
<p>If <span class="math inline">\(F_1, F_2, \ldots, F_d\)</span> are continuous, then <span class="math inline">\(C\)</span> is unique. Conversely, if <span class="math inline">\(C\)</span> is a copula and <span class="math inline">\(F_1, F_2, \ldots, F_d\)</span> are univariate distribution functions, then the function <span class="math inline">\(F\)</span> defined above is a joint distribution function with marginal distributions <span class="math inline">\(F_1, F_2, \ldots, F_d\)</span>.</p>
<p><strong>Proof Sketch</strong>: The existence part follows from defining <span class="math inline">\(C(u_1, \ldots, u_d) = F(F_1^{-1}(u_1), \ldots, F_d^{-1}(u_d))\)</span> where <span class="math inline">\(F_i^{-1}\)</span> denotes the generalized inverse of <span class="math inline">\(F_i\)</span>. The uniqueness under continuity follows from the fact that when marginals are continuous, the generalized inverse is the true inverse, making the copula uniquely determined. □</p>
</section>
<section id="mathematical-definition-and-properties" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="mathematical-definition-and-properties"><span class="header-section-number">2.2</span> Mathematical Definition and Properties</h3>
<p><strong>Definition 2.2 (Copula)</strong>: A <span class="math inline">\(d\)</span>-dimensional copula is a function <span class="math inline">\(C: [0,1]^d \to [0,1]\)</span> with the following properties:</p>
<ol type="1">
<li><p><strong>Grounding condition</strong>: For every <span class="math inline">\(\mathbf{u} \in [0,1]^d\)</span>, if at least one coordinate <span class="math inline">\(u_i = 0\)</span>, then <span class="math inline">\(C(\mathbf{u}) = 0\)</span>.</p></li>
<li><p><strong>Uniform margins</strong>: For every <span class="math inline">\(i \in \{1, \ldots, d\}\)</span> and <span class="math inline">\(u_i \in [0,1]\)</span>: <span class="math display">\[C(1, \ldots, 1, u_i, 1, \ldots, 1) = u_i\]</span></p></li>
<li><p><strong><span class="math inline">\(d\)</span>-increasing</strong>: For every hyperrectangle <span class="math inline">\([a_1, b_1] \times \cdots \times [a_d, b_d] \subseteq [0,1]^d\)</span>, the <span class="math inline">\(C\)</span>-volume is non-negative: <span class="math display">\[V_C([a_1, b_1] \times \cdots \times [a_d, b_d]) \geq 0\]</span></p></li>
</ol>
<p>where the <span class="math inline">\(C\)</span>-volume is defined as: <span class="math display">\[V_C([a_1, b_1] \times \cdots \times [a_d, b_d]) = \sum_{\mathbf{z} \in \{a_1, b_1\} \times \cdots \times \{a_d, b_d\}} (-1)^{|\mathbf{z}|} C(\mathbf{z})\]</span></p>
<p>with <span class="math inline">\(|\mathbf{z}| = |\{i: z_i = a_i\}|\)</span>.</p>
</section>
<section id="fréchet-hoeffding-bounds" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="fréchet-hoeffding-bounds"><span class="header-section-number">2.3</span> Fréchet-Hoeffding Bounds</h3>
<p>A fundamental result in copula theory establishes universal bounds for all copulas.</p>
<p><strong>Theorem 2.3 (Fréchet-Hoeffding Bounds)</strong>: For any <span class="math inline">\(d\)</span>-dimensional copula <span class="math inline">\(C\)</span> and all <span class="math inline">\(\mathbf{u} \in [0,1]^d\)</span>:</p>
<p><span class="math display">\[W_d(\mathbf{u}) \leq C(\mathbf{u}) \leq M_d(\mathbf{u})\]</span></p>
<p>where: - <strong>Upper Fréchet bound</strong>: <span class="math inline">\(M_d(\mathbf{u}) = \min(u_1, u_2, \ldots, u_d)\)</span> - <strong>Lower Fréchet bound</strong>: <span class="math inline">\(W_d(\mathbf{u}) = \max(u_1 + u_2 + \cdots + u_d - d + 1, 0)\)</span></p>
<p>For <span class="math inline">\(d = 2\)</span>, both bounds are copulas. For <span class="math inline">\(d &gt; 2\)</span>, only <span class="math inline">\(M_d\)</span> is a copula; <span class="math inline">\(W_d\)</span> fails the <span class="math inline">\(d\)</span>-increasing property.</p>
<div id="cell-fig-frechet-bounds" class="cell" data-fig-height="10" data-fig-width="18" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create grid for plotting</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>U1, U2 <span class="op">=</span> np.meshgrid(u, u)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define Fréchet bounds</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> np.minimum(U1, U2)  <span class="co"># Upper bound (comonotonicity)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.maximum(U1 <span class="op">+</span> U2 <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>)  <span class="co"># Lower bound (countermonotonicity)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>Pi <span class="op">=</span> U1 <span class="op">*</span> U2  <span class="co"># Independence copula</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Define Clayton copula for comparison</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>C_clayton <span class="op">=</span> np.maximum((U1<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">+</span> U2<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta), <span class="dv">0</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">10</span>))</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Contour plots</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>levels <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">21</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Upper bound</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>].contourf(U1, U2, M, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Upper Fréchet Bound</span><span class="ch">\n</span><span class="st">$M(u_1, u_2) = \min(u_1, u_2)$'</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Lower bound  </span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">1</span>].contourf(U1, U2, W, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Lower Fréchet Bound</span><span class="ch">\n</span><span class="st">$W(u_1, u_2) = \max(u_1 + u_2 - 1, 0)$'</span>)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im2, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Independence</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>im3 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">2</span>].contourf(U1, U2, Pi, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="st">'Independence Copula</span><span class="ch">\n</span><span class="st">$\Pi(u_1, u_2) = u_1 u_2$'</span>)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im3, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Clayton copula</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>im4 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>].contourf(U1, U2, C_clayton, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="ss">f'Clayton Copula</span><span class="ch">\n</span><span class="ss">$θ = </span><span class="sc">{</span>theta<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im4, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Diagonal comparison</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>diag_u <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(diag_u, np.minimum(diag_u, diag_u), <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Upper bound'</span>)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(diag_u, np.maximum(<span class="dv">2</span><span class="op">*</span>diag_u <span class="op">-</span> <span class="dv">1</span>, <span class="dv">0</span>), <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Lower bound'</span>)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(diag_u, diag_u<span class="op">**</span><span class="dv">2</span>, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Independence'</span>)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>clayton_diag <span class="op">=</span> np.maximum((<span class="dv">2</span> <span class="op">*</span> diag_u<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta), <span class="dv">0</span>)</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(diag_u, clayton_diag, <span class="st">'m-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Clayton'</span>)</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'$u_1 = u_2$'</span>)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'$C(u_1, u_2)$'</span>)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Diagonal Comparison'</span>)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="co"># 3D surface plot of Clayton copula</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">6</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> ax.plot_surface(U1[::<span class="dv">5</span>, ::<span class="dv">5</span>], U2[::<span class="dv">5</span>, ::<span class="dv">5</span>], C_clayton[::<span class="dv">5</span>, ::<span class="dv">5</span>], </span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>                      cmap<span class="op">=</span><span class="st">'viridis'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>ax.set_zlabel(<span class="st">'$C(u_1, u_2)$'</span>)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Clayton Copula Surface'</span>)</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.08</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.92</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-frechet-bounds" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-frechet-bounds-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-frechet-bounds-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-frechet-bounds-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Fréchet-Hoeffding bounds and example copulas in the bivariate case
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="copula-density-and-conditional-distributions" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="copula-density-and-conditional-distributions"><span class="header-section-number">2.4</span> Copula Density and Conditional Distributions</h3>
<p>When the copula <span class="math inline">\(C\)</span> is absolutely continuous, it possesses a density function that provides important insights into the dependence structure.</p>
<p><strong>Definition 2.4 (Copula Density)</strong>: If a copula <span class="math inline">\(C\)</span> is absolutely continuous, its density is defined as: <span class="math display">\[c(u_1, \ldots, u_d) = \frac{\partial^d C(u_1, \ldots, u_d)}{\partial u_1 \cdots \partial u_d}\]</span></p>
<p>The joint density of <span class="math inline">\((X_1, \ldots, X_d)\)</span> with marginal densities <span class="math inline">\(f_1, \ldots, f_d\)</span> and copula density <span class="math inline">\(c\)</span> is: <span class="math display">\[f(x_1, \ldots, x_d) = c(F_1(x_1), \ldots, F_d(x_d)) \prod_{i=1}^d f_i(x_i)\]</span></p>
<p><strong>Theorem 2.5 (Conditional Distributions from Copulas)</strong>: Let <span class="math inline">\((U_1, U_2)\)</span> have copula <span class="math inline">\(C\)</span> with density <span class="math inline">\(c\)</span>. Then:</p>
<p><span class="math display">\[F(U_2 | U_1 = u_1) = \frac{\partial C(u_1, u_2)}{\partial u_1} = C_{1|2}(u_2|u_1)\]</span></p>
<p>This conditional distribution function is itself a uniform random variable when <span class="math inline">\(U_1\)</span> is given.</p>
<div id="cell-fig-conditional-distributions" class="cell" data-fig-height="9" data-fig-width="18" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gaussian_copula_conditional(u1, u2, rho):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Conditional distribution for Gaussian copula"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    z1 <span class="op">=</span> stats.norm.ppf(u1)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    z2 <span class="op">=</span> stats.norm.ppf(u2)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Conditional mean and variance</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    mu_cond <span class="op">=</span> rho <span class="op">*</span> z1</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    sigma_cond <span class="op">=</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Conditional CDF</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> stats.norm.cdf((z2 <span class="op">-</span> mu_cond) <span class="op">/</span> sigma_cond)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clayton_copula_conditional(u1, u2, theta):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Conditional distribution for Clayton copula"""</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> u1<span class="op">**</span>(<span class="op">-</span>theta<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> (u1<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">+</span> u2<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>u_vals <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.99</span>, <span class="dv">100</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">9</span>))</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian copula conditionals</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, u1_fixed <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.9</span>]):</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    conditional_vals <span class="op">=</span> [gaussian_copula_conditional(u1_fixed, u2, rho) <span class="cf">for</span> u2 <span class="kw">in</span> u_vals]</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].plot(u_vals, conditional_vals, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].plot([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>], <span class="st">'k--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Independence'</span>)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f'Gaussian Copula</span><span class="ch">\n</span><span class="ss">$u_1 = </span><span class="sc">{</span>u1_fixed<span class="sc">}</span><span class="ss">$, $ρ = </span><span class="sc">{</span>rho<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_xlabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_ylabel(<span class="st">'$P(U_2 ≤ u_2 | U_1 = u_1)$'</span>)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].grid(<span class="va">True</span>)</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].legend()</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Clayton copula conditionals</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, u1_fixed <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.9</span>]):</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    conditional_vals <span class="op">=</span> [clayton_copula_conditional(u1_fixed, u2, theta) <span class="cf">for</span> u2 <span class="kw">in</span> u_vals]</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].plot(u_vals, conditional_vals, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].plot([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>], <span class="st">'k--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Independence'</span>)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'Clayton Copula</span><span class="ch">\n</span><span class="ss">$u_1 = </span><span class="sc">{</span>u1_fixed<span class="sc">}</span><span class="ss">$, $θ = </span><span class="sc">{</span>theta<span class="sc">}</span><span class="ss">$'</span>)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_xlabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_ylabel(<span class="st">'$P(U_2 ≤ u_2 | U_1 = u_1)$'</span>)</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].grid(<span class="va">True</span>)</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].legend()</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.08</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.92</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-conditional-distributions" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-conditional-distributions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-conditional-distributions-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-conditional-distributions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Conditional distributions from copulas: Gaussian vs Clayton copula
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="dependence-measures" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="dependence-measures"><span class="header-section-number">2.5</span> Dependence Measures</h3>
<p>Copulas provide natural definitions for various dependence measures that are invariant under strictly increasing transformations of the marginal variables.</p>
<p><strong>Definition 2.6 (Kendall’s Tau)</strong>: For a bivariate copula <span class="math inline">\(C\)</span>, Kendall’s tau is defined as: <span class="math display">\[\tau = 4\iint_{[0,1]^2} C(u_1, u_2) \, dC(u_1, u_2) - 1\]</span></p>
<p><strong>Definition 2.7 (Spearman’s Rho)</strong>: For a bivariate copula <span class="math inline">\(C\)</span>, Spearman’s rho is defined as: <span class="math display">\[\rho_S = 12\iint_{[0,1]^2} u_1 u_2 \, dC(u_1, u_2) - 3 = 12\iint_{[0,1]^2} C(u_1, u_2) \, du_1 du_2 - 3\]</span></p>
<p><strong>Definition 2.8 (Tail Dependence)</strong>: The upper and lower tail dependence coefficients are defined as: - <strong>Upper tail dependence</strong>: <span class="math inline">\(\lambda_U = \lim_{t \to 1^-} P(U_2 &gt; t | U_1 &gt; t) = \lim_{t \to 1^-} \frac{1 - 2t + C(t,t)}{1 - t}\)</span> - <strong>Lower tail dependence</strong>: <span class="math inline">\(\lambda_L = \lim_{t \to 0^+} P(U_2 \leq t | U_1 \leq t) = \lim_{t \to 0^+} \frac{C(t,t)}{t}\)</span></p>
<p>These measures capture different aspects of dependence that complement the information provided by linear correlation.</p>
</section>
</section>
<section id="sec-archimedean" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-archimedean"><span class="header-section-number">3</span> Archimedean Copulas</h2>
<p>Archimedean copulas form one of the most important and widely used families in copula theory. Named after Archimedes due to their connection with the functional equation that bears his name, these copulas are characterized by their generator functions and possess attractive analytical properties <span class="citation" data-cites="nelsen2006 joe1997">(<a href="#ref-nelsen2006" role="doc-biblioref">Nelsen 2006</a>; <a href="#ref-joe1997" role="doc-biblioref">Joe 1997</a>)</span>.</p>
<section id="definition-and-mathematical-structure" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="definition-and-mathematical-structure"><span class="header-section-number">3.1</span> Definition and Mathematical Structure</h3>
<p><strong>Definition 3.1 (Archimedean Copula)</strong>: A bivariate copula <span class="math inline">\(C\)</span> is Archimedean if there exists a continuous, strictly decreasing function <span class="math inline">\(\varphi: [0,1] \to [0,\infty]\)</span> with <span class="math inline">\(\varphi(1) = 0\)</span> such that:</p>
<p><span class="math display">\[C(u_1, u_2) = \varphi^{-1}(\varphi(u_1) + \varphi(u_2))\]</span></p>
<p>where <span class="math inline">\(\varphi^{-1}\)</span> is the generalized inverse of <span class="math inline">\(\varphi\)</span>. The function <span class="math inline">\(\varphi\)</span> is called the <strong>generator</strong> of the Archimedean copula.</p>
<p><strong>Theorem 3.2 (Generator Properties)</strong>: For <span class="math inline">\(\varphi\)</span> to generate a valid Archimedean copula, it must satisfy:</p>
<ol type="1">
<li><span class="math inline">\(\varphi\)</span> is continuous and strictly decreasing on <span class="math inline">\([0,1]\)</span></li>
<li><span class="math inline">\(\varphi(1) = 0\)</span> and <span class="math inline">\(\varphi(0) = \infty\)</span> (or a finite positive value)</li>
<li><span class="math inline">\(\varphi\)</span> is convex on <span class="math inline">\([0,1]\)</span></li>
</ol>
<p>The convexity condition ensures that the resulting function satisfies the 2-increasing property required for copulas.</p>
</section>
<section id="major-archimedean-copula-families" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="major-archimedean-copula-families"><span class="header-section-number">3.2</span> Major Archimedean Copula Families</h3>
<section id="clayton-copula" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="clayton-copula"><span class="header-section-number">3.2.1</span> 1. Clayton Copula</h4>
<p>The Clayton copula, introduced by Clayton (1978) <span class="citation" data-cites="clayton1978">(<a href="#ref-clayton1978" role="doc-biblioref">Clayton 1978</a>)</span>, is particularly useful for modeling lower tail dependence.</p>
<p><strong>Generator</strong>: <span class="math inline">\(\varphi(t) = t^{-\theta} - 1\)</span> for <span class="math inline">\(\theta &gt; 0\)</span></p>
<p><strong>Copula</strong>: <span class="math display">\[C_{\text{Clayton}}(u_1, u_2; \theta) = \max\left[(u_1^{-\theta} + u_2^{-\theta} - 1)^{-1/\theta}, 0\right]\]</span></p>
<p><strong>Properties</strong>: - Lower tail dependence: <span class="math inline">\(\lambda_L = 2^{-1/\theta}\)</span> - Upper tail dependence: <span class="math inline">\(\lambda_U = 0\)</span> - Kendall’s tau: <span class="math inline">\(\tau = \frac{\theta}{\theta + 2}\)</span></p>
</section>
<section id="gumbel-copula" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="gumbel-copula"><span class="header-section-number">3.2.2</span> 2. Gumbel Copula</h4>
<p>The Gumbel copula <span class="citation" data-cites="gumbel1960">(<a href="#ref-gumbel1960" role="doc-biblioref">Gumbel 1960</a>)</span> models upper tail dependence and is widely used in extreme value theory.</p>
<p><strong>Generator</strong>: <span class="math inline">\(\varphi(t) = (-\ln t)^\theta\)</span> for <span class="math inline">\(\theta \geq 1\)</span></p>
<p><strong>Copula</strong>: <span class="math display">\[C_{\text{Gumbel}}(u_1, u_2; \theta) = \exp\left(-\left[(-\ln u_1)^\theta + (-\ln u_2)^\theta\right]^{1/\theta}\right)\]</span></p>
<p><strong>Properties</strong>: - Lower tail dependence: <span class="math inline">\(\lambda_L = 0\)</span> - Upper tail dependence: <span class="math inline">\(\lambda_U = 2 - 2^{1/\theta}\)</span> - Kendall’s tau: <span class="math inline">\(\tau = 1 - 1/\theta\)</span></p>
</section>
<section id="frank-copula" class="level4" data-number="3.2.3">
<h4 data-number="3.2.3" class="anchored" data-anchor-id="frank-copula"><span class="header-section-number">3.2.3</span> 3. Frank Copula</h4>
<p>The Frank copula <span class="citation" data-cites="frank1979">(<a href="#ref-frank1979" role="doc-biblioref">Frank 1979</a>)</span> provides symmetric dependence without tail dependence.</p>
<p><strong>Generator</strong>: <span class="math inline">\(\varphi(t) = -\ln\left(\frac{e^{-\theta t} - 1}{e^{-\theta} - 1}\right)\)</span> for <span class="math inline">\(\theta \neq 0\)</span></p>
<p><strong>Copula</strong>: <span class="math display">\[C_{\text{Frank}}(u_1, u_2; \theta) = -\frac{1}{\theta}\ln\left(1 + \frac{(e^{-\theta u_1} - 1)(e^{-\theta u_2} - 1)}{e^{-\theta} - 1}\right)\]</span></p>
<p><strong>Properties</strong>: - Lower tail dependence: <span class="math inline">\(\lambda_L = 0\)</span> - Upper tail dependence: <span class="math inline">\(\lambda_U = 0\)</span> - Kendall’s tau: <span class="math inline">\(\tau = 1 - \frac{4}{\theta}\left[1 - D_1(\theta)\right]\)</span> where <span class="math inline">\(D_1\)</span> is the Debye function</p>
<div id="cell-fig-archimedean-families" class="cell" data-fig-height="15" data-fig-width="18" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArchimedeanCopulas:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implementation of major Archimedean copula families"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> clayton_copula(u1, u2, theta):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Clayton copula implementation"""</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> theta <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Clayton parameter must be positive"</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.maximum((u1<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">+</span> u2<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta), <span class="dv">0</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> clayton_generator(t, theta):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Clayton generator function"""</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> t<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gumbel_copula(u1, u2, theta):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Gumbel copula implementation"""</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> theta <span class="op">&lt;</span> <span class="dv">1</span>:</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Gumbel parameter must be &gt;= 1"</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(<span class="op">-</span>((<span class="op">-</span>np.log(u1))<span class="op">**</span>theta <span class="op">+</span> (<span class="op">-</span>np.log(u2))<span class="op">**</span>theta)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>theta))</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gumbel_generator(t, theta):</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Gumbel generator function"""</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="op">-</span>np.log(t))<span class="op">**</span>theta</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> frank_copula(u1, u2, theta):</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Frank copula implementation"""</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> theta <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> u1 <span class="op">*</span> u2  <span class="co"># Independence case</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        exp_theta <span class="op">=</span> np.exp(<span class="op">-</span>theta)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        numerator <span class="op">=</span> (np.exp(<span class="op">-</span>theta <span class="op">*</span> u1) <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (np.exp(<span class="op">-</span>theta <span class="op">*</span> u2) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        denominator <span class="op">=</span> exp_theta <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>np.log(<span class="dv">1</span> <span class="op">+</span> numerator <span class="op">/</span> denominator) <span class="op">/</span> theta</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> frank_generator(t, theta):</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Frank generator function"""</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> theta <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span>np.log(t)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>np.log((np.exp(<span class="op">-</span>theta <span class="op">*</span> t) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> (np.exp(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters for comparison</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>theta_clayton <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>theta_gumbel <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>theta_frank <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Create evaluation grid</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.99</span>, <span class="dv">50</span>)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>U1, U2 <span class="op">=</span> np.meshgrid(u, u)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute copulas</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>clayton <span class="op">=</span> ArchimedeanCopulas.clayton_copula(U1, U2, theta_clayton)</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>gumbel <span class="op">=</span> ArchimedeanCopulas.gumbel_copula(U1, U2, theta_gumbel)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>frank <span class="op">=</span> ArchimedeanCopulas.frank_copula(U1, U2, theta_frank)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">15</span>))</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Contour plots</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>levels <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">20</span>)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Clayton</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>].contourf(U1, U2, clayton, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="ss">f'Clayton Copula (θ=</span><span class="sc">{</span>theta_clayton<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Gumbel</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">1</span>].contourf(U1, U2, gumbel, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="ss">f'Gumbel Copula (θ=</span><span class="sc">{</span>theta_gumbel<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im2, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Frank</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>im3 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">2</span>].contourf(U1, U2, frank, levels<span class="op">=</span>levels, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="ss">f'Frank Copula (θ=</span><span class="sc">{</span>theta_frank<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im3, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a><span class="co"># Generator functions</span></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>t_vals <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.99</span>, <span class="dv">100</span>)</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>clayton_gen <span class="op">=</span> ArchimedeanCopulas.clayton_generator(t_vals, theta_clayton)</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>gumbel_gen <span class="op">=</span> ArchimedeanCopulas.gumbel_generator(t_vals, theta_gumbel)</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>frank_gen <span class="op">=</span> ArchimedeanCopulas.frank_generator(t_vals, theta_frank)</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t_vals, clayton_gen, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Clayton Generator'</span>)</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'t'</span>)</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'φ(t)'</span>)</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(t_vals, gumbel_gen, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Gumbel Generator'</span>)</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'t'</span>)</span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'φ(t)'</span>)</span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].plot(t_vals, frank_gen, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'Frank Generator'</span>)</span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'t'</span>)</span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'φ(t)'</span>)</span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].grid(<span class="va">True</span>)</span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a><span class="co"># Diagonal sections for tail dependence visualization</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>diag_u <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.99</span>, <span class="dv">100</span>)</span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>clayton_diag <span class="op">=</span> ArchimedeanCopulas.clayton_copula(diag_u, diag_u, theta_clayton)</span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>gumbel_diag <span class="op">=</span> ArchimedeanCopulas.gumbel_copula(diag_u, diag_u, theta_gumbel)</span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>frank_diag <span class="op">=</span> ArchimedeanCopulas.frank_copula(diag_u, diag_u, theta_frank)</span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(diag_u, clayton_diag, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Clayton'</span>)</span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(diag_u, diag_u, <span class="st">'k--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Independence'</span>)</span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(diag_u, np.minimum(diag_u, diag_u), <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Perfect dependence'</span>)</span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Clayton: Lower Tail Dependence'</span>)</span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'u'</span>)</span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'C(u,u)'</span>)</span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(diag_u, gumbel_diag, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Gumbel'</span>)</span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(diag_u, diag_u, <span class="st">'k--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Independence'</span>)</span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(diag_u, np.minimum(diag_u, diag_u), <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Perfect dependence'</span>)</span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Gumbel: Upper Tail Dependence'</span>)</span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'u'</span>)</span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'C(u,u)'</span>)</span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].plot(diag_u, frank_diag, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Frank'</span>)</span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].plot(diag_u, diag_u, <span class="st">'k--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Independence'</span>)</span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].plot(diag_u, np.minimum(diag_u, diag_u), <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Perfect dependence'</span>)</span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].set_title(<span class="st">'Frank: No Tail Dependence'</span>)</span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'u'</span>)</span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'C(u,u)'</span>)</span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].legend()</span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">2</span>].grid(<span class="va">True</span>)</span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.08</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.92</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-archimedean-families" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-archimedean-families-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-archimedean-families-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-archimedean-families-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Comparison of major Archimedean copula families with their generators and dependence properties
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="simulation-from-archimedean-copulas" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="simulation-from-archimedean-copulas"><span class="header-section-number">3.3</span> Simulation from Archimedean Copulas</h3>
<p>Simulation from Archimedean copulas can be performed using the conditional distribution method or specialized algorithms for specific families.</p>
<p><strong>Theorem 3.3 (Conditional Simulation Method)</strong>: For an Archimedean copula with generator <span class="math inline">\(\varphi\)</span>, if <span class="math inline">\((U_1, U_2) \sim C\)</span>, then:</p>
<p><span class="math display">\[U_2 | U_1 = u_1 \sim F^{-1}_{2|1}(v | u_1) = \varphi^{-1}\left(\frac{\varphi'(u_1)}{\varphi'(\varphi^{-1}(\varphi(u_1) + \varphi(v)))}\right)\]</span></p>
<p>where <span class="math inline">\(V \sim \text{Uniform}(0,1)\)</span> is independent of <span class="math inline">\(U_1\)</span>.</p>
<div id="cell-fig-archimedean-simulation" class="cell" data-fig-height="9" data-fig-width="18" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArchimedeanSimulation:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulation methods for Archimedean copulas"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_clayton(n, theta, seed<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate from Clayton copula using Laplace transform method"""</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> seed <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            np.random.seed(seed)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate exponential random variable</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        gamma_var <span class="op">=</span> np.random.gamma(<span class="dv">1</span><span class="op">/</span>theta, <span class="dv">1</span>, n)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate uniform random variables</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        u1 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        u2 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform using Laplace transform</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        v1 <span class="op">=</span> (<span class="op">-</span>np.log(u1) <span class="op">/</span> gamma_var)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> (<span class="op">-</span>np.log(u2) <span class="op">/</span> gamma_var)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v1, v2</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_gumbel(n, theta, seed<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate from Gumbel copula"""</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> seed <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            np.random.seed(seed)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate stable random variable</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>theta</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.random.exponential(<span class="dv">1</span>, n)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Stable random variable simulation (simplified)</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        stable <span class="op">=</span> (np.sin(alpha <span class="op">*</span> np.pi <span class="op">*</span> w) <span class="op">/</span> (np.sin(np.pi <span class="op">*</span> w))<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>alpha)) <span class="op">*</span> <span class="op">\</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>                 (np.sin((<span class="dv">1</span><span class="op">-</span>alpha) <span class="op">*</span> np.pi <span class="op">*</span> w) <span class="op">/</span> z)<span class="op">**</span>((<span class="dv">1</span><span class="op">-</span>alpha)<span class="op">/</span>alpha)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate uniform variables and transform</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        u1 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        u2 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        v1 <span class="op">=</span> np.exp(<span class="op">-</span>(<span class="op">-</span>np.log(u1) <span class="op">/</span> stable)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>theta))</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> np.exp(<span class="op">-</span>(<span class="op">-</span>np.log(u2) <span class="op">/</span> stable)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>theta))</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v1, v2</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_frank(n, theta, seed<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate from Frank copula using conditional method"""</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> seed <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>            np.random.seed(seed)</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        u1 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> theta <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>            u2 <span class="op">=</span> v</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Conditional distribution method</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>            exp_theta_u1 <span class="op">=</span> np.exp(<span class="op">-</span>theta <span class="op">*</span> u1)</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>            exp_theta <span class="op">=</span> np.exp(<span class="op">-</span>theta)</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>            numerator <span class="op">=</span> <span class="op">-</span>np.log(<span class="dv">1</span> <span class="op">+</span> v <span class="op">*</span> (exp_theta_u1 <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> (exp_theta <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>            u2 <span class="op">=</span> numerator <span class="op">/</span> theta</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u1, u2</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate from different copulas</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>clayton_data <span class="op">=</span> ArchimedeanSimulation.simulate_clayton(n, theta<span class="op">=</span><span class="dv">2</span>, seed<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a><span class="co"># For Gumbel and Frank, use conditional method for stability</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>u1_gumbel <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>v_gumbel <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a><span class="co"># Simplified Gumbel simulation</span></span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>gumbel_data <span class="op">=</span> (u1_gumbel, v_gumbel)  <span class="co"># Placeholder for proper implementation</span></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>u1_frank <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>v_frank <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>frank_data <span class="op">=</span> ArchimedeanSimulation.simulate_frank(n, theta<span class="op">=</span><span class="dv">5</span>, seed<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">9</span>))</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a><span class="co"># Scatter plots</span></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].scatter(clayton_data[<span class="dv">0</span>], clayton_data[<span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Clayton Copula Simulation</span><span class="ch">\n</span><span class="st">(θ=2, Lower Tail Dependence)'</span>)</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'$U_1$'</span>)</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'$U_2$'</span>)</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a><span class="co"># For demonstration, use theoretical copula values for Gumbel</span></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>u_sim <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, (n, <span class="dv">2</span>))</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>gumbel_theoretical <span class="op">=</span> ArchimedeanCopulas.gumbel_copula(u_sim[:, <span class="dv">0</span>], u_sim[:, <span class="dv">1</span>], <span class="dv">2</span>)</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].scatter(u_sim[:, <span class="dv">0</span>], u_sim[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span>gumbel_theoretical, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Gumbel Copula Pattern</span><span class="ch">\n</span><span class="st">(θ=2, Upper Tail Dependence)'</span>)</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'$U_1$'</span>)</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'$U_2$'</span>)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].scatter(frank_data[<span class="dv">0</span>], frank_data[<span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="st">'Frank Copula Simulation</span><span class="ch">\n</span><span class="st">(θ=5, No Tail Dependence)'</span>)</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'$U_1$'</span>)</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'$U_2$'</span>)</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a><span class="co"># Density plots comparing with theoretical</span></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a><span class="co"># Clayton empirical density</span></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>clayton_kde <span class="op">=</span> gaussian_kde([clayton_data[<span class="dv">0</span>], clayton_data[<span class="dv">1</span>]])</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>u_grid <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">50</span>)</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>U1_grid, U2_grid <span class="op">=</span> np.meshgrid(u_grid, u_grid)</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> np.vstack([U1_grid.ravel(), U2_grid.ravel()])</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>clayton_density <span class="op">=</span> clayton_kde(positions).reshape(U1_grid.shape)</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>].contourf(U1_grid, U2_grid, clayton_density, levels<span class="op">=</span><span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'Blues'</span>)</span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Clayton Empirical Density'</span>)</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a><span class="co"># Theoretical Clayton density (simplified)</span></span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>clayton_theoretical <span class="op">=</span> ArchimedeanCopulas.clayton_copula(U1_grid, U2_grid, <span class="dv">2</span>)</span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">1</span>].contourf(U1_grid, U2_grid, clayton_theoretical, levels<span class="op">=</span><span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'Blues'</span>)</span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Clayton Theoretical'</span>)</span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a><span class="co"># Frank empirical density</span></span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>frank_kde <span class="op">=</span> gaussian_kde([frank_data[<span class="dv">0</span>], frank_data[<span class="dv">1</span>]])</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>frank_density <span class="op">=</span> frank_kde(positions).reshape(U1_grid.shape)</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>im3 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">2</span>].contourf(U1_grid, U2_grid, frank_density, levels<span class="op">=</span><span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'Greens'</span>)</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'Frank Empirical Density'</span>)</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.08</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.92</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-archimedean-simulation" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-archimedean-simulation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-archimedean-simulation-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-archimedean-simulation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Simulation from Archimedean copulas demonstrating different dependence patterns
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="multivariate-extensions" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="multivariate-extensions"><span class="header-section-number">3.4</span> Multivariate Extensions</h3>
<p>Archimedean copulas can be extended to higher dimensions while maintaining their attractive properties.</p>
<p><strong>Definition 3.4 (Multivariate Archimedean Copula)</strong>: A <span class="math inline">\(d\)</span>-dimensional Archimedean copula is given by:</p>
<p><span class="math display">\[C(u_1, \ldots, u_d) = \varphi^{-1}\left(\sum_{i=1}^d \varphi(u_i)\right)\]</span></p>
<p>However, not all bivariate Archimedean generators extend validly to higher dimensions. The generator must satisfy additional conditions for <span class="math inline">\(d &gt; 2\)</span>.</p>
<p><strong>Theorem 3.5 (Necessary and Sufficient Conditions)</strong>: A generator <span class="math inline">\(\varphi\)</span> produces a valid <span class="math inline">\(d\)</span>-dimensional Archimedean copula if and only if <span class="math inline">\(\varphi^{-1}\)</span> is completely monotonic on <span class="math inline">\([0, \infty)\)</span>, i.e., for all <span class="math inline">\(k \geq 0\)</span>:</p>
<p><span class="math display">\[(-1)^k \frac{d^k}{dx^k}\varphi^{-1}(x) \geq 0\]</span></p>
<p>This condition is automatically satisfied for <span class="math inline">\(d = 2\)</span> but becomes restrictive for higher dimensions, limiting the parameter ranges of many common families.</p>
</section>
</section>
<section id="sec-elliptical" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-elliptical"><span class="header-section-number">4</span> Elliptical Copulas</h2>
<p>Elliptical copulas arise from elliptical distributions and include the widely used Gaussian and Student’s t copulas. These copulas are particularly important in financial applications due to their connection with well-established multivariate distributions <span class="citation" data-cites="embrechts2002 mcneil2015quantitative">(<a href="#ref-embrechts2002" role="doc-biblioref">Embrechts, McNeil, and Straumann 2002</a>; <a href="#ref-mcneil2015quantitative" role="doc-biblioref">McNeil, Frey, and Embrechts 2015</a>)</span>.</p>
<section id="gaussian-copula" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="gaussian-copula"><span class="header-section-number">4.1</span> Gaussian Copula</h3>
<p>The Gaussian copula is derived from the multivariate normal distribution and is characterized by the linear correlation matrix.</p>
<p><strong>Definition 4.1 (Gaussian Copula)</strong>: The <span class="math inline">\(d\)</span>-dimensional Gaussian copula with correlation matrix <span class="math inline">\(\mathbf{R}\)</span> is given by:</p>
<p><span class="math display">\[C^{Ga}(u_1, \ldots, u_d; \mathbf{R}) = \Phi_{\mathbf{R}}(\Phi^{-1}(u_1), \ldots, \Phi^{-1}(u_d))\]</span></p>
<p>where <span class="math inline">\(\Phi\)</span> is the standard normal CDF and <span class="math inline">\(\Phi_{\mathbf{R}}\)</span> is the multivariate normal CDF with correlation matrix <span class="math inline">\(\mathbf{R}\)</span>.</p>
<p><strong>Properties</strong>: - No tail dependence: <span class="math inline">\(\lambda_L = \lambda_U = 0\)</span> - Kendall’s tau: <span class="math inline">\(\tau_{ij} = \frac{2}{\pi}\arcsin(\rho_{ij})\)</span> where <span class="math inline">\(\rho_{ij}\)</span> is the correlation between variables <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span></p>
</section>
<section id="students-t-copula" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="students-t-copula"><span class="header-section-number">4.2</span> Student’s t Copula</h3>
<p>The Student’s t copula incorporates tail dependence through the degrees of freedom parameter.</p>
<p><strong>Definition 4.2 (Student’s t Copula)</strong>: The <span class="math inline">\(d\)</span>-dimensional Student’s t copula with correlation matrix <span class="math inline">\(\mathbf{R}\)</span> and <span class="math inline">\(\nu\)</span> degrees of freedom is:</p>
<p><span class="math display">\[C^t(u_1, \ldots, u_d; \mathbf{R}, \nu) = t_{\mathbf{R},\nu}(t_\nu^{-1}(u_1), \ldots, t_\nu^{-1}(u_d))\]</span></p>
<p>where <span class="math inline">\(t_\nu\)</span> is the univariate Student’s t CDF with <span class="math inline">\(\nu\)</span> degrees of freedom.</p>
<p><strong>Properties</strong>: - Symmetric tail dependence: <span class="math inline">\(\lambda_L = \lambda_U = 2t_{\nu+1}\left(-\sqrt{\frac{(\nu+1)(1-\rho)}{1+\rho}}\right)\)</span> - As <span class="math inline">\(\nu \to \infty\)</span>, the t copula converges to the Gaussian copula</p>
<div id="cell-fig-elliptical-copulas" class="cell" data-fig-height="12" data-fig-width="18" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> EllipticalCopulas:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implementation of elliptical copula families"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gaussian_copula(u1, u2, rho):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Gaussian copula implementation"""</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        z1 <span class="op">=</span> stats.norm.ppf(u1)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        z2 <span class="op">=</span> stats.norm.ppf(u2)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Bivariate normal CDF</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        cov <span class="op">=</span> [[<span class="dv">1</span>, rho], [rho, <span class="dv">1</span>]]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Vectorized approach for multiple points</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.isscalar(z1):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> stats.multivariate_normal.cdf([z1, z2], mean, cov)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> np.zeros_like(z1)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(z1.flat)):</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">=</span> np.unravel_index(i, z1.shape)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                result[idx] <span class="op">=</span> stats.multivariate_normal.cdf([z1[idx], z2[idx]], mean, cov)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> result</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> t_copula(u1, u2, rho, nu):</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Student's t copula implementation"""</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        t1 <span class="op">=</span> stats.t.ppf(u1, nu)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        t2 <span class="op">=</span> stats.t.ppf(u2, nu)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Bivariate t distribution CDF (approximation)</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.isscalar(t1):</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For scalar inputs, use numerical integration</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>            <span class="im">from</span> scipy.integrate <span class="im">import</span> dblquad</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>            <span class="kw">def</span> integrand(x, y):</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> stats.multivariate_t.pdf([x, y], loc<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], </span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>                                              shape<span class="op">=</span>[[<span class="dv">1</span>, rho], [rho, <span class="dv">1</span>]], df<span class="op">=</span>nu)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>            result, _ <span class="op">=</span> dblquad(integrand, <span class="op">-</span>np.inf, t1, <span class="kw">lambda</span> x: <span class="op">-</span>np.inf, <span class="kw">lambda</span> x: t2)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> result</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For array inputs, use approximation</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform to normal and apply adjustment</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>            z1 <span class="op">=</span> stats.norm.ppf(stats.t.cdf(t1, nu))</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>            z2 <span class="op">=</span> stats.norm.ppf(stats.t.cdf(t2, nu))</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> np.zeros_like(z1)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(z1.flat)):</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">=</span> np.unravel_index(i, z1.shape)</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> (np.isfinite(z1[idx]) <span class="kw">and</span> np.isfinite(z2[idx])):</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>                    result[idx] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>                    result[idx] <span class="op">=</span> stats.multivariate_normal.cdf([z1[idx], z2[idx]], </span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>                                                              [<span class="dv">0</span>, <span class="dv">0</span>], [[<span class="dv">1</span>, rho], [rho, <span class="dv">1</span>]])</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> result</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>nu_values <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">10</span>]</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Create evaluation grid</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.99</span>, <span class="dv">50</span>)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>U1, U2 <span class="op">=</span> np.meshgrid(u, u)</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">15</span>))</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian copula</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>gaussian_cop <span class="op">=</span> EllipticalCopulas.gaussian_copula(U1, U2, rho)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>].contourf(U1, U2, gaussian_cop, levels<span class="op">=</span><span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="ss">f'Gaussian Copula</span><span class="ch">\n</span><span class="ss">(ρ=</span><span class="sc">{</span>rho<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a><span class="co"># Student's t copulas with different degrees of freedom</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, nu <span class="kw">in</span> <span class="bu">enumerate</span>(nu_values):</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simplified t copula visualization using simulation</span></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>    n_sim <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate from multivariate t distribution</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>    mean <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>    cov <span class="op">=</span> [[<span class="dv">1</span>, rho], [rho, <span class="dv">1</span>]]</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> stats.multivariate_t.rvs(loc<span class="op">=</span>mean, shape<span class="op">=</span>cov, df<span class="op">=</span>nu, size<span class="op">=</span>n_sim)</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Transform to uniform margins</span></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>    u1_sim <span class="op">=</span> stats.t.cdf(samples[:, <span class="dv">0</span>], nu)</span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>    u2_sim <span class="op">=</span> stats.t.cdf(samples[:, <span class="dv">1</span>], nu)</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i<span class="op">+</span><span class="dv">1</span>].scatter(u1_sim, u2_sim, alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i<span class="op">+</span><span class="dv">1</span>].set_title(<span class="ss">f'Student</span><span class="ch">\'</span><span class="ss">s t Copula</span><span class="ch">\n</span><span class="ss">(ρ=</span><span class="sc">{</span>rho<span class="sc">}</span><span class="ss">, ν=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i<span class="op">+</span><span class="dv">1</span>].set_xlabel(<span class="st">'$u_1$'</span>)</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i<span class="op">+</span><span class="dv">1</span>].set_ylabel(<span class="st">'$u_2$'</span>)</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Tail dependence analysis</span></span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>tail_probs <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="fl">0.1</span>, <span class="dv">50</span>)</span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian (no tail dependence)</span></span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>gaussian_lower <span class="op">=</span> np.zeros_like(tail_probs)</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>gaussian_upper <span class="op">=</span> np.zeros_like(tail_probs)</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(tail_probs, gaussian_lower, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Lower tail'</span>)</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(tail_probs, gaussian_upper, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Upper tail'</span>)</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Gaussian: No Tail Dependence'</span>)</span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Tail probability'</span>)</span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Tail dependence'</span>)</span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a><span class="co"># t copula tail dependence</span></span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, nu <span class="kw">in</span> <span class="bu">enumerate</span>(nu_values):</span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Theoretical tail dependence coefficient</span></span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a>    lambda_tail <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> stats.t.cdf(<span class="op">-</span>np.sqrt((nu <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> rho) <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> rho)), nu <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Approximate tail behavior</span></span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a>    t_lower <span class="op">=</span> np.full_like(tail_probs, lambda_tail)</span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a>    t_upper <span class="op">=</span> np.full_like(tail_probs, lambda_tail)</span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].plot(tail_probs, t_lower, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Lower tail (λ=</span><span class="sc">{</span>lambda_tail<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].plot(tail_probs, t_upper, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Upper tail (λ=</span><span class="sc">{</span>lambda_tail<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].set_title(<span class="ss">f't Copula Tail Dependence</span><span class="ch">\n</span><span class="ss">(ν=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].set_xlabel(<span class="st">'Tail probability'</span>)</span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].set_ylabel(<span class="st">'Tail dependence'</span>)</span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].legend()</span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a><span class="co"># Correlation vs Kendall's tau relationships</span></span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a>rho_range <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">0.99</span>, <span class="fl">0.99</span>, <span class="dv">100</span>)</span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a>tau_gaussian <span class="op">=</span> (<span class="dv">2</span><span class="op">/</span>np.pi) <span class="op">*</span> np.arcsin(rho_range)</span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-132"><a href="#cb6-132" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(rho_range, tau_gaussian, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-133"><a href="#cb6-133" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Gaussian: ρ vs τ'</span>)</span>
<span id="cb6-134"><a href="#cb6-134" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Correlation ρ'</span>)</span>
<span id="cb6-135"><a href="#cb6-135" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Kendall</span><span class="ch">\'</span><span class="st">s τ'</span>)</span>
<span id="cb6-136"><a href="#cb6-136" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb6-137"><a href="#cb6-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-138"><a href="#cb6-138" aria-hidden="true" tabindex="-1"></a><span class="co"># For t copula, Kendall's tau is approximately the same as Gaussian</span></span>
<span id="cb6-139"><a href="#cb6-139" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, nu <span class="kw">in</span> <span class="bu">enumerate</span>(nu_values):</span>
<span id="cb6-140"><a href="#cb6-140" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>].plot(rho_range, tau_gaussian, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb6-141"><a href="#cb6-141" aria-hidden="true" tabindex="-1"></a>                     label<span class="op">=</span><span class="ss">f'τ ≈ (2/π)arcsin(ρ)'</span>)</span>
<span id="cb6-142"><a href="#cb6-142" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>].set_title(<span class="ss">f't Copula: ρ vs τ</span><span class="ch">\n</span><span class="ss">(ν=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb6-143"><a href="#cb6-143" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>].set_xlabel(<span class="st">'Correlation ρ'</span>)</span>
<span id="cb6-144"><a href="#cb6-144" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>].set_ylabel(<span class="st">'Kendall</span><span class="ch">\'</span><span class="st">s τ'</span>)</span>
<span id="cb6-145"><a href="#cb6-145" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>].legend()</span>
<span id="cb6-146"><a href="#cb6-146" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb6-147"><a href="#cb6-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-148"><a href="#cb6-148" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.95</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.4</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb6-149"><a href="#cb6-149" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-elliptical-copulas" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-elliptical-copulas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-elliptical-copulas-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-elliptical-copulas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Comparison of Gaussian and Student’s t copulas with tail dependence analysis
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-estimation" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-estimation"><span class="header-section-number">5</span> Parameter Estimation</h2>
<p>Parameter estimation in copula models presents unique challenges due to the separation of marginal distributions from the dependence structure. This section covers the major estimation approaches, their theoretical properties, and practical implementation considerations.</p>
<section id="estimation-approaches" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="estimation-approaches"><span class="header-section-number">5.1</span> Estimation Approaches</h3>
<section id="inference-functions-for-margins-ifm" class="level4" data-number="5.1.1">
<h4 data-number="5.1.1" class="anchored" data-anchor-id="inference-functions-for-margins-ifm"><span class="header-section-number">5.1.1</span> 1. Inference Functions for Margins (IFM)</h4>
<p>The IFM method, proposed by <span class="citation" data-cites="joe1997">Joe (<a href="#ref-joe1997" role="doc-biblioref">1997</a>)</span>, is a two-step semiparametric approach that estimates marginal parameters and copula parameters separately.</p>
<p><strong>Step 1</strong>: Estimate marginal parameters <span class="math inline">\(\hat{\boldsymbol{\theta}}_j\)</span> for each margin <span class="math inline">\(j = 1, \ldots, d\)</span>: <span class="math display">\[\hat{\boldsymbol{\theta}}_j = \arg\max_{\boldsymbol{\theta}_j} \sum_{i=1}^n \log f_j(x_{ij}; \boldsymbol{\theta}_j)\]</span></p>
<p><strong>Step 2</strong>: Transform data to uniform margins and estimate copula parameters: <span class="math display">\[\hat{\boldsymbol{\alpha}} = \arg\max_{\boldsymbol{\alpha}} \sum_{i=1}^n \log c(F_1(x_{i1}; \hat{\boldsymbol{\theta}}_1), \ldots, F_d(x_{id}; \hat{\boldsymbol{\theta}}_d); \boldsymbol{\alpha})\]</span></p>
<p><strong>Advantages</strong>: Computationally efficient, robust to marginal misspecification <strong>Disadvantages</strong>: Not fully efficient, ignores dependence in marginal estimation</p>
</section>
<section id="maximum-likelihood-estimation-mle" class="level4" data-number="5.1.2">
<h4 data-number="5.1.2" class="anchored" data-anchor-id="maximum-likelihood-estimation-mle"><span class="header-section-number">5.1.2</span> 2. Maximum Likelihood Estimation (MLE)</h4>
<p>Full MLE jointly estimates all parameters by maximizing the complete likelihood: <span class="math display">\[\hat{\boldsymbol{\theta}}, \hat{\boldsymbol{\alpha}} = \arg\max_{\boldsymbol{\theta}, \boldsymbol{\alpha}} \sum_{i=1}^n \log f(\mathbf{x}_i; \boldsymbol{\theta}, \boldsymbol{\alpha})\]</span></p>
<p>where the joint density is: <span class="math display">\[f(\mathbf{x}; \boldsymbol{\theta}, \boldsymbol{\alpha}) = c(F_1(x_1; \boldsymbol{\theta}_1), \ldots, F_d(x_d; \boldsymbol{\theta}_d); \boldsymbol{\alpha}) \prod_{j=1}^d f_j(x_j; \boldsymbol{\theta}_j)\]</span></p>
<p><strong>Advantages</strong>: Fully efficient, optimal statistical properties <strong>Disadvantages</strong>: Computationally demanding, sensitive to marginal misspecification</p>
</section>
<section id="canonical-maximum-likelihood-cml" class="level4" data-number="5.1.3">
<h4 data-number="5.1.3" class="anchored" data-anchor-id="canonical-maximum-likelihood-cml"><span class="header-section-number">5.1.3</span> 3. Canonical Maximum Likelihood (CML)</h4>
<p>CML, proposed by <span class="citation" data-cites="genest1995">Genest, Rémillard, and Beaudoin (<a href="#ref-genest1995" role="doc-biblioref">2009</a>)</span>, uses ranks to avoid specifying marginal distributions: <span class="math display">\[\hat{\boldsymbol{\alpha}} = \arg\max_{\boldsymbol{\alpha}} \sum_{i=1}^n \log c\left(\frac{R_{i1}}{n+1}, \ldots, \frac{R_{id}}{n+1}; \boldsymbol{\alpha}\right)\]</span></p>
<p>where <span class="math inline">\(R_{ij}\)</span> is the rank of <span class="math inline">\(x_{ij}\)</span> among <span class="math inline">\(\{x_{1j}, \ldots, x_{nj}\}\)</span>.</p>
<p><strong>Advantages</strong>: Distribution-free, robust to marginal specification <strong>Disadvantages</strong>: Less efficient than parametric methods, limited to copula parameters</p>
<div id="cell-fig-estimation-methods" class="cell" data-fig-height="15" data-fig-width="20" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CopulaEstimation:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implementation of different copula parameter estimation methods"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n, <span class="va">self</span>.d <span class="op">=</span> data.shape</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> estimate_marginals(<span class="va">self</span>, distribution<span class="op">=</span><span class="st">'t'</span>):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Estimate marginal distribution parameters"""</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.marginal_params <span class="op">=</span> []</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.marginal_dists <span class="op">=</span> []</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.d):</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> distribution <span class="op">==</span> <span class="st">'t'</span>:</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Fit Student's t distribution</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> stats.t.fit(<span class="va">self</span>.data[:, j])</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_params.append(params)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_dists.append(<span class="st">'t'</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> distribution <span class="op">==</span> <span class="st">'normal'</span>:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Fit normal distribution</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> stats.norm.fit(<span class="va">self</span>.data[:, j])</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_params.append(params)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_dists.append(<span class="st">'normal'</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> distribution <span class="op">==</span> <span class="st">'empirical'</span>:</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Use empirical distribution</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_params.append(<span class="va">None</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_dists.append(<span class="st">'empirical'</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform_to_uniform(<span class="va">self</span>, method<span class="op">=</span><span class="st">'parametric'</span>):</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Transform data to uniform margins"""</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.uniform_data <span class="op">=</span> np.zeros_like(<span class="va">self</span>.data)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.d):</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> method <span class="op">==</span> <span class="st">'parametric'</span> <span class="kw">and</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'marginal_params'</span>):</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.marginal_dists[j] <span class="op">==</span> <span class="st">'t'</span>:</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>                    params <span class="op">=</span> <span class="va">self</span>.marginal_params[j]</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.uniform_data[:, j] <span class="op">=</span> stats.t.cdf(<span class="va">self</span>.data[:, j], <span class="op">*</span>params)</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> <span class="va">self</span>.marginal_dists[j] <span class="op">==</span> <span class="st">'normal'</span>:</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>                    params <span class="op">=</span> <span class="va">self</span>.marginal_params[j]</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.uniform_data[:, j] <span class="op">=</span> stats.norm.cdf(<span class="va">self</span>.data[:, j], <span class="op">*</span>params)</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> method <span class="op">==</span> <span class="st">'empirical'</span> <span class="kw">or</span> <span class="va">self</span>.marginal_dists[j] <span class="op">==</span> <span class="st">'empirical'</span>:</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Use empirical CDF (ranks)</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>                ranks <span class="op">=</span> stats.rankdata(<span class="va">self</span>.data[:, j])</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.uniform_data[:, j] <span class="op">=</span> ranks <span class="op">/</span> (<span class="va">self</span>.n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> estimate_gaussian_copula(<span class="va">self</span>, method<span class="op">=</span><span class="st">'ifm'</span>):</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Estimate Gaussian copula parameters using different methods"""</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> method <span class="op">==</span> <span class="st">'ifm'</span>:</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Two-step estimation</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'uniform_data'</span>):</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.transform_to_uniform(<span class="st">'parametric'</span>)</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform to normal space and estimate correlation</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>            normal_data <span class="op">=</span> stats.norm.ppf(np.clip(<span class="va">self</span>.uniform_data, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>            correlation <span class="op">=</span> np.corrcoef(normal_data.T)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> method <span class="op">==</span> <span class="st">'cml'</span>:</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Canonical maximum likelihood using ranks</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.transform_to_uniform(<span class="st">'empirical'</span>)</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>            normal_data <span class="op">=</span> stats.norm.ppf(np.clip(<span class="va">self</span>.uniform_data, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>            correlation <span class="op">=</span> np.corrcoef(normal_data.T)</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> correlation</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> estimate_clayton_copula(<span class="va">self</span>, method<span class="op">=</span><span class="st">'ifm'</span>):</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Estimate Clayton copula parameter"""</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'uniform_data'</span>):</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.transform_to_uniform(<span class="st">'parametric'</span> <span class="cf">if</span> method <span class="op">==</span> <span class="st">'ifm'</span> <span class="cf">else</span> <span class="st">'empirical'</span>)</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Method of moments estimator for Clayton copula</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Kendall's tau relationship: tau = theta / (theta + 2)</span></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.d <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>            tau <span class="op">=</span> stats.kendalltau(<span class="va">self</span>.uniform_data[:, <span class="dv">0</span>], <span class="va">self</span>.uniform_data[:, <span class="dv">1</span>])[<span class="dv">0</span>]</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> tau <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>                theta_hat <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> tau <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> tau)</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>                theta_hat <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># Small positive value</span></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For multivariate case, use average pairwise tau</span></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>            taus <span class="op">=</span> []</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.d):</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, <span class="va">self</span>.d):</span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>                    tau_ij <span class="op">=</span> stats.kendalltau(<span class="va">self</span>.uniform_data[:, i], <span class="va">self</span>.uniform_data[:, j])[<span class="dv">0</span>]</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> tau_ij <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>                        taus.append(tau_ij)</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> taus:</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>                mean_tau <span class="op">=</span> np.mean(taus)</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>                theta_hat <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> mean_tau <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> mean_tau)</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>                theta_hat <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(theta_hat, <span class="fl">0.1</span>)  <span class="co"># Ensure positive parameter</span></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bootstrap_confidence_intervals(<span class="va">self</span>, estimator_func, n_bootstrap<span class="op">=</span><span class="dv">500</span>, alpha<span class="op">=</span><span class="fl">0.05</span>):</span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Bootstrap confidence intervals for parameter estimates"""</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>        bootstrap_estimates <span class="op">=</span> []</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_bootstrap):</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Resample data</span></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>            indices <span class="op">=</span> np.random.choice(<span class="va">self</span>.n, <span class="va">self</span>.n, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>            bootstrap_data <span class="op">=</span> <span class="va">self</span>.data[indices]</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create temporary estimator</span></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>            temp_estimator <span class="op">=</span> CopulaEstimation(bootstrap_data)</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>            temp_estimator.estimate_marginals(distribution<span class="op">=</span><span class="st">'t'</span>)</span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get parameter estimate</span></span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a>            param_estimate <span class="op">=</span> estimator_func(temp_estimator)</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a>            bootstrap_estimates.append(param_estimate)</span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a>        bootstrap_estimates <span class="op">=</span> np.array(bootstrap_estimates)</span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate confidence intervals</span></span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> bootstrap_estimates.ndim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> np.percentile(bootstrap_estimates, <span class="dv">100</span> <span class="op">*</span> alpha <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> np.percentile(bootstrap_estimates, <span class="dv">100</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> alpha <span class="op">/</span> <span class="dv">2</span>))</span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lower, upper</span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For matrices (like correlation matrices)</span></span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> np.percentile(bootstrap_estimates, <span class="dv">100</span> <span class="op">*</span> alpha <span class="op">/</span> <span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> np.percentile(bootstrap_estimates, <span class="dv">100</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> alpha <span class="op">/</span> <span class="dv">2</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-123"><a href="#cb7-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lower, upper</span>
<span id="cb7-124"><a href="#cb7-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-125"><a href="#cb7-125" aria-hidden="true" tabindex="-1"></a><span class="co"># Monte Carlo study comparing estimation methods</span></span>
<span id="cb7-126"><a href="#cb7-126" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb7-127"><a href="#cb7-127" aria-hidden="true" tabindex="-1"></a>n_obs <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">250</span>, <span class="dv">500</span>, <span class="dv">1000</span>]</span>
<span id="cb7-128"><a href="#cb7-128" aria-hidden="true" tabindex="-1"></a>n_simulations <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb7-129"><a href="#cb7-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-130"><a href="#cb7-130" aria-hidden="true" tabindex="-1"></a><span class="co"># True parameters</span></span>
<span id="cb7-131"><a href="#cb7-131" aria-hidden="true" tabindex="-1"></a>true_rho <span class="op">=</span> <span class="fl">0.6</span></span>
<span id="cb7-132"><a href="#cb7-132" aria-hidden="true" tabindex="-1"></a>true_theta_clayton <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb7-133"><a href="#cb7-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-134"><a href="#cb7-134" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage for results</span></span>
<span id="cb7-135"><a href="#cb7-135" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {</span>
<span id="cb7-136"><a href="#cb7-136" aria-hidden="true" tabindex="-1"></a>    <span class="st">'sample_size'</span>: [],</span>
<span id="cb7-137"><a href="#cb7-137" aria-hidden="true" tabindex="-1"></a>    <span class="st">'method'</span>: [],</span>
<span id="cb7-138"><a href="#cb7-138" aria-hidden="true" tabindex="-1"></a>    <span class="st">'copula'</span>: [],</span>
<span id="cb7-139"><a href="#cb7-139" aria-hidden="true" tabindex="-1"></a>    <span class="st">'bias'</span>: [],</span>
<span id="cb7-140"><a href="#cb7-140" aria-hidden="true" tabindex="-1"></a>    <span class="st">'rmse'</span>: [],</span>
<span id="cb7-141"><a href="#cb7-141" aria-hidden="true" tabindex="-1"></a>    <span class="st">'coverage'</span>: []</span>
<span id="cb7-142"><a href="#cb7-142" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-143"><a href="#cb7-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-144"><a href="#cb7-144" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">15</span>))</span>
<span id="cb7-145"><a href="#cb7-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-146"><a href="#cb7-146" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation study</span></span>
<span id="cb7-147"><a href="#cb7-147" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, n <span class="kw">in</span> <span class="bu">enumerate</span>(n_obs):</span>
<span id="cb7-148"><a href="#cb7-148" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Running simulation for n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-149"><a href="#cb7-149" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-150"><a href="#cb7-150" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gaussian copula results</span></span>
<span id="cb7-151"><a href="#cb7-151" aria-hidden="true" tabindex="-1"></a>    gaussian_ifm_estimates <span class="op">=</span> []</span>
<span id="cb7-152"><a href="#cb7-152" aria-hidden="true" tabindex="-1"></a>    gaussian_cml_estimates <span class="op">=</span> []</span>
<span id="cb7-153"><a href="#cb7-153" aria-hidden="true" tabindex="-1"></a>    gaussian_mle_estimates <span class="op">=</span> []</span>
<span id="cb7-154"><a href="#cb7-154" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-155"><a href="#cb7-155" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clayton copula results  </span></span>
<span id="cb7-156"><a href="#cb7-156" aria-hidden="true" tabindex="-1"></a>    clayton_ifm_estimates <span class="op">=</span> []</span>
<span id="cb7-157"><a href="#cb7-157" aria-hidden="true" tabindex="-1"></a>    clayton_cml_estimates <span class="op">=</span> []</span>
<span id="cb7-158"><a href="#cb7-158" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-159"><a href="#cb7-159" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> sim <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb7-160"><a href="#cb7-160" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate data from Gaussian copula</span></span>
<span id="cb7-161"><a href="#cb7-161" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb7-162"><a href="#cb7-162" aria-hidden="true" tabindex="-1"></a>        cov <span class="op">=</span> [[<span class="dv">1</span>, true_rho], [true_rho, <span class="dv">1</span>]]</span>
<span id="cb7-163"><a href="#cb7-163" aria-hidden="true" tabindex="-1"></a>        normal_data <span class="op">=</span> np.random.multivariate_normal(mean, cov, n)</span>
<span id="cb7-164"><a href="#cb7-164" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-165"><a href="#cb7-165" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform to different margins</span></span>
<span id="cb7-166"><a href="#cb7-166" aria-hidden="true" tabindex="-1"></a>        data_gaussian <span class="op">=</span> np.column_stack([</span>
<span id="cb7-167"><a href="#cb7-167" aria-hidden="true" tabindex="-1"></a>            stats.t.ppf(stats.norm.cdf(normal_data[:, <span class="dv">0</span>]), df<span class="op">=</span><span class="dv">5</span>, scale<span class="op">=</span><span class="fl">1.5</span>),</span>
<span id="cb7-168"><a href="#cb7-168" aria-hidden="true" tabindex="-1"></a>            stats.expon.ppf(stats.norm.cdf(normal_data[:, <span class="dv">1</span>]), scale<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb7-169"><a href="#cb7-169" aria-hidden="true" tabindex="-1"></a>        ])</span>
<span id="cb7-170"><a href="#cb7-170" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-171"><a href="#cb7-171" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate data from Clayton copula</span></span>
<span id="cb7-172"><a href="#cb7-172" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Using simple transformation method</span></span>
<span id="cb7-173"><a href="#cb7-173" aria-hidden="true" tabindex="-1"></a>        u1 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb7-174"><a href="#cb7-174" aria-hidden="true" tabindex="-1"></a>        u2 <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>, n)</span>
<span id="cb7-175"><a href="#cb7-175" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-176"><a href="#cb7-176" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Clayton copula simulation (simplified)</span></span>
<span id="cb7-177"><a href="#cb7-177" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> np.random.gamma(<span class="dv">1</span><span class="op">/</span>true_theta_clayton, <span class="dv">1</span>, n)</span>
<span id="cb7-178"><a href="#cb7-178" aria-hidden="true" tabindex="-1"></a>        v1 <span class="op">=</span> (<span class="op">-</span>np.log(u1) <span class="op">/</span> w)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>true_theta_clayton)</span>
<span id="cb7-179"><a href="#cb7-179" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> (<span class="op">-</span>np.log(u2) <span class="op">/</span> w)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>true_theta_clayton)</span>
<span id="cb7-180"><a href="#cb7-180" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-181"><a href="#cb7-181" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform to different margins</span></span>
<span id="cb7-182"><a href="#cb7-182" aria-hidden="true" tabindex="-1"></a>        data_clayton <span class="op">=</span> np.column_stack([</span>
<span id="cb7-183"><a href="#cb7-183" aria-hidden="true" tabindex="-1"></a>            stats.t.ppf(np.clip(v1, <span class="fl">0.001</span>, <span class="fl">0.999</span>), df<span class="op">=</span><span class="dv">5</span>, scale<span class="op">=</span><span class="fl">1.5</span>),</span>
<span id="cb7-184"><a href="#cb7-184" aria-hidden="true" tabindex="-1"></a>            stats.expon.ppf(np.clip(v2, <span class="fl">0.001</span>, <span class="fl">0.999</span>), scale<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb7-185"><a href="#cb7-185" aria-hidden="true" tabindex="-1"></a>        ])</span>
<span id="cb7-186"><a href="#cb7-186" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-187"><a href="#cb7-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Estimation for Gaussian copula</span></span>
<span id="cb7-188"><a href="#cb7-188" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb7-189"><a href="#cb7-189" aria-hidden="true" tabindex="-1"></a>            estimator_gauss <span class="op">=</span> CopulaEstimation(data_gaussian)</span>
<span id="cb7-190"><a href="#cb7-190" aria-hidden="true" tabindex="-1"></a>            estimator_gauss.estimate_marginals(<span class="st">'t'</span>)</span>
<span id="cb7-191"><a href="#cb7-191" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-192"><a href="#cb7-192" aria-hidden="true" tabindex="-1"></a>            <span class="co"># IFM estimation</span></span>
<span id="cb7-193"><a href="#cb7-193" aria-hidden="true" tabindex="-1"></a>            rho_ifm <span class="op">=</span> estimator_gauss.estimate_gaussian_copula(<span class="st">'ifm'</span>)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb7-194"><a href="#cb7-194" aria-hidden="true" tabindex="-1"></a>            gaussian_ifm_estimates.append(rho_ifm)</span>
<span id="cb7-195"><a href="#cb7-195" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-196"><a href="#cb7-196" aria-hidden="true" tabindex="-1"></a>            <span class="co"># CML estimation</span></span>
<span id="cb7-197"><a href="#cb7-197" aria-hidden="true" tabindex="-1"></a>            rho_cml <span class="op">=</span> estimator_gauss.estimate_gaussian_copula(<span class="st">'cml'</span>)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb7-198"><a href="#cb7-198" aria-hidden="true" tabindex="-1"></a>            gaussian_cml_estimates.append(rho_cml)</span>
<span id="cb7-199"><a href="#cb7-199" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-200"><a href="#cb7-200" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Pseudo-MLE (same as IFM for Gaussian copula)</span></span>
<span id="cb7-201"><a href="#cb7-201" aria-hidden="true" tabindex="-1"></a>            gaussian_mle_estimates.append(rho_ifm)</span>
<span id="cb7-202"><a href="#cb7-202" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-203"><a href="#cb7-203" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span>:</span>
<span id="cb7-204"><a href="#cb7-204" aria-hidden="true" tabindex="-1"></a>            <span class="co"># In case of numerical issues</span></span>
<span id="cb7-205"><a href="#cb7-205" aria-hidden="true" tabindex="-1"></a>            gaussian_ifm_estimates.append(np.nan)</span>
<span id="cb7-206"><a href="#cb7-206" aria-hidden="true" tabindex="-1"></a>            gaussian_cml_estimates.append(np.nan)</span>
<span id="cb7-207"><a href="#cb7-207" aria-hidden="true" tabindex="-1"></a>            gaussian_mle_estimates.append(np.nan)</span>
<span id="cb7-208"><a href="#cb7-208" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-209"><a href="#cb7-209" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Estimation for Clayton copula</span></span>
<span id="cb7-210"><a href="#cb7-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb7-211"><a href="#cb7-211" aria-hidden="true" tabindex="-1"></a>            estimator_clayton <span class="op">=</span> CopulaEstimation(data_clayton)</span>
<span id="cb7-212"><a href="#cb7-212" aria-hidden="true" tabindex="-1"></a>            estimator_clayton.estimate_marginals(<span class="st">'t'</span>)</span>
<span id="cb7-213"><a href="#cb7-213" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-214"><a href="#cb7-214" aria-hidden="true" tabindex="-1"></a>            <span class="co"># IFM estimation</span></span>
<span id="cb7-215"><a href="#cb7-215" aria-hidden="true" tabindex="-1"></a>            theta_ifm <span class="op">=</span> estimator_clayton.estimate_clayton_copula(<span class="st">'ifm'</span>)</span>
<span id="cb7-216"><a href="#cb7-216" aria-hidden="true" tabindex="-1"></a>            clayton_ifm_estimates.append(theta_ifm)</span>
<span id="cb7-217"><a href="#cb7-217" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-218"><a href="#cb7-218" aria-hidden="true" tabindex="-1"></a>            <span class="co"># CML estimation</span></span>
<span id="cb7-219"><a href="#cb7-219" aria-hidden="true" tabindex="-1"></a>            theta_cml <span class="op">=</span> estimator_clayton.estimate_clayton_copula(<span class="st">'cml'</span>)</span>
<span id="cb7-220"><a href="#cb7-220" aria-hidden="true" tabindex="-1"></a>            clayton_cml_estimates.append(theta_cml)</span>
<span id="cb7-221"><a href="#cb7-221" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-222"><a href="#cb7-222" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span>:</span>
<span id="cb7-223"><a href="#cb7-223" aria-hidden="true" tabindex="-1"></a>            clayton_ifm_estimates.append(np.nan)</span>
<span id="cb7-224"><a href="#cb7-224" aria-hidden="true" tabindex="-1"></a>            clayton_cml_estimates.append(np.nan)</span>
<span id="cb7-225"><a href="#cb7-225" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-226"><a href="#cb7-226" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clean up NaN values</span></span>
<span id="cb7-227"><a href="#cb7-227" aria-hidden="true" tabindex="-1"></a>    gaussian_ifm_estimates <span class="op">=</span> np.array(gaussian_ifm_estimates)</span>
<span id="cb7-228"><a href="#cb7-228" aria-hidden="true" tabindex="-1"></a>    gaussian_ifm_estimates <span class="op">=</span> gaussian_ifm_estimates[<span class="op">~</span>np.isnan(gaussian_ifm_estimates)]</span>
<span id="cb7-229"><a href="#cb7-229" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-230"><a href="#cb7-230" aria-hidden="true" tabindex="-1"></a>    gaussian_cml_estimates <span class="op">=</span> np.array(gaussian_cml_estimates)</span>
<span id="cb7-231"><a href="#cb7-231" aria-hidden="true" tabindex="-1"></a>    gaussian_cml_estimates <span class="op">=</span> gaussian_cml_estimates[<span class="op">~</span>np.isnan(gaussian_cml_estimates)]</span>
<span id="cb7-232"><a href="#cb7-232" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-233"><a href="#cb7-233" aria-hidden="true" tabindex="-1"></a>    clayton_ifm_estimates <span class="op">=</span> np.array(clayton_ifm_estimates)</span>
<span id="cb7-234"><a href="#cb7-234" aria-hidden="true" tabindex="-1"></a>    clayton_ifm_estimates <span class="op">=</span> clayton_ifm_estimates[<span class="op">~</span>np.isnan(clayton_ifm_estimates)]</span>
<span id="cb7-235"><a href="#cb7-235" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-236"><a href="#cb7-236" aria-hidden="true" tabindex="-1"></a>    clayton_cml_estimates <span class="op">=</span> np.array(clayton_cml_estimates)</span>
<span id="cb7-237"><a href="#cb7-237" aria-hidden="true" tabindex="-1"></a>    clayton_cml_estimates <span class="op">=</span> clayton_cml_estimates[<span class="op">~</span>np.isnan(clayton_cml_estimates)]</span>
<span id="cb7-238"><a href="#cb7-238" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-239"><a href="#cb7-239" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot histograms of estimates</span></span>
<span id="cb7-240"><a href="#cb7-240" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(gaussian_ifm_estimates) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-241"><a href="#cb7-241" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].hist(gaussian_ifm_estimates, bins<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, label<span class="op">=</span><span class="ss">f'IFM (n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-242"><a href="#cb7-242" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].axvline(true_rho, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'True value'</span>)</span>
<span id="cb7-243"><a href="#cb7-243" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].axvline(np.mean(gaussian_ifm_estimates), color<span class="op">=</span><span class="st">'blue'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Mean estimate'</span>)</span>
<span id="cb7-244"><a href="#cb7-244" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_title(<span class="ss">f'Gaussian Copula: IFM (n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb7-245"><a href="#cb7-245" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_xlabel(<span class="st">'ρ estimate'</span>)</span>
<span id="cb7-246"><a href="#cb7-246" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb7-247"><a href="#cb7-247" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].legend()</span>
<span id="cb7-248"><a href="#cb7-248" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-249"><a href="#cb7-249" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-250"><a href="#cb7-250" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(gaussian_cml_estimates) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-251"><a href="#cb7-251" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].hist(gaussian_cml_estimates, bins<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, label<span class="op">=</span><span class="ss">f'CML (n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-252"><a href="#cb7-252" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].axvline(true_rho, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'True value'</span>)</span>
<span id="cb7-253"><a href="#cb7-253" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].axvline(np.mean(gaussian_cml_estimates), color<span class="op">=</span><span class="st">'green'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Mean estimate'</span>)</span>
<span id="cb7-254"><a href="#cb7-254" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'Gaussian Copula: CML (n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb7-255"><a href="#cb7-255" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_xlabel(<span class="st">'ρ estimate'</span>)</span>
<span id="cb7-256"><a href="#cb7-256" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb7-257"><a href="#cb7-257" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].legend()</span>
<span id="cb7-258"><a href="#cb7-258" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-259"><a href="#cb7-259" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-260"><a href="#cb7-260" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(clayton_ifm_estimates) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-261"><a href="#cb7-261" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].hist(clayton_ifm_estimates, bins<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, label<span class="op">=</span><span class="ss">f'IFM (n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)'</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-262"><a href="#cb7-262" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].axvline(true_theta_clayton, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'True value'</span>)</span>
<span id="cb7-263"><a href="#cb7-263" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].axvline(np.mean(clayton_ifm_estimates), color<span class="op">=</span><span class="st">'orange'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Mean estimate'</span>)</span>
<span id="cb7-264"><a href="#cb7-264" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].set_title(<span class="ss">f'Clayton Copula: IFM (n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb7-265"><a href="#cb7-265" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].set_xlabel(<span class="st">'θ estimate'</span>)</span>
<span id="cb7-266"><a href="#cb7-266" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb7-267"><a href="#cb7-267" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].legend()</span>
<span id="cb7-268"><a href="#cb7-268" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">2</span>, i].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-269"><a href="#cb7-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-270"><a href="#cb7-270" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.98</span>, top<span class="op">=</span><span class="fl">0.95</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb7-271"><a href="#cb7-271" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running simulation for n = 100
Running simulation for n = 250
Running simulation for n = 500
Running simulation for n = 1000</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-estimation-methods" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-estimation-methods-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-estimation-methods-output-2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-estimation-methods-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Comparison of parameter estimation methods for copulas with Monte Carlo study
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="practical-considerations" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="practical-considerations"><span class="header-section-number">5.2</span> Practical Considerations</h3>
<p><strong>Sample Size Requirements</strong>: Copula parameter estimation typically requires larger sample sizes than univariate problems, especially for complex dependence structures. The Monte Carlo study above illustrates how estimation precision improves with sample size.</p>
<p><strong>Marginal Specification</strong>: The choice between parametric and semiparametric approaches involves a bias-variance tradeoff: - <strong>Parametric methods</strong> (IFM, MLE) are more efficient when margins are correctly specified but biased under misspecification - <strong>Semiparametric methods</strong> (CML) are more robust but potentially less efficient</p>
<p><strong>Computational Aspects</strong>: For high-dimensional problems, consider: - <strong>Stepwise estimation</strong> for vine copulas - <strong>Composite likelihood</strong> methods for large dimensions - <strong>Bayesian approaches</strong> with MCMC for complex models</p>
</section>
</section>
<section id="sec-vine" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="sec-vine"><span class="header-section-number">6</span> Vine Copulas</h2>
<p>Vine copulas, introduced by <span class="citation" data-cites="bedford2002">Bedford and Cooke (<a href="#ref-bedford2002" role="doc-biblioref">2002</a>)</span> and further developed by <span class="citation" data-cites="aas2009">Aas et al. (<a href="#ref-aas2009" role="doc-biblioref">2009</a>)</span>, provide a flexible framework for modeling high-dimensional dependence structures through hierarchical decompositions of multivariate distributions.</p>
<section id="theoretical-foundation" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="theoretical-foundation"><span class="header-section-number">6.1</span> Theoretical Foundation</h3>
<p>The fundamental insight behind vine copulas is that any <span class="math inline">\(d\)</span>-dimensional density can be decomposed into a product of conditional densities and bivariate copulas. For a <span class="math inline">\(d\)</span>-dimensional random vector <span class="math inline">\(\mathbf{X} = (X_1, \ldots, X_d)\)</span>, we can write:</p>
<p><span class="math display">\[f(\mathbf{x}) = \prod_{j=1}^d f_j(x_j) \prod_{i=1}^{d-1} \prod_{j=1}^{d-i} c_{j,j+i|1:(j-1)}(F(x_j|x_1, \ldots, x_{j-1}), F(x_{j+i}|x_1, \ldots, x_{j-1}))\]</span></p>
<p>where <span class="math inline">\(c_{j,k|D}\)</span> denotes the bivariate copula density of variables <span class="math inline">\(j\)</span> and <span class="math inline">\(k\)</span> conditional on the set <span class="math inline">\(D\)</span>.</p>
</section>
<section id="regular-vine-structures" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="regular-vine-structures"><span class="header-section-number">6.2</span> Regular Vine Structures</h3>
<p>Regular vines (R-vines) provide a systematic way to organize this decomposition using graph theory.</p>
<section id="canonical-vine-c-vine" class="level4" data-number="6.2.1">
<h4 data-number="6.2.1" class="anchored" data-anchor-id="canonical-vine-c-vine"><span class="header-section-number">6.2.1</span> Canonical Vine (C-vine)</h4>
<p>In a C-vine, each tree has a star structure with one variable acting as the central node:</p>
<ul>
<li><strong>Tree 1</strong>: One variable (root) is connected to all others</li>
<li><strong>Tree 2</strong>: One of the remaining variables becomes the new root<br>
</li>
<li><strong>Tree <span class="math inline">\(j\)</span></strong>: Similar star structure with conditioning sets of size <span class="math inline">\(j-1\)</span></li>
</ul>
<p><strong>Mathematical representation</strong> for a 4-dimensional C-vine: <span class="math display">\[f(x_1, x_2, x_3, x_4) = f_1(x_1) f_2(x_2) f_3(x_3) f_4(x_4) \times\]</span> <span class="math display">\[c_{1,2}(u_1, u_2) c_{1,3}(u_1, u_3) c_{1,4}(u_1, u_4) \times\]</span> <span class="math display">\[c_{2,3|1}(u_{2|1}, u_{3|1}) c_{2,4|1}(u_{2|1}, u_{4|1}) \times\]</span> <span class="math display">\[c_{3,4|1,2}(u_{3|1,2}, u_{4|1,2})\]</span></p>
</section>
<section id="drawable-vine-d-vine" class="level4" data-number="6.2.2">
<h4 data-number="6.2.2" class="anchored" data-anchor-id="drawable-vine-d-vine"><span class="header-section-number">6.2.2</span> Drawable Vine (D-vine)</h4>
<p>D-vines have a path structure where variables are arranged sequentially:</p>
<ul>
<li><strong>Tree 1</strong>: Variables form a path <span class="math inline">\((1-2-3-4-\ldots)\)</span></li>
<li><strong>Tree 2</strong>: Connect variables with one intermediate node</li>
<li><strong>Tree <span class="math inline">\(j\)</span></strong>: Connect variables with <span class="math inline">\(j\)</span> intermediate nodes</li>
</ul>
<p><strong>Mathematical representation</strong> for a 4-dimensional D-vine: <span class="math display">\[f(x_1, x_2, x_3, x_4) = f_1(x_1) f_2(x_2) f_3(x_3) f_4(x_4) \times\]</span> <span class="math display">\[c_{1,2}(u_1, u_2) c_{2,3}(u_2, u_3) c_{3,4}(u_3, u_4) \times\]</span> <span class="math display">\[c_{1,3|2}(u_{1|2}, u_{3|2}) c_{2,4|3}(u_{2|3}, u_{4|3}) \times\]</span> <span class="math display">\[c_{1,4|2,3}(u_{1|2,3}, u_{4|2,3})\]</span></p>
</section>
</section>
<section id="construction-and-estimation" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="construction-and-estimation"><span class="header-section-number">6.3</span> Construction and Estimation</h3>
<div id="cell-fig-vine-copulas" class="cell" data-fig-height="16" data-fig-width="20" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VineCopula:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implementation of vine copula construction and estimation"""</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data, vine_type<span class="op">=</span><span class="st">'cvine'</span>):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> data</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n, <span class="va">self</span>.d <span class="op">=</span> data.shape</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vine_type <span class="op">=</span> vine_type</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trees <span class="op">=</span> []</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.copula_params <span class="op">=</span> {}</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform_to_uniform(<span class="va">self</span>):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Transform data to uniform margins using empirical CDFs"""</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.uniform_data <span class="op">=</span> np.zeros_like(<span class="va">self</span>.data)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.d):</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            ranks <span class="op">=</span> stats.rankdata(<span class="va">self</span>.data[:, j])</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.uniform_data[:, j] <span class="op">=</span> ranks <span class="op">/</span> (<span class="va">self</span>.n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> estimate_bivariate_copula(<span class="va">self</span>, u1, u2, copula_family<span class="op">=</span><span class="st">'gaussian'</span>):</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Estimate parameters for a bivariate copula"""</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> copula_family <span class="op">==</span> <span class="st">'gaussian'</span>:</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform to normal space</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>            z1 <span class="op">=</span> stats.norm.ppf(np.clip(u1, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            z2 <span class="op">=</span> stats.norm.ppf(np.clip(u2, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            rho <span class="op">=</span> np.corrcoef(z1, z2)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'family'</span>: <span class="st">'gaussian'</span>, <span class="st">'rho'</span>: rho}</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> copula_family <span class="op">==</span> <span class="st">'clayton'</span>:</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Kendall's tau method</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>            tau <span class="op">=</span> stats.kendalltau(u1, u2)[<span class="dv">0</span>]</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> tau <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>                theta <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> tau <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> tau)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>                theta <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'family'</span>: <span class="st">'clayton'</span>, <span class="st">'theta'</span>: <span class="bu">max</span>(theta, <span class="fl">0.1</span>)}</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> copula_family <span class="op">==</span> <span class="st">'gumbel'</span>:</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Kendall's tau method</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>            tau <span class="op">=</span> stats.kendalltau(u1, u2)[<span class="dv">0</span>]</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> tau <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>                theta <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> tau)</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>                theta <span class="op">=</span> <span class="fl">1.1</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'family'</span>: <span class="st">'gumbel'</span>, <span class="st">'theta'</span>: <span class="bu">max</span>(theta, <span class="fl">1.01</span>)}</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> copula_family <span class="op">==</span> <span class="st">'frank'</span>:</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Kendall's tau method (approximation)</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>            tau <span class="op">=</span> stats.kendalltau(u1, u2)[<span class="dv">0</span>]</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(tau) <span class="op">&gt;</span> <span class="fl">0.001</span>:</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Approximate inverse of tau-theta relationship for Frank copula</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>                theta <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> tau  <span class="co"># Simplified approximation</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>                theta <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {<span class="st">'family'</span>: <span class="st">'frank'</span>, <span class="st">'theta'</span>: theta}</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> conditional_cdf(<span class="va">self</span>, u1, u2, copula_params):</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute conditional CDF h(u1|u2) = ∂C(u1,u2)/∂u2"""</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>        family <span class="op">=</span> copula_params[<span class="st">'family'</span>]</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> family <span class="op">==</span> <span class="st">'gaussian'</span>:</span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>            rho <span class="op">=</span> copula_params[<span class="st">'rho'</span>]</span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>            z1 <span class="op">=</span> stats.norm.ppf(np.clip(u1, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>            z2 <span class="op">=</span> stats.norm.ppf(np.clip(u2, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Conditional distribution for bivariate normal</span></span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>            conditional_mean <span class="op">=</span> rho <span class="op">*</span> z2</span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>            conditional_std <span class="op">=</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>            h <span class="op">=</span> stats.norm.cdf((z1 <span class="op">-</span> conditional_mean) <span class="op">/</span> conditional_std)</span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> family <span class="op">==</span> <span class="st">'clayton'</span>:</span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>            theta <span class="op">=</span> copula_params[<span class="st">'theta'</span>]</span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> theta <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>                h <span class="op">=</span> u2<span class="op">**</span>(<span class="op">-</span>theta<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> (u1<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">+</span> u2<span class="op">**</span>(<span class="op">-</span>theta) <span class="op">-</span> <span class="dv">1</span>)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>theta <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>                h <span class="op">=</span> u1  <span class="co"># Independence case</span></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> family <span class="op">==</span> <span class="st">'frank'</span>:</span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>            theta <span class="op">=</span> copula_params[<span class="st">'theta'</span>]</span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(theta) <span class="op">&gt;</span> <span class="fl">0.001</span>:</span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>                exp_theta_u1 <span class="op">=</span> np.exp(<span class="op">-</span>theta <span class="op">*</span> u1)</span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>                exp_theta_u2 <span class="op">=</span> np.exp(<span class="op">-</span>theta <span class="op">*</span> u2)</span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>                exp_theta <span class="op">=</span> np.exp(<span class="op">-</span>theta)</span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>                numerator <span class="op">=</span> (exp_theta_u2 <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> exp_theta_u1</span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>                denominator <span class="op">=</span> (exp_theta <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> (exp_theta_u1 <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (exp_theta_u2 <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>                h <span class="op">=</span> numerator <span class="op">/</span> denominator</span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>                h <span class="op">=</span> u1  <span class="co"># Independence case</span></span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>            h <span class="op">=</span> u1  <span class="co"># Default to independence</span></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.clip(h, <span class="fl">0.001</span>, <span class="fl">0.999</span>)</span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit_cvine(<span class="va">self</span>):</span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fit a canonical vine copula"""</span></span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'uniform_data'</span>):</span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.transform_to_uniform()</span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Storage for vine structure</span></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>        current_data <span class="op">=</span> <span class="va">self</span>.uniform_data.copy()</span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Tree construction</span></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> tree_level <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.d <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Constructing tree </span><span class="sc">{</span>tree_level <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a>            tree_edges <span class="op">=</span> []</span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a>            tree_copulas <span class="op">=</span> {}</span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a>            new_data <span class="op">=</span> {}</span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> tree_level <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>                <span class="co"># First tree: star structure around variable 0</span></span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>                root_var <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="va">self</span>.d):</span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Estimate copula between root and variable j</span></span>
<span id="cb9-115"><a href="#cb9-115" aria-hidden="true" tabindex="-1"></a>                    u1 <span class="op">=</span> current_data[:, root_var]</span>
<span id="cb9-116"><a href="#cb9-116" aria-hidden="true" tabindex="-1"></a>                    u2 <span class="op">=</span> current_data[:, j]</span>
<span id="cb9-117"><a href="#cb9-117" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb9-118"><a href="#cb9-118" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Select best copula family (simplified selection)</span></span>
<span id="cb9-119"><a href="#cb9-119" aria-hidden="true" tabindex="-1"></a>                    copula_params <span class="op">=</span> <span class="va">self</span>.select_best_copula(u1, u2)</span>
<span id="cb9-120"><a href="#cb9-120" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb9-121"><a href="#cb9-121" aria-hidden="true" tabindex="-1"></a>                    edge <span class="op">=</span> (root_var, j, <span class="bu">frozenset</span>())  <span class="co"># (var1, var2, conditioning_set)</span></span>
<span id="cb9-122"><a href="#cb9-122" aria-hidden="true" tabindex="-1"></a>                    tree_edges.append(edge)</span>
<span id="cb9-123"><a href="#cb9-123" aria-hidden="true" tabindex="-1"></a>                    tree_copulas[edge] <span class="op">=</span> copula_params</span>
<span id="cb9-124"><a href="#cb9-124" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-125"><a href="#cb9-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-126"><a href="#cb9-126" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Higher trees: condition on previous variables (simplified)</span></span>
<span id="cb9-127"><a href="#cb9-127" aria-hidden="true" tabindex="-1"></a>                <span class="co"># For demonstration, only construct second tree</span></span>
<span id="cb9-128"><a href="#cb9-128" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> tree_level <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-129"><a href="#cb9-129" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Second tree with some conditional dependence</span></span>
<span id="cb9-130"><a href="#cb9-130" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="va">self</span>.d):</span>
<span id="cb9-131"><a href="#cb9-131" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> j <span class="op">&lt;</span> <span class="va">self</span>.d:</span>
<span id="cb9-132"><a href="#cb9-132" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># Get conditional data from first tree</span></span>
<span id="cb9-133"><a href="#cb9-133" aria-hidden="true" tabindex="-1"></a>                            prev_edge1 <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">frozenset</span>())</span>
<span id="cb9-134"><a href="#cb9-134" aria-hidden="true" tabindex="-1"></a>                            prev_edge2 <span class="op">=</span> (<span class="dv">0</span>, j, <span class="bu">frozenset</span>())</span>
<span id="cb9-135"><a href="#cb9-135" aria-hidden="true" tabindex="-1"></a>                            </span>
<span id="cb9-136"><a href="#cb9-136" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> prev_edge1 <span class="kw">in</span> <span class="va">self</span>.trees[<span class="dv">0</span>][<span class="st">'copulas'</span>] <span class="kw">and</span> prev_edge2 <span class="kw">in</span> <span class="va">self</span>.trees[<span class="dv">0</span>][<span class="st">'copulas'</span>]:</span>
<span id="cb9-137"><a href="#cb9-137" aria-hidden="true" tabindex="-1"></a>                                u1_cond <span class="op">=</span> <span class="va">self</span>.conditional_cdf(</span>
<span id="cb9-138"><a href="#cb9-138" aria-hidden="true" tabindex="-1"></a>                                    current_data[:, <span class="dv">1</span>], </span>
<span id="cb9-139"><a href="#cb9-139" aria-hidden="true" tabindex="-1"></a>                                    current_data[:, <span class="dv">0</span>],</span>
<span id="cb9-140"><a href="#cb9-140" aria-hidden="true" tabindex="-1"></a>                                    <span class="va">self</span>.trees[<span class="dv">0</span>][<span class="st">'copulas'</span>][prev_edge1]</span>
<span id="cb9-141"><a href="#cb9-141" aria-hidden="true" tabindex="-1"></a>                                )</span>
<span id="cb9-142"><a href="#cb9-142" aria-hidden="true" tabindex="-1"></a>                                u2_cond <span class="op">=</span> <span class="va">self</span>.conditional_cdf(</span>
<span id="cb9-143"><a href="#cb9-143" aria-hidden="true" tabindex="-1"></a>                                    current_data[:, j], </span>
<span id="cb9-144"><a href="#cb9-144" aria-hidden="true" tabindex="-1"></a>                                    current_data[:, <span class="dv">0</span>],</span>
<span id="cb9-145"><a href="#cb9-145" aria-hidden="true" tabindex="-1"></a>                                    <span class="va">self</span>.trees[<span class="dv">0</span>][<span class="st">'copulas'</span>][prev_edge2]</span>
<span id="cb9-146"><a href="#cb9-146" aria-hidden="true" tabindex="-1"></a>                                )</span>
<span id="cb9-147"><a href="#cb9-147" aria-hidden="true" tabindex="-1"></a>                                </span>
<span id="cb9-148"><a href="#cb9-148" aria-hidden="true" tabindex="-1"></a>                                <span class="co"># Estimate conditional copula</span></span>
<span id="cb9-149"><a href="#cb9-149" aria-hidden="true" tabindex="-1"></a>                                copula_params <span class="op">=</span> <span class="va">self</span>.select_best_copula(u1_cond, u2_cond)</span>
<span id="cb9-150"><a href="#cb9-150" aria-hidden="true" tabindex="-1"></a>                                </span>
<span id="cb9-151"><a href="#cb9-151" aria-hidden="true" tabindex="-1"></a>                                edge <span class="op">=</span> (<span class="dv">1</span>, j, <span class="bu">frozenset</span>([<span class="dv">0</span>]))</span>
<span id="cb9-152"><a href="#cb9-152" aria-hidden="true" tabindex="-1"></a>                                tree_edges.append(edge)</span>
<span id="cb9-153"><a href="#cb9-153" aria-hidden="true" tabindex="-1"></a>                                tree_copulas[edge] <span class="op">=</span> copula_params</span>
<span id="cb9-154"><a href="#cb9-154" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-155"><a href="#cb9-155" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Store tree information</span></span>
<span id="cb9-156"><a href="#cb9-156" aria-hidden="true" tabindex="-1"></a>            tree_info <span class="op">=</span> {</span>
<span id="cb9-157"><a href="#cb9-157" aria-hidden="true" tabindex="-1"></a>                <span class="st">'level'</span>: tree_level,</span>
<span id="cb9-158"><a href="#cb9-158" aria-hidden="true" tabindex="-1"></a>                <span class="st">'edges'</span>: tree_edges,</span>
<span id="cb9-159"><a href="#cb9-159" aria-hidden="true" tabindex="-1"></a>                <span class="st">'copulas'</span>: tree_copulas</span>
<span id="cb9-160"><a href="#cb9-160" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb9-161"><a href="#cb9-161" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.trees.append(tree_info)</span>
<span id="cb9-162"><a href="#cb9-162" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-163"><a href="#cb9-163" aria-hidden="true" tabindex="-1"></a>            <span class="co"># For simplicity, only fit first two trees</span></span>
<span id="cb9-164"><a href="#cb9-164" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> tree_level <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb9-165"><a href="#cb9-165" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb9-166"><a href="#cb9-166" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-167"><a href="#cb9-167" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> select_best_copula(<span class="va">self</span>, u1, u2):</span>
<span id="cb9-168"><a href="#cb9-168" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Select best copula family based on AIC"""</span></span>
<span id="cb9-169"><a href="#cb9-169" aria-hidden="true" tabindex="-1"></a>        families <span class="op">=</span> [<span class="st">'gaussian'</span>, <span class="st">'clayton'</span>, <span class="st">'frank'</span>]</span>
<span id="cb9-170"><a href="#cb9-170" aria-hidden="true" tabindex="-1"></a>        best_aic <span class="op">=</span> np.inf</span>
<span id="cb9-171"><a href="#cb9-171" aria-hidden="true" tabindex="-1"></a>        best_params <span class="op">=</span> <span class="va">None</span></span>
<span id="cb9-172"><a href="#cb9-172" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-173"><a href="#cb9-173" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> family <span class="kw">in</span> families:</span>
<span id="cb9-174"><a href="#cb9-174" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb9-175"><a href="#cb9-175" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> <span class="va">self</span>.estimate_bivariate_copula(u1, u2, family)</span>
<span id="cb9-176"><a href="#cb9-176" aria-hidden="true" tabindex="-1"></a>                aic <span class="op">=</span> <span class="va">self</span>.compute_aic(u1, u2, params)</span>
<span id="cb9-177"><a href="#cb9-177" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-178"><a href="#cb9-178" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> aic <span class="op">&lt;</span> best_aic:</span>
<span id="cb9-179"><a href="#cb9-179" aria-hidden="true" tabindex="-1"></a>                    best_aic <span class="op">=</span> aic</span>
<span id="cb9-180"><a href="#cb9-180" aria-hidden="true" tabindex="-1"></a>                    best_params <span class="op">=</span> params</span>
<span id="cb9-181"><a href="#cb9-181" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span>:</span>
<span id="cb9-182"><a href="#cb9-182" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb9-183"><a href="#cb9-183" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb9-184"><a href="#cb9-184" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best_params <span class="cf">if</span> best_params <span class="cf">else</span> {<span class="st">'family'</span>: <span class="st">'gaussian'</span>, <span class="st">'rho'</span>: <span class="fl">0.1</span>}</span>
<span id="cb9-185"><a href="#cb9-185" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-186"><a href="#cb9-186" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_aic(<span class="va">self</span>, u1, u2, copula_params):</span>
<span id="cb9-187"><a href="#cb9-187" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute AIC for copula model (simplified)"""</span></span>
<span id="cb9-188"><a href="#cb9-188" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb9-189"><a href="#cb9-189" aria-hidden="true" tabindex="-1"></a>            log_likelihood <span class="op">=</span> <span class="va">self</span>.log_likelihood(u1, u2, copula_params)</span>
<span id="cb9-190"><a href="#cb9-190" aria-hidden="true" tabindex="-1"></a>            n_params <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Assuming single parameter copulas</span></span>
<span id="cb9-191"><a href="#cb9-191" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">2</span> <span class="op">*</span> log_likelihood <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> n_params</span>
<span id="cb9-192"><a href="#cb9-192" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span>:</span>
<span id="cb9-193"><a href="#cb9-193" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.inf</span>
<span id="cb9-194"><a href="#cb9-194" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-195"><a href="#cb9-195" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> log_likelihood(<span class="va">self</span>, u1, u2, copula_params):</span>
<span id="cb9-196"><a href="#cb9-196" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Compute log-likelihood for bivariate copula"""</span></span>
<span id="cb9-197"><a href="#cb9-197" aria-hidden="true" tabindex="-1"></a>        family <span class="op">=</span> copula_params[<span class="st">'family'</span>]</span>
<span id="cb9-198"><a href="#cb9-198" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-199"><a href="#cb9-199" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> family <span class="op">==</span> <span class="st">'gaussian'</span>:</span>
<span id="cb9-200"><a href="#cb9-200" aria-hidden="true" tabindex="-1"></a>            rho <span class="op">=</span> copula_params[<span class="st">'rho'</span>]</span>
<span id="cb9-201"><a href="#cb9-201" aria-hidden="true" tabindex="-1"></a>            z1 <span class="op">=</span> stats.norm.ppf(np.clip(u1, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb9-202"><a href="#cb9-202" aria-hidden="true" tabindex="-1"></a>            z2 <span class="op">=</span> stats.norm.ppf(np.clip(u2, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb9-203"><a href="#cb9-203" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-204"><a href="#cb9-204" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Gaussian copula density</span></span>
<span id="cb9-205"><a href="#cb9-205" aria-hidden="true" tabindex="-1"></a>            density <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span>(<span class="op">-</span><span class="fl">0.5</span>) <span class="op">*</span> np.exp(</span>
<span id="cb9-206"><a href="#cb9-206" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> rho <span class="op">*</span> (<span class="dv">2</span><span class="op">*</span>rho<span class="op">*</span>z1<span class="op">*</span>z2 <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span><span class="op">*</span>(z1<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> z2<span class="op">**</span><span class="dv">2</span>)) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb9-207"><a href="#cb9-207" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb9-208"><a href="#cb9-208" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.<span class="bu">sum</span>(np.log(np.clip(density, <span class="fl">1e-10</span>, np.inf)))</span>
<span id="cb9-209"><a href="#cb9-209" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-210"><a href="#cb9-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-211"><a href="#cb9-211" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Simplified: return correlation-based pseudo-likelihood</span></span>
<span id="cb9-212"><a href="#cb9-212" aria-hidden="true" tabindex="-1"></a>            tau <span class="op">=</span> stats.kendalltau(u1, u2)[<span class="dv">0</span>]</span>
<span id="cb9-213"><a href="#cb9-213" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.n <span class="op">*</span> np.log(<span class="bu">max</span>(<span class="bu">abs</span>(tau), <span class="fl">0.01</span>))</span>
<span id="cb9-214"><a href="#cb9-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-215"><a href="#cb9-215" aria-hidden="true" tabindex="-1"></a><span class="co"># Demonstration with synthetic 4-dimensional data</span></span>
<span id="cb9-216"><a href="#cb9-216" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb9-217"><a href="#cb9-217" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb9-218"><a href="#cb9-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-219"><a href="#cb9-219" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate 4-dimensional data with known vine structure</span></span>
<span id="cb9-220"><a href="#cb9-220" aria-hidden="true" tabindex="-1"></a><span class="co"># True C-vine structure: 1 as root, then dependencies through vine</span></span>
<span id="cb9-221"><a href="#cb9-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-222"><a href="#cb9-222" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate base normal data with specific correlation structure</span></span>
<span id="cb9-223"><a href="#cb9-223" aria-hidden="true" tabindex="-1"></a>true_corr <span class="op">=</span> np.array([</span>
<span id="cb9-224"><a href="#cb9-224" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.7</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>],</span>
<span id="cb9-225"><a href="#cb9-225" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.7</span>, <span class="fl">1.0</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>], </span>
<span id="cb9-226"><a href="#cb9-226" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.5</span>, <span class="fl">0.4</span>, <span class="fl">1.0</span>, <span class="fl">0.6</span>],</span>
<span id="cb9-227"><a href="#cb9-227" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.6</span>, <span class="fl">1.0</span>]</span>
<span id="cb9-228"><a href="#cb9-228" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb9-229"><a href="#cb9-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-230"><a href="#cb9-230" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate multivariate normal data</span></span>
<span id="cb9-231"><a href="#cb9-231" aria-hidden="true" tabindex="-1"></a>mvn_data <span class="op">=</span> np.random.multivariate_normal(np.zeros(<span class="dv">4</span>), true_corr, n)</span>
<span id="cb9-232"><a href="#cb9-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-233"><a href="#cb9-233" aria-hidden="true" tabindex="-1"></a><span class="co"># Transform to different marginal distributions</span></span>
<span id="cb9-234"><a href="#cb9-234" aria-hidden="true" tabindex="-1"></a>vine_data <span class="op">=</span> np.column_stack([</span>
<span id="cb9-235"><a href="#cb9-235" aria-hidden="true" tabindex="-1"></a>    stats.norm.ppf(stats.norm.cdf(mvn_data[:, <span class="dv">0</span>])),  <span class="co"># Keep normal</span></span>
<span id="cb9-236"><a href="#cb9-236" aria-hidden="true" tabindex="-1"></a>    stats.t.ppf(stats.norm.cdf(mvn_data[:, <span class="dv">1</span>]), df<span class="op">=</span><span class="dv">5</span>),  <span class="co"># t-distribution  </span></span>
<span id="cb9-237"><a href="#cb9-237" aria-hidden="true" tabindex="-1"></a>    stats.expon.ppf(stats.norm.cdf(mvn_data[:, <span class="dv">2</span>])),  <span class="co"># Exponential</span></span>
<span id="cb9-238"><a href="#cb9-238" aria-hidden="true" tabindex="-1"></a>    stats.gamma.ppf(stats.norm.cdf(mvn_data[:, <span class="dv">3</span>]), a<span class="op">=</span><span class="dv">2</span>)  <span class="co"># Gamma</span></span>
<span id="cb9-239"><a href="#cb9-239" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb9-240"><a href="#cb9-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-241"><a href="#cb9-241" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit vine copula</span></span>
<span id="cb9-242"><a href="#cb9-242" aria-hidden="true" tabindex="-1"></a>vine_model <span class="op">=</span> VineCopula(vine_data, vine_type<span class="op">=</span><span class="st">'cvine'</span>)</span>
<span id="cb9-243"><a href="#cb9-243" aria-hidden="true" tabindex="-1"></a>vine_model.fit_cvine()</span>
<span id="cb9-244"><a href="#cb9-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-245"><a href="#cb9-245" aria-hidden="true" tabindex="-1"></a><span class="co"># Create visualization</span></span>
<span id="cb9-246"><a href="#cb9-246" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">25</span>, <span class="dv">20</span>))</span>
<span id="cb9-247"><a href="#cb9-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-248"><a href="#cb9-248" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data pairwise plots</span></span>
<span id="cb9-249"><a href="#cb9-249" aria-hidden="true" tabindex="-1"></a>var_names <span class="op">=</span> [<span class="st">'Normal'</span>, <span class="st">'t(5)'</span>, <span class="st">'Exponential'</span>, <span class="st">'Gamma'</span>]</span>
<span id="cb9-250"><a href="#cb9-250" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb9-251"><a href="#cb9-251" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb9-252"><a href="#cb9-252" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">!=</span> j:</span>
<span id="cb9-253"><a href="#cb9-253" aria-hidden="true" tabindex="-1"></a>            axes[i, j].scatter(vine_data[:, j], vine_data[:, i], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb9-254"><a href="#cb9-254" aria-hidden="true" tabindex="-1"></a>            axes[i, j].set_xlabel(<span class="ss">f'Variable </span><span class="sc">{</span>j<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>var_names[j]<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb9-255"><a href="#cb9-255" aria-hidden="true" tabindex="-1"></a>            axes[i, j].set_ylabel(<span class="ss">f'Variable </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>var_names[i]<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb9-256"><a href="#cb9-256" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-257"><a href="#cb9-257" aria-hidden="true" tabindex="-1"></a>            axes[i, j].hist(vine_data[:, i], bins<span class="op">=</span><span class="dv">30</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-258"><a href="#cb9-258" aria-hidden="true" tabindex="-1"></a>            axes[i, j].set_title(<span class="ss">f'Variable </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>var_names[i]<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb9-259"><a href="#cb9-259" aria-hidden="true" tabindex="-1"></a>        axes[i, j].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb9-260"><a href="#cb9-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-261"><a href="#cb9-261" aria-hidden="true" tabindex="-1"></a><span class="co"># Vine structure visualization</span></span>
<span id="cb9-262"><a href="#cb9-262" aria-hidden="true" tabindex="-1"></a>ax_vine <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">4</span>]</span>
<span id="cb9-263"><a href="#cb9-263" aria-hidden="true" tabindex="-1"></a>ax_vine.set_xlim(<span class="dv">0</span>, <span class="dv">4</span>)</span>
<span id="cb9-264"><a href="#cb9-264" aria-hidden="true" tabindex="-1"></a>ax_vine.set_ylim(<span class="dv">0</span>, <span class="dv">4</span>)</span>
<span id="cb9-265"><a href="#cb9-265" aria-hidden="true" tabindex="-1"></a>ax_vine.set_title(<span class="st">'C-Vine Structure (Tree 1)'</span>)</span>
<span id="cb9-266"><a href="#cb9-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-267"><a href="#cb9-267" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw nodes</span></span>
<span id="cb9-268"><a href="#cb9-268" aria-hidden="true" tabindex="-1"></a>node_positions <span class="op">=</span> {<span class="dv">0</span>: (<span class="dv">1</span>, <span class="dv">2</span>), <span class="dv">1</span>: (<span class="dv">2</span>, <span class="dv">3</span>), <span class="dv">2</span>: (<span class="dv">2</span>, <span class="dv">1</span>), <span class="dv">3</span>: (<span class="dv">3</span>, <span class="dv">2</span>)}</span>
<span id="cb9-269"><a href="#cb9-269" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node, (x, y) <span class="kw">in</span> node_positions.items():</span>
<span id="cb9-270"><a href="#cb9-270" aria-hidden="true" tabindex="-1"></a>    circle <span class="op">=</span> plt.Circle((x, y), <span class="fl">0.2</span>, color<span class="op">=</span><span class="st">'lightblue'</span>, ec<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb9-271"><a href="#cb9-271" aria-hidden="true" tabindex="-1"></a>    ax_vine.add_patch(circle)</span>
<span id="cb9-272"><a href="#cb9-272" aria-hidden="true" tabindex="-1"></a>    ax_vine.text(x, y, <span class="bu">str</span>(node<span class="op">+</span><span class="dv">1</span>), ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb9-273"><a href="#cb9-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-274"><a href="#cb9-274" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw edges for tree 1 (star structure with node 0 as root)</span></span>
<span id="cb9-275"><a href="#cb9-275" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-276"><a href="#cb9-276" aria-hidden="true" tabindex="-1"></a>root_pos <span class="op">=</span> node_positions[root]</span>
<span id="cb9-277"><a href="#cb9-277" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> leaf <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]:</span>
<span id="cb9-278"><a href="#cb9-278" aria-hidden="true" tabindex="-1"></a>    leaf_pos <span class="op">=</span> node_positions[leaf]</span>
<span id="cb9-279"><a href="#cb9-279" aria-hidden="true" tabindex="-1"></a>    ax_vine.plot([root_pos[<span class="dv">0</span>], leaf_pos[<span class="dv">0</span>]], [root_pos[<span class="dv">1</span>], leaf_pos[<span class="dv">1</span>]], </span>
<span id="cb9-280"><a href="#cb9-280" aria-hidden="true" tabindex="-1"></a>                <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb9-281"><a href="#cb9-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-282"><a href="#cb9-282" aria-hidden="true" tabindex="-1"></a>ax_vine.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb9-283"><a href="#cb9-283" aria-hidden="true" tabindex="-1"></a>ax_vine.axis(<span class="st">'off'</span>)</span>
<span id="cb9-284"><a href="#cb9-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-285"><a href="#cb9-285" aria-hidden="true" tabindex="-1"></a><span class="co"># Copula parameters summary</span></span>
<span id="cb9-286"><a href="#cb9-286" aria-hidden="true" tabindex="-1"></a>ax_summary <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">4</span>]</span>
<span id="cb9-287"><a href="#cb9-287" aria-hidden="true" tabindex="-1"></a>ax_summary.axis(<span class="st">'off'</span>)</span>
<span id="cb9-288"><a href="#cb9-288" aria-hidden="true" tabindex="-1"></a>ax_summary.text(<span class="fl">0.1</span>, <span class="fl">0.9</span>, <span class="st">'Vine Copula Summary'</span>, fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb9-289"><a href="#cb9-289" aria-hidden="true" tabindex="-1"></a>                transform<span class="op">=</span>ax_summary.transAxes)</span>
<span id="cb9-290"><a href="#cb9-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-291"><a href="#cb9-291" aria-hidden="true" tabindex="-1"></a>summary_text <span class="op">=</span> <span class="ss">f"Data: </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> observations, </span><span class="sc">{</span><span class="dv">4</span><span class="sc">}</span><span class="ss"> variables</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb9-292"><a href="#cb9-292" aria-hidden="true" tabindex="-1"></a>summary_text <span class="op">+=</span> <span class="ss">f"Vine type: C-vine</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb9-293"><a href="#cb9-293" aria-hidden="true" tabindex="-1"></a>summary_text <span class="op">+=</span> <span class="ss">f"Trees fitted: </span><span class="sc">{</span><span class="bu">len</span>(vine_model.trees)<span class="sc">}</span><span class="ch">\n\n</span><span class="ss">"</span></span>
<span id="cb9-294"><a href="#cb9-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-295"><a href="#cb9-295" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> vine_model.trees:</span>
<span id="cb9-296"><a href="#cb9-296" aria-hidden="true" tabindex="-1"></a>    summary_text <span class="op">+=</span> <span class="st">"Tree 1 Copulas:</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb9-297"><a href="#cb9-297" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edge, params <span class="kw">in</span> vine_model.trees[<span class="dv">0</span>][<span class="st">'copulas'</span>].items():</span>
<span id="cb9-298"><a href="#cb9-298" aria-hidden="true" tabindex="-1"></a>        summary_text <span class="op">+=</span> <span class="ss">f"  </span><span class="sc">{</span>edge[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>edge[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>params[<span class="st">'family'</span>]<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb9-299"><a href="#cb9-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-300"><a href="#cb9-300" aria-hidden="true" tabindex="-1"></a>ax_summary.text(<span class="fl">0.1</span>, <span class="fl">0.7</span>, summary_text, fontsize<span class="op">=</span><span class="dv">10</span>, fontfamily<span class="op">=</span><span class="st">'monospace'</span>,</span>
<span id="cb9-301"><a href="#cb9-301" aria-hidden="true" tabindex="-1"></a>                transform<span class="op">=</span>ax_summary.transAxes, verticalalignment<span class="op">=</span><span class="st">'top'</span>)</span>
<span id="cb9-302"><a href="#cb9-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-303"><a href="#cb9-303" aria-hidden="true" tabindex="-1"></a><span class="co"># Empirical vs theoretical copula comparison (for first tree)</span></span>
<span id="cb9-304"><a href="#cb9-304" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> vine_model.trees <span class="kw">and</span> <span class="bu">hasattr</span>(vine_model, <span class="st">'uniform_data'</span>):</span>
<span id="cb9-305"><a href="#cb9-305" aria-hidden="true" tabindex="-1"></a>    uniform_data <span class="op">=</span> vine_model.uniform_data</span>
<span id="cb9-306"><a href="#cb9-306" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-307"><a href="#cb9-307" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot empirical copula for variables 1 and 2</span></span>
<span id="cb9-308"><a href="#cb9-308" aria-hidden="true" tabindex="-1"></a>    ax_emp <span class="op">=</span> axes[<span class="dv">2</span>, <span class="dv">4</span>]</span>
<span id="cb9-309"><a href="#cb9-309" aria-hidden="true" tabindex="-1"></a>    ax_emp.scatter(uniform_data[:, <span class="dv">0</span>], uniform_data[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb9-310"><a href="#cb9-310" aria-hidden="true" tabindex="-1"></a>    ax_emp.set_xlabel(<span class="st">'U₁'</span>)</span>
<span id="cb9-311"><a href="#cb9-311" aria-hidden="true" tabindex="-1"></a>    ax_emp.set_ylabel(<span class="st">'U₂'</span>)</span>
<span id="cb9-312"><a href="#cb9-312" aria-hidden="true" tabindex="-1"></a>    ax_emp.set_title(<span class="st">'Empirical Copula (Variables 1-2)'</span>)</span>
<span id="cb9-313"><a href="#cb9-313" aria-hidden="true" tabindex="-1"></a>    ax_emp.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb9-314"><a href="#cb9-314" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-315"><a href="#cb9-315" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Model diagnostics</span></span>
<span id="cb9-316"><a href="#cb9-316" aria-hidden="true" tabindex="-1"></a>    ax_diag <span class="op">=</span> axes[<span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb9-317"><a href="#cb9-317" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-318"><a href="#cb9-318" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute pairwise Kendall's tau</span></span>
<span id="cb9-319"><a href="#cb9-319" aria-hidden="true" tabindex="-1"></a>    taus <span class="op">=</span> []</span>
<span id="cb9-320"><a href="#cb9-320" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb9-321"><a href="#cb9-321" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, <span class="dv">4</span>):</span>
<span id="cb9-322"><a href="#cb9-322" aria-hidden="true" tabindex="-1"></a>            tau <span class="op">=</span> stats.kendalltau(uniform_data[:, i], uniform_data[:, j])[<span class="dv">0</span>]</span>
<span id="cb9-323"><a href="#cb9-323" aria-hidden="true" tabindex="-1"></a>            taus.append(tau)</span>
<span id="cb9-324"><a href="#cb9-324" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-325"><a href="#cb9-325" aria-hidden="true" tabindex="-1"></a>    ax_diag.bar(<span class="bu">range</span>(<span class="bu">len</span>(taus)), taus, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb9-326"><a href="#cb9-326" aria-hidden="true" tabindex="-1"></a>    ax_diag.set_xlabel(<span class="st">'Variable Pairs'</span>)</span>
<span id="cb9-327"><a href="#cb9-327" aria-hidden="true" tabindex="-1"></a>    ax_diag.set_ylabel(<span class="st">'Kendall</span><span class="ch">\'</span><span class="st">s τ'</span>)</span>
<span id="cb9-328"><a href="#cb9-328" aria-hidden="true" tabindex="-1"></a>    ax_diag.set_title(<span class="st">'Pairwise Dependence'</span>)</span>
<span id="cb9-329"><a href="#cb9-329" aria-hidden="true" tabindex="-1"></a>    ax_diag.set_xticks(<span class="bu">range</span>(<span class="bu">len</span>(taus)))</span>
<span id="cb9-330"><a href="#cb9-330" aria-hidden="true" tabindex="-1"></a>    ax_diag.set_xticklabels([<span class="st">'1-2'</span>, <span class="st">'1-3'</span>, <span class="st">'1-4'</span>, <span class="st">'2-3'</span>, <span class="st">'2-4'</span>, <span class="st">'3-4'</span>], rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb9-331"><a href="#cb9-331" aria-hidden="true" tabindex="-1"></a>    ax_diag.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb9-332"><a href="#cb9-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-333"><a href="#cb9-333" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.98</span>, top<span class="op">=</span><span class="fl">0.95</span>, bottom<span class="op">=</span><span class="fl">0.08</span>, hspace<span class="op">=</span><span class="fl">0.4</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb9-334"><a href="#cb9-334" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Constructing tree 1
Constructing tree 2</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-vine-copulas" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-vine-copulas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-vine-copulas-output-2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-vine-copulas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Vine copula construction: C-vine and D-vine structures with estimation algorithms
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="model-selection-and-specification" class="level3" data-number="6.4">
<h3 data-number="6.4" class="anchored" data-anchor-id="model-selection-and-specification"><span class="header-section-number">6.4</span> Model Selection and Specification</h3>
<p>Vine copula modeling involves several specification choices:</p>
<section id="vine-structure-selection" class="level4" data-number="6.4.1">
<h4 data-number="6.4.1" class="anchored" data-anchor-id="vine-structure-selection"><span class="header-section-number">6.4.1</span> 1. Vine Structure Selection</h4>
<ul>
<li><strong>C-vine</strong>: Suitable when one variable has strong dependence with all others</li>
<li><strong>D-vine</strong>: Appropriate for sequential or ordered data</li>
<li><strong>Regular vine</strong>: General structure selected based on dependence strength</li>
</ul>
</section>
<section id="copula-family-selection" class="level4" data-number="6.4.2">
<h4 data-number="6.4.2" class="anchored" data-anchor-id="copula-family-selection"><span class="header-section-number">6.4.2</span> 2. Copula Family Selection</h4>
<p>For each bivariate copula in the vine, select among: - <strong>Gaussian</strong>: Symmetric dependence, no tail dependence - <strong>Student’s t</strong>: Symmetric with tail dependence - <strong>Clayton</strong>: Lower tail dependence - <strong>Gumbel</strong>: Upper tail dependence - <strong>Frank</strong>: Symmetric, no tail dependence</p>
</section>
<section id="sequential-estimation-algorithm" class="level4" data-number="6.4.3">
<h4 data-number="6.4.3" class="anchored" data-anchor-id="sequential-estimation-algorithm"><span class="header-section-number">6.4.3</span> 3. Sequential Estimation Algorithm</h4>
<ol type="1">
<li><strong>Transform to uniform margins</strong> using empirical CDFs or parametric fits</li>
<li><strong>For each tree level <span class="math inline">\(k = 1, \ldots, d-1\)</span></strong>:
<ul>
<li>Identify edge set based on vine structure</li>
<li>For each edge <span class="math inline">\((i,j|D)\)</span> with conditioning set <span class="math inline">\(D\)</span>:
<ul>
<li>Compute conditional data <span class="math inline">\(u_{i|D}\)</span> and <span class="math inline">\(u_{j|D}\)</span></li>
<li>Select optimal bivariate copula family</li>
<li>Estimate copula parameters</li>
<li>Compute conditional distributions for next tree</li>
</ul></li>
</ul></li>
</ol>
</section>
</section>
<section id="applications-and-extensions" class="level3" data-number="6.5">
<h3 data-number="6.5" class="anchored" data-anchor-id="applications-and-extensions"><span class="header-section-number">6.5</span> Applications and Extensions</h3>
<p><strong>High-Dimensional Modeling</strong>: Vine copulas scale to high dimensions while maintaining interpretability. They have been successfully applied to portfolios with 50+ assets.</p>
<p><strong>Dynamic Vines</strong>: Extensions allowing time-varying copula parameters and structures <span class="citation" data-cites="patton2006">(<a href="#ref-patton2006" role="doc-biblioref">Patton 2006</a>)</span>.</p>
<p><strong>Truncated Vines</strong>: Simplify high-dimensional vines by setting higher-tree copulas to independence.</p>
<p><strong>Bayesian Vines</strong>: Use Bayesian methods for parameter uncertainty quantification and model selection.</p>
<p><strong>Model Validation</strong>: Use techniques like: - <strong>Probability integral transforms</strong> for goodness-of-fit testing - <strong>Cross-validation</strong> for structure selection - <strong>Rosenblatt transforms</strong> for multivariate model checking</p>
</section>
</section>
<section id="sec-applications" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="sec-applications"><span class="header-section-number">7</span> Applications in Finance and Risk Management</h2>
<p>This section demonstrates practical applications of copulas in portfolio risk management and spatial data analysis, showcasing their power in real-world scenarios.</p>
<section id="portfolio-risk-management-and-value-at-risk" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="portfolio-risk-management-and-value-at-risk"><span class="header-section-number">7.1</span> Portfolio Risk Management and Value-at-Risk</h3>
<p>Portfolio risk management represents one of the most successful applications of copula theory in quantitative finance. Traditional approaches often assume multivariate normality or rely on linear correlation measures, which fail to capture the complex dependence patterns observed in financial markets during stress periods.</p>
<p><strong>The Challenge</strong>: Financial assets exhibit several stylized facts that complicate risk modeling: - <strong>Fat tails</strong>: Return distributions have heavier tails than the normal distribution - <strong>Asymmetric dependence</strong>: Correlations increase during market downturns (contagion effect) - <strong>Tail dependence</strong>: Extreme losses tend to occur simultaneously across assets - <strong>Time-varying correlations</strong>: Dependence structures evolve over time</p>
<p><strong>The Copula Solution</strong>: By separating marginal behavior from dependence structure, copulas allow risk managers to: 1. Model each asset’s return distribution using appropriate heavy-tailed distributions (Student’s t, skewed distributions) 2. Capture realistic dependence patterns through flexible copula functions 3. Generate scenarios that preserve both marginal characteristics and joint behavior 4. Compute accurate tail risk measures like Value-at-Risk (VaR) and Expected Shortfall (ES)</p>
<p>The following implementation demonstrates a comprehensive copula-based risk management framework, comparing Gaussian and Student’s t copulas for portfolio VaR estimation:</p>
<div id="cell-fig-portfolio-risk" class="cell" data-fig-height="15" data-fig-width="20" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PortfolioRiskAnalyzer:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Comprehensive portfolio risk analysis using copulas"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, returns_data, weights<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.returns <span class="op">=</span> returns_data</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_assets <span class="op">=</span> returns_data.shape[<span class="dv">1</span>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> weights <span class="cf">if</span> weights <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> np.ones(<span class="va">self</span>.n_assets) <span class="op">/</span> <span class="va">self</span>.n_assets</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit_marginals(<span class="va">self</span>, distribution<span class="op">=</span><span class="st">'t'</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fit marginal distributions to return data"""</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.marginal_params <span class="op">=</span> []</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.marginal_cdfs <span class="op">=</span> []</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.n_assets):</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> <span class="va">self</span>.returns[:, i]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> distribution <span class="op">==</span> <span class="st">'t'</span>:</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Fit Student's t distribution</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> stats.t.fit(data)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_params.append(params)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_cdfs.append(<span class="kw">lambda</span> x, p<span class="op">=</span>params: stats.t.cdf(x, <span class="op">*</span>p))</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> distribution <span class="op">==</span> <span class="st">'normal'</span>:</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Fit normal distribution</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> stats.norm.fit(data)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_params.append(params)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.marginal_cdfs.append(<span class="kw">lambda</span> x, p<span class="op">=</span>params: stats.norm.cdf(x, <span class="op">*</span>p))</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform_to_uniform(<span class="va">self</span>):</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Transform returns to uniform margins using fitted distributions"""</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.uniform_data <span class="op">=</span> np.zeros_like(<span class="va">self</span>.returns)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.n_assets):</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'marginal_params'</span>):</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> <span class="va">self</span>.marginal_params[i]</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.uniform_data[:, i] <span class="op">=</span> stats.t.cdf(<span class="va">self</span>.returns[:, i], <span class="op">*</span>params)</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Use empirical CDF</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.uniform_data[:, i] <span class="op">=</span> stats.rankdata(<span class="va">self</span>.returns[:, i]) <span class="op">/</span> (<span class="bu">len</span>(<span class="va">self</span>.returns) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> estimate_copula_parameters(<span class="va">self</span>, copula_type<span class="op">=</span><span class="st">'gaussian'</span>):</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Estimate copula parameters from uniform data"""</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'uniform_data'</span>):</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.transform_to_uniform()</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> copula_type <span class="op">==</span> <span class="st">'gaussian'</span>:</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform to normal and estimate correlation</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>            normal_data <span class="op">=</span> stats.norm.ppf(np.clip(<span class="va">self</span>.uniform_data, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.copula_params <span class="op">=</span> np.corrcoef(normal_data.T)</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.copula_type <span class="op">=</span> <span class="st">'gaussian'</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> copula_type <span class="op">==</span> <span class="st">'t'</span>:</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Estimate t copula parameters (simplified)</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>            normal_data <span class="op">=</span> stats.norm.ppf(np.clip(<span class="va">self</span>.uniform_data, <span class="fl">0.001</span>, <span class="fl">0.999</span>))</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.copula_params <span class="op">=</span> {</span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>                <span class="st">'correlation'</span>: np.corrcoef(normal_data.T),</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>                <span class="st">'df'</span>: <span class="dv">5</span>  <span class="co"># Fixed for simplicity, could be estimated</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.copula_type <span class="op">=</span> <span class="st">'t'</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_portfolio_returns(<span class="va">self</span>, n_simulations<span class="op">=</span><span class="dv">10000</span>, copula_type<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate portfolio returns using fitted copula"""</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> copula_type <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>            copula_type <span class="op">=</span> <span class="bu">getattr</span>(<span class="va">self</span>, <span class="st">'copula_type'</span>, <span class="st">'gaussian'</span>)</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate copula samples</span></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> copula_type <span class="op">==</span> <span class="st">'gaussian'</span>:</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Generate from multivariate normal copula</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>            corr_matrix <span class="op">=</span> <span class="va">self</span>.copula_params</span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>            normal_samples <span class="op">=</span> np.random.multivariate_normal(</span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>                np.zeros(<span class="va">self</span>.n_assets), corr_matrix, n_simulations</span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>            uniform_samples <span class="op">=</span> stats.norm.cdf(normal_samples)</span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> copula_type <span class="op">==</span> <span class="st">'t'</span>:</span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Generate from multivariate t copula</span></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>            corr_matrix <span class="op">=</span> <span class="va">self</span>.copula_params[<span class="st">'correlation'</span>]</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> <span class="va">self</span>.copula_params[<span class="st">'df'</span>]</span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>            t_samples <span class="op">=</span> np.random.multivariate_normal(</span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>                np.zeros(<span class="va">self</span>.n_assets), corr_matrix, n_simulations</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply t distribution transformation (simplified)</span></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>            chi2_samples <span class="op">=</span> np.random.chisquare(df, n_simulations)</span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>            t_samples <span class="op">=</span> t_samples <span class="op">*</span> np.sqrt(df <span class="op">/</span> chi2_samples[:, np.newaxis])</span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>            uniform_samples <span class="op">=</span> stats.t.cdf(t_samples, df)</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform back to return space using inverse marginal CDFs</span></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>        simulated_returns <span class="op">=</span> np.zeros_like(uniform_samples)</span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.n_assets):</span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'marginal_params'</span>):</span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a>                params <span class="op">=</span> <span class="va">self</span>.marginal_params[i]</span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>                simulated_returns[:, i] <span class="op">=</span> stats.t.ppf(uniform_samples[:, i], <span class="op">*</span>params)</span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Use empirical quantiles</span></span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>                quantiles <span class="op">=</span> np.percentile(<span class="va">self</span>.returns[:, i], uniform_samples[:, i] <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>                simulated_returns[:, i] <span class="op">=</span> quantiles</span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate portfolio returns</span></span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true" tabindex="-1"></a>        portfolio_returns <span class="op">=</span> np.dot(simulated_returns, <span class="va">self</span>.weights)</span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> portfolio_returns, simulated_returns</span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_var_es(<span class="va">self</span>, portfolio_returns, confidence_levels<span class="op">=</span>[<span class="fl">0.95</span>, <span class="fl">0.99</span>]):</span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Calculate Value-at-Risk and Expected Shortfall"""</span></span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> {}</span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> alpha <span class="kw">in</span> confidence_levels:</span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true" tabindex="-1"></a>            var <span class="op">=</span> np.percentile(portfolio_returns, (<span class="dv">1</span> <span class="op">-</span> alpha) <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true" tabindex="-1"></a>            es <span class="op">=</span> np.mean(portfolio_returns[portfolio_returns <span class="op">&lt;=</span> var])</span>
<span id="cb11-107"><a href="#cb11-107" aria-hidden="true" tabindex="-1"></a>            results[alpha] <span class="op">=</span> {<span class="st">'VaR'</span>: var, <span class="st">'ES'</span>: es}</span>
<span id="cb11-108"><a href="#cb11-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> results</span>
<span id="cb11-109"><a href="#cb11-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-110"><a href="#cb11-110" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic financial data with realistic properties</span></span>
<span id="cb11-111"><a href="#cb11-111" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb11-112"><a href="#cb11-112" aria-hidden="true" tabindex="-1"></a>n_days <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb11-113"><a href="#cb11-113" aria-hidden="true" tabindex="-1"></a>n_assets <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb11-114"><a href="#cb11-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-115"><a href="#cb11-115" aria-hidden="true" tabindex="-1"></a><span class="co"># Asset names</span></span>
<span id="cb11-116"><a href="#cb11-116" aria-hidden="true" tabindex="-1"></a>asset_names <span class="op">=</span> [<span class="st">'Tech Stock'</span>, <span class="st">'Bank Stock'</span>, <span class="st">'Commodity'</span>, <span class="st">'Bond'</span>]</span>
<span id="cb11-117"><a href="#cb11-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-118"><a href="#cb11-118" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate correlated returns with different characteristics</span></span>
<span id="cb11-119"><a href="#cb11-119" aria-hidden="true" tabindex="-1"></a>base_corr <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb11-120"><a href="#cb11-120" aria-hidden="true" tabindex="-1"></a>correlations <span class="op">=</span> np.array([</span>
<span id="cb11-121"><a href="#cb11-121" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>, <span class="op">-</span><span class="fl">0.1</span>],</span>
<span id="cb11-122"><a href="#cb11-122" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.4</span>, <span class="fl">1.0</span>, <span class="fl">0.3</span>, <span class="fl">0.0</span>],</span>
<span id="cb11-123"><a href="#cb11-123" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">1.0</span>, <span class="op">-</span><span class="fl">0.2</span>],</span>
<span id="cb11-124"><a href="#cb11-124" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.0</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">1.0</span>]</span>
<span id="cb11-125"><a href="#cb11-125" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb11-126"><a href="#cb11-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-127"><a href="#cb11-127" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate base normal returns</span></span>
<span id="cb11-128"><a href="#cb11-128" aria-hidden="true" tabindex="-1"></a>base_returns <span class="op">=</span> np.random.multivariate_normal(np.zeros(n_assets), correlations, n_days)</span>
<span id="cb11-129"><a href="#cb11-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-130"><a href="#cb11-130" aria-hidden="true" tabindex="-1"></a><span class="co"># Transform to different marginal distributions</span></span>
<span id="cb11-131"><a href="#cb11-131" aria-hidden="true" tabindex="-1"></a>returns_data <span class="op">=</span> np.zeros_like(base_returns)</span>
<span id="cb11-132"><a href="#cb11-132" aria-hidden="true" tabindex="-1"></a>returns_data[:, <span class="dv">0</span>] <span class="op">=</span> base_returns[:, <span class="dv">0</span>] <span class="op">*</span> <span class="fl">0.02</span> <span class="op">+</span> <span class="fl">0.0005</span>  <span class="co"># Tech: higher volatility</span></span>
<span id="cb11-133"><a href="#cb11-133" aria-hidden="true" tabindex="-1"></a>returns_data[:, <span class="dv">1</span>] <span class="op">=</span> stats.t.ppf(stats.norm.cdf(base_returns[:, <span class="dv">1</span>]), df<span class="op">=</span><span class="dv">4</span>) <span class="op">*</span> <span class="fl">0.015</span> <span class="op">+</span> <span class="fl">0.0003</span>  <span class="co"># Bank: fat tails</span></span>
<span id="cb11-134"><a href="#cb11-134" aria-hidden="true" tabindex="-1"></a>returns_data[:, <span class="dv">2</span>] <span class="op">=</span> base_returns[:, <span class="dv">2</span>] <span class="op">*</span> <span class="fl">0.025</span> <span class="op">+</span> <span class="fl">0.0002</span>  <span class="co"># Commodity: high volatility</span></span>
<span id="cb11-135"><a href="#cb11-135" aria-hidden="true" tabindex="-1"></a>returns_data[:, <span class="dv">3</span>] <span class="op">=</span> base_returns[:, <span class="dv">3</span>] <span class="op">*</span> <span class="fl">0.005</span> <span class="op">+</span> <span class="fl">0.0001</span>  <span class="co"># Bond: low volatility</span></span>
<span id="cb11-136"><a href="#cb11-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-137"><a href="#cb11-137" aria-hidden="true" tabindex="-1"></a><span class="co"># Equal weights portfolio</span></span>
<span id="cb11-138"><a href="#cb11-138" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.array([<span class="fl">0.25</span>, <span class="fl">0.25</span>, <span class="fl">0.25</span>, <span class="fl">0.25</span>])</span>
<span id="cb11-139"><a href="#cb11-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-140"><a href="#cb11-140" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize analyzer</span></span>
<span id="cb11-141"><a href="#cb11-141" aria-hidden="true" tabindex="-1"></a>analyzer <span class="op">=</span> PortfolioRiskAnalyzer(returns_data, weights)</span>
<span id="cb11-142"><a href="#cb11-142" aria-hidden="true" tabindex="-1"></a>analyzer.fit_marginals(<span class="st">'t'</span>)</span>
<span id="cb11-143"><a href="#cb11-143" aria-hidden="true" tabindex="-1"></a>analyzer.transform_to_uniform()</span>
<span id="cb11-144"><a href="#cb11-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-145"><a href="#cb11-145" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare different copula models</span></span>
<span id="cb11-146"><a href="#cb11-146" aria-hidden="true" tabindex="-1"></a>copula_models <span class="op">=</span> [<span class="st">'gaussian'</span>, <span class="st">'t'</span>]</span>
<span id="cb11-147"><a href="#cb11-147" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb11-148"><a href="#cb11-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-149"><a href="#cb11-149" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">25</span>, <span class="dv">20</span>))</span>
<span id="cb11-150"><a href="#cb11-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-151"><a href="#cb11-151" aria-hidden="true" tabindex="-1"></a><span class="co"># Historical returns analysis</span></span>
<span id="cb11-152"><a href="#cb11-152" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, asset <span class="kw">in</span> <span class="bu">enumerate</span>(asset_names):</span>
<span id="cb11-153"><a href="#cb11-153" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].hist(returns_data[:, i], bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-154"><a href="#cb11-154" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>asset<span class="sc">}</span><span class="ss"> Returns'</span>)</span>
<span id="cb11-155"><a href="#cb11-155" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_xlabel(<span class="st">'Return'</span>)</span>
<span id="cb11-156"><a href="#cb11-156" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-157"><a href="#cb11-157" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].grid(<span class="va">True</span>)</span>
<span id="cb11-158"><a href="#cb11-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-159"><a href="#cb11-159" aria-hidden="true" tabindex="-1"></a><span class="co"># Portfolio returns comparison</span></span>
<span id="cb11-160"><a href="#cb11-160" aria-hidden="true" tabindex="-1"></a>historical_portfolio <span class="op">=</span> np.dot(returns_data, weights)</span>
<span id="cb11-161"><a href="#cb11-161" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">4</span>].hist(historical_portfolio, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, label<span class="op">=</span><span class="st">'Historical'</span>)</span>
<span id="cb11-162"><a href="#cb11-162" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">4</span>].set_title(<span class="st">'Portfolio Returns'</span>)</span>
<span id="cb11-163"><a href="#cb11-163" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">4</span>].set_xlabel(<span class="st">'Return'</span>)</span>
<span id="cb11-164"><a href="#cb11-164" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">4</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-165"><a href="#cb11-165" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">4</span>].legend()</span>
<span id="cb11-166"><a href="#cb11-166" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">4</span>].grid(<span class="va">True</span>)</span>
<span id="cb11-167"><a href="#cb11-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-168"><a href="#cb11-168" aria-hidden="true" tabindex="-1"></a><span class="co"># Copula comparison</span></span>
<span id="cb11-169"><a href="#cb11-169" aria-hidden="true" tabindex="-1"></a>simulation_results <span class="op">=</span> {}</span>
<span id="cb11-170"><a href="#cb11-170" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, copula_type <span class="kw">in</span> <span class="bu">enumerate</span>(copula_models):</span>
<span id="cb11-171"><a href="#cb11-171" aria-hidden="true" tabindex="-1"></a>    analyzer.estimate_copula_parameters(copula_type)</span>
<span id="cb11-172"><a href="#cb11-172" aria-hidden="true" tabindex="-1"></a>    portfolio_sim, returns_sim <span class="op">=</span> analyzer.simulate_portfolio_returns(<span class="dv">10000</span>, copula_type)</span>
<span id="cb11-173"><a href="#cb11-173" aria-hidden="true" tabindex="-1"></a>    simulation_results[copula_type] <span class="op">=</span> portfolio_sim</span>
<span id="cb11-174"><a href="#cb11-174" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-175"><a href="#cb11-175" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Portfolio distribution comparison</span></span>
<span id="cb11-176"><a href="#cb11-176" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].hist(historical_portfolio, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb11-177"><a href="#cb11-177" aria-hidden="true" tabindex="-1"></a>                   label<span class="op">=</span><span class="st">'Historical'</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb11-178"><a href="#cb11-178" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].hist(portfolio_sim, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb11-179"><a href="#cb11-179" aria-hidden="true" tabindex="-1"></a>                   label<span class="op">=</span><span class="ss">f'</span><span class="sc">{</span>copula_type<span class="sc">.</span>title()<span class="sc">}</span><span class="ss"> Copula'</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb11-180"><a href="#cb11-180" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].set_title(<span class="ss">f'Portfolio: </span><span class="sc">{</span>copula_type<span class="sc">.</span>title()<span class="sc">}</span><span class="ss"> Copula'</span>)</span>
<span id="cb11-181"><a href="#cb11-181" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].set_xlabel(<span class="st">'Return'</span>)</span>
<span id="cb11-182"><a href="#cb11-182" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-183"><a href="#cb11-183" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].legend()</span>
<span id="cb11-184"><a href="#cb11-184" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, j].grid(<span class="va">True</span>)</span>
<span id="cb11-185"><a href="#cb11-185" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-186"><a href="#cb11-186" aria-hidden="true" tabindex="-1"></a>    <span class="co"># VaR calculation</span></span>
<span id="cb11-187"><a href="#cb11-187" aria-hidden="true" tabindex="-1"></a>    var_results <span class="op">=</span> analyzer.calculate_var_es(portfolio_sim)</span>
<span id="cb11-188"><a href="#cb11-188" aria-hidden="true" tabindex="-1"></a>    results[copula_type] <span class="op">=</span> var_results</span>
<span id="cb11-189"><a href="#cb11-189" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-190"><a href="#cb11-190" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Q-Q plot for tail analysis</span></span>
<span id="cb11-191"><a href="#cb11-191" aria-hidden="true" tabindex="-1"></a>    q_theoretical <span class="op">=</span> np.percentile(portfolio_sim, np.linspace(<span class="dv">1</span>, <span class="dv">99</span>, <span class="dv">99</span>))</span>
<span id="cb11-192"><a href="#cb11-192" aria-hidden="true" tabindex="-1"></a>    q_historical <span class="op">=</span> np.percentile(historical_portfolio, np.linspace(<span class="dv">1</span>, <span class="dv">99</span>, <span class="dv">99</span>))</span>
<span id="cb11-193"><a href="#cb11-193" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j].plot(q_theoretical, q_historical, <span class="st">'o'</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb11-194"><a href="#cb11-194" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j].plot([q_theoretical.<span class="bu">min</span>(), q_theoretical.<span class="bu">max</span>()], </span>
<span id="cb11-195"><a href="#cb11-195" aria-hidden="true" tabindex="-1"></a>                   [q_theoretical.<span class="bu">min</span>(), q_theoretical.<span class="bu">max</span>()], <span class="st">'r--'</span>)</span>
<span id="cb11-196"><a href="#cb11-196" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j].set_title(<span class="ss">f'Q-Q Plot: </span><span class="sc">{</span>copula_type<span class="sc">.</span>title()<span class="sc">}</span><span class="ss"> vs Historical'</span>)</span>
<span id="cb11-197"><a href="#cb11-197" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j].set_xlabel(<span class="st">'Simulated Quantiles'</span>)</span>
<span id="cb11-198"><a href="#cb11-198" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j].set_ylabel(<span class="st">'Historical Quantiles'</span>)</span>
<span id="cb11-199"><a href="#cb11-199" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j].grid(<span class="va">True</span>)</span>
<span id="cb11-200"><a href="#cb11-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-201"><a href="#cb11-201" aria-hidden="true" tabindex="-1"></a><span class="co"># VaR comparison</span></span>
<span id="cb11-202"><a href="#cb11-202" aria-hidden="true" tabindex="-1"></a>confidence_levels <span class="op">=</span> [<span class="fl">0.95</span>, <span class="fl">0.99</span>]</span>
<span id="cb11-203"><a href="#cb11-203" aria-hidden="true" tabindex="-1"></a>var_comparison <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>copula_models, </span>
<span id="cb11-204"><a href="#cb11-204" aria-hidden="true" tabindex="-1"></a>                             columns<span class="op">=</span>[<span class="ss">f'VaR_</span><span class="sc">{</span><span class="bu">int</span>(cl<span class="op">*</span><span class="dv">100</span>)<span class="sc">}</span><span class="ss">%'</span> <span class="cf">for</span> cl <span class="kw">in</span> confidence_levels] <span class="op">+</span> </span>
<span id="cb11-205"><a href="#cb11-205" aria-hidden="true" tabindex="-1"></a>                                    [<span class="ss">f'ES_</span><span class="sc">{</span><span class="bu">int</span>(cl<span class="op">*</span><span class="dv">100</span>)<span class="sc">}</span><span class="ss">%'</span> <span class="cf">for</span> cl <span class="kw">in</span> confidence_levels])</span>
<span id="cb11-206"><a href="#cb11-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-207"><a href="#cb11-207" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> copula <span class="kw">in</span> copula_models:</span>
<span id="cb11-208"><a href="#cb11-208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> cl <span class="kw">in</span> confidence_levels:</span>
<span id="cb11-209"><a href="#cb11-209" aria-hidden="true" tabindex="-1"></a>        var_comparison.loc[copula, <span class="ss">f'VaR_</span><span class="sc">{</span><span class="bu">int</span>(cl<span class="op">*</span><span class="dv">100</span>)<span class="sc">}</span><span class="ss">%'</span>] <span class="op">=</span> results[copula][cl][<span class="st">'VaR'</span>]</span>
<span id="cb11-210"><a href="#cb11-210" aria-hidden="true" tabindex="-1"></a>        var_comparison.loc[copula, <span class="ss">f'ES_</span><span class="sc">{</span><span class="bu">int</span>(cl<span class="op">*</span><span class="dv">100</span>)<span class="sc">}</span><span class="ss">%'</span>] <span class="op">=</span> results[copula][cl][<span class="st">'ES'</span>]</span>
<span id="cb11-211"><a href="#cb11-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-212"><a href="#cb11-212" aria-hidden="true" tabindex="-1"></a><span class="co"># Historical VaR for comparison</span></span>
<span id="cb11-213"><a href="#cb11-213" aria-hidden="true" tabindex="-1"></a>historical_var_95 <span class="op">=</span> np.percentile(historical_portfolio, <span class="dv">5</span>)</span>
<span id="cb11-214"><a href="#cb11-214" aria-hidden="true" tabindex="-1"></a>historical_var_99 <span class="op">=</span> np.percentile(historical_portfolio, <span class="dv">1</span>)</span>
<span id="cb11-215"><a href="#cb11-215" aria-hidden="true" tabindex="-1"></a>historical_es_95 <span class="op">=</span> np.mean(historical_portfolio[historical_portfolio <span class="op">&lt;=</span> historical_var_95])</span>
<span id="cb11-216"><a href="#cb11-216" aria-hidden="true" tabindex="-1"></a>historical_es_99 <span class="op">=</span> np.mean(historical_portfolio[historical_portfolio <span class="op">&lt;=</span> historical_var_99])</span>
<span id="cb11-217"><a href="#cb11-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-218"><a href="#cb11-218" aria-hidden="true" tabindex="-1"></a><span class="co"># Bar plot of VaR estimates</span></span>
<span id="cb11-219"><a href="#cb11-219" aria-hidden="true" tabindex="-1"></a>x_pos <span class="op">=</span> np.arange(<span class="bu">len</span>(copula_models))</span>
<span id="cb11-220"><a href="#cb11-220" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="fl">0.35</span></span>
<span id="cb11-221"><a href="#cb11-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-222"><a href="#cb11-222" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].bar(x_pos <span class="op">-</span> width<span class="op">/</span><span class="dv">2</span>, [results[c][<span class="fl">0.95</span>][<span class="st">'VaR'</span>] <span class="cf">for</span> c <span class="kw">in</span> copula_models], </span>
<span id="cb11-223"><a href="#cb11-223" aria-hidden="true" tabindex="-1"></a>              width, label<span class="op">=</span><span class="st">'VaR 95%'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-224"><a href="#cb11-224" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].bar(x_pos <span class="op">+</span> width<span class="op">/</span><span class="dv">2</span>, [results[c][<span class="fl">0.99</span>][<span class="st">'VaR'</span>] <span class="cf">for</span> c <span class="kw">in</span> copula_models], </span>
<span id="cb11-225"><a href="#cb11-225" aria-hidden="true" tabindex="-1"></a>              width, label<span class="op">=</span><span class="st">'VaR 99%'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-226"><a href="#cb11-226" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].axhline(y<span class="op">=</span>historical_var_95, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Historical VaR 95%'</span>)</span>
<span id="cb11-227"><a href="#cb11-227" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].axhline(y<span class="op">=</span>historical_var_99, color<span class="op">=</span><span class="st">'orange'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Historical VaR 99%'</span>)</span>
<span id="cb11-228"><a href="#cb11-228" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'VaR Comparison'</span>)</span>
<span id="cb11-229"><a href="#cb11-229" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Copula Model'</span>)</span>
<span id="cb11-230"><a href="#cb11-230" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'VaR'</span>)</span>
<span id="cb11-231"><a href="#cb11-231" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xticks(x_pos)</span>
<span id="cb11-232"><a href="#cb11-232" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xticklabels([c.title() <span class="cf">for</span> c <span class="kw">in</span> copula_models])</span>
<span id="cb11-233"><a href="#cb11-233" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].legend()</span>
<span id="cb11-234"><a href="#cb11-234" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].grid(<span class="va">True</span>)</span>
<span id="cb11-235"><a href="#cb11-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-236"><a href="#cb11-236" aria-hidden="true" tabindex="-1"></a><span class="co"># Tail dependence visualization</span></span>
<span id="cb11-237"><a href="#cb11-237" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, copula_type <span class="kw">in</span> <span class="bu">enumerate</span>(copula_models):</span>
<span id="cb11-238"><a href="#cb11-238" aria-hidden="true" tabindex="-1"></a>    portfolio_sim <span class="op">=</span> simulation_results[copula_type]</span>
<span id="cb11-239"><a href="#cb11-239" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-240"><a href="#cb11-240" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extreme value analysis</span></span>
<span id="cb11-241"><a href="#cb11-241" aria-hidden="true" tabindex="-1"></a>    threshold_95 <span class="op">=</span> np.percentile(portfolio_sim, <span class="dv">5</span>)  <span class="co"># Lower 5% (bad returns)</span></span>
<span id="cb11-242"><a href="#cb11-242" aria-hidden="true" tabindex="-1"></a>    extreme_returns <span class="op">=</span> portfolio_sim[portfolio_sim <span class="op">&lt;=</span> threshold_95]</span>
<span id="cb11-243"><a href="#cb11-243" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-244"><a href="#cb11-244" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].hist(extreme_returns, bins<span class="op">=</span><span class="dv">30</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-245"><a href="#cb11-245" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].axvline(x<span class="op">=</span>results[copula_type][<span class="fl">0.99</span>][<span class="st">'VaR'</span>], color<span class="op">=</span><span class="st">'r'</span>, </span>
<span id="cb11-246"><a href="#cb11-246" aria-hidden="true" tabindex="-1"></a>                        linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'VaR 99%'</span>)</span>
<span id="cb11-247"><a href="#cb11-247" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].axvline(x<span class="op">=</span>results[copula_type][<span class="fl">0.99</span>][<span class="st">'ES'</span>], color<span class="op">=</span><span class="st">'orange'</span>, </span>
<span id="cb11-248"><a href="#cb11-248" aria-hidden="true" tabindex="-1"></a>                        linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'ES 99%'</span>)</span>
<span id="cb11-249"><a href="#cb11-249" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].set_title(<span class="ss">f'Tail Analysis: </span><span class="sc">{</span>copula_type<span class="sc">.</span>title()<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb11-250"><a href="#cb11-250" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].set_xlabel(<span class="st">'Extreme Returns'</span>)</span>
<span id="cb11-251"><a href="#cb11-251" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb11-252"><a href="#cb11-252" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].legend()</span>
<span id="cb11-253"><a href="#cb11-253" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, j<span class="op">+</span><span class="dv">2</span>].grid(<span class="va">True</span>)</span>
<span id="cb11-254"><a href="#cb11-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-255"><a href="#cb11-255" aria-hidden="true" tabindex="-1"></a><span class="co"># Risk decomposition by asset</span></span>
<span id="cb11-256"><a href="#cb11-256" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, asset <span class="kw">in</span> <span class="bu">enumerate</span>(asset_names):</span>
<span id="cb11-257"><a href="#cb11-257" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Marginal contribution to portfolio risk</span></span>
<span id="cb11-258"><a href="#cb11-258" aria-hidden="true" tabindex="-1"></a>    asset_contribution <span class="op">=</span> []</span>
<span id="cb11-259"><a href="#cb11-259" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> copula_type <span class="kw">in</span> copula_models:</span>
<span id="cb11-260"><a href="#cb11-260" aria-hidden="true" tabindex="-1"></a>        analyzer.estimate_copula_parameters(copula_type)</span>
<span id="cb11-261"><a href="#cb11-261" aria-hidden="true" tabindex="-1"></a>        portfolio_sim, returns_sim <span class="op">=</span> analyzer.simulate_portfolio_returns(<span class="dv">5000</span>, copula_type)</span>
<span id="cb11-262"><a href="#cb11-262" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-263"><a href="#cb11-263" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate asset's contribution to portfolio VaR</span></span>
<span id="cb11-264"><a href="#cb11-264" aria-hidden="true" tabindex="-1"></a>        var_95 <span class="op">=</span> np.percentile(portfolio_sim, <span class="dv">5</span>)</span>
<span id="cb11-265"><a href="#cb11-265" aria-hidden="true" tabindex="-1"></a>        tail_indices <span class="op">=</span> portfolio_sim <span class="op">&lt;=</span> var_95</span>
<span id="cb11-266"><a href="#cb11-266" aria-hidden="true" tabindex="-1"></a>        asset_contrib <span class="op">=</span> np.mean(returns_sim[tail_indices, i] <span class="op">*</span> weights[i])</span>
<span id="cb11-267"><a href="#cb11-267" aria-hidden="true" tabindex="-1"></a>        asset_contribution.append(asset_contrib)</span>
<span id="cb11-268"><a href="#cb11-268" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-269"><a href="#cb11-269" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">3</span>, i].bar(copula_models, asset_contribution, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb11-270"><a href="#cb11-270" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">3</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>asset<span class="sc">}</span><span class="ss"> Risk Contribution'</span>)</span>
<span id="cb11-271"><a href="#cb11-271" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">3</span>, i].set_xlabel(<span class="st">'Copula Model'</span>)</span>
<span id="cb11-272"><a href="#cb11-272" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">3</span>, i].set_ylabel(<span class="st">'Contribution to VaR'</span>)</span>
<span id="cb11-273"><a href="#cb11-273" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">3</span>, i].grid(<span class="va">True</span>)</span>
<span id="cb11-274"><a href="#cb11-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-275"><a href="#cb11-275" aria-hidden="true" tabindex="-1"></a><span class="co"># Summary statistics table</span></span>
<span id="cb11-276"><a href="#cb11-276" aria-hidden="true" tabindex="-1"></a>summary_stats <span class="op">=</span> pd.DataFrame({</span>
<span id="cb11-277"><a href="#cb11-277" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Historical'</span>: [historical_portfolio.mean(), historical_portfolio.std(), </span>
<span id="cb11-278"><a href="#cb11-278" aria-hidden="true" tabindex="-1"></a>                  stats.skew(historical_portfolio), stats.kurtosis(historical_portfolio)],</span>
<span id="cb11-279"><a href="#cb11-279" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Gaussian Copula'</span>: [simulation_results[<span class="st">'gaussian'</span>].mean(), simulation_results[<span class="st">'gaussian'</span>].std(),</span>
<span id="cb11-280"><a href="#cb11-280" aria-hidden="true" tabindex="-1"></a>                       stats.skew(simulation_results[<span class="st">'gaussian'</span>]), stats.kurtosis(simulation_results[<span class="st">'gaussian'</span>])],</span>
<span id="cb11-281"><a href="#cb11-281" aria-hidden="true" tabindex="-1"></a>    <span class="st">'t Copula'</span>: [simulation_results[<span class="st">'t'</span>].mean(), simulation_results[<span class="st">'t'</span>].std(),</span>
<span id="cb11-282"><a href="#cb11-282" aria-hidden="true" tabindex="-1"></a>                stats.skew(simulation_results[<span class="st">'t'</span>]), stats.kurtosis(simulation_results[<span class="st">'t'</span>])]</span>
<span id="cb11-283"><a href="#cb11-283" aria-hidden="true" tabindex="-1"></a>}, index<span class="op">=</span>[<span class="st">'Mean'</span>, <span class="st">'Std Dev'</span>, <span class="st">'Skewness'</span>, <span class="st">'Kurtosis'</span>])</span>
<span id="cb11-284"><a href="#cb11-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-285"><a href="#cb11-285" aria-hidden="true" tabindex="-1"></a><span class="co"># Create text plot for summary</span></span>
<span id="cb11-286"><a href="#cb11-286" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">4</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb11-287"><a href="#cb11-287" aria-hidden="true" tabindex="-1"></a>table_text <span class="op">=</span> summary_stats.<span class="bu">round</span>(<span class="dv">4</span>).to_string()</span>
<span id="cb11-288"><a href="#cb11-288" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">4</span>].text(<span class="fl">0.1</span>, <span class="fl">0.9</span>, <span class="st">'Portfolio Statistics'</span>, transform<span class="op">=</span>axes[<span class="dv">3</span>, <span class="dv">4</span>].transAxes, </span>
<span id="cb11-289"><a href="#cb11-289" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb11-290"><a href="#cb11-290" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">4</span>].text(<span class="fl">0.1</span>, <span class="fl">0.1</span>, table_text, transform<span class="op">=</span>axes[<span class="dv">3</span>, <span class="dv">4</span>].transAxes, </span>
<span id="cb11-291"><a href="#cb11-291" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, fontfamily<span class="op">=</span><span class="st">'monospace'</span>)</span>
<span id="cb11-292"><a href="#cb11-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-293"><a href="#cb11-293" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.98</span>, top<span class="op">=</span><span class="fl">0.95</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.4</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb11-294"><a href="#cb11-294" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-portfolio-risk" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-portfolio-risk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-portfolio-risk-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-portfolio-risk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Portfolio risk analysis using copulas: VaR estimation and tail risk assessment
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="spatial-data-analysis-with-copulas" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="spatial-data-analysis-with-copulas"><span class="header-section-number">7.2</span> Spatial Data Analysis with Copulas</h3>
<p>Spatial data analysis presents unique challenges that make copulas particularly valuable. Traditional geostatistical methods like kriging assume Gaussian distributions and rely on the variogram to model spatial dependence. However, many environmental and geological phenomena exhibit non-Gaussian marginal distributions and complex spatial dependence structures that cannot be adequately captured by classical approaches.</p>
<p><strong>Spatial Challenges Addressed by Copulas</strong>: - <strong>Marginal heterogeneity</strong>: Different locations may have different marginal distributions due to local environmental conditions - <strong>Non-linear spatial dependence</strong>: The relationship between observations may not be captured by linear correlation - <strong>Scale effects</strong>: Dependence patterns may vary at different spatial scales - <strong>Multivariate spatial fields</strong>: Multiple correlated variables observed at the same locations</p>
<p><strong>Advantages of Spatial Copulas</strong>: 1. <strong>Flexible marginal modeling</strong>: Each location can have its own marginal distribution while preserving spatial structure 2. <strong>Non-parametric dependence</strong>: Capture complex spatial relationships beyond exponential or spherical models 3. <strong>Simulation capabilities</strong>: Generate realistic spatial fields that preserve both marginal properties and spatial correlation 4. <strong>Multivariate extension</strong>: Model multiple correlated spatial processes simultaneously</p>
<p><strong>Applications</strong>: Spatial copulas are used in: - <strong>Environmental monitoring</strong>: Modeling precipitation, temperature, and pollution levels - <strong>Hydrology</strong>: Rainfall-runoff modeling and flood risk assessment - <strong>Geology</strong>: Mineral resource estimation and geological property mapping - <strong>Ecology</strong>: Species distribution and habitat modeling - <strong>Climate science</strong>: Regional climate model validation and downscaling</p>
<p>The following example demonstrates spatial copula analysis using synthetic environmental data, showing how to model spatial dependence while preserving realistic marginal distributions:</p>
<div id="cell-fig-spatial-copulas" class="cell" data-fig-height="12" data-fig-width="20" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SpatialCopulaAnalysis:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Spatial copula analysis for environmental data"""</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, coordinates, observations):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.coords <span class="op">=</span> coordinates</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.obs <span class="op">=</span> observations</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_locations <span class="op">=</span> <span class="bu">len</span>(coordinates)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_distance_matrix(<span class="va">self</span>):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Calculate pairwise distances between locations"""</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> scipy.spatial.distance <span class="im">import</span> pdist, squareform</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        distances <span class="op">=</span> pdist(<span class="va">self</span>.coords)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.distance_matrix <span class="op">=</span> squareform(distances)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit_spatial_copula(<span class="va">self</span>, copula_family<span class="op">=</span><span class="st">'gaussian'</span>, max_distance<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fit spatial copula model"""</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'distance_matrix'</span>):</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.calculate_distance_matrix()</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform observations to uniform margins</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.uniform_obs <span class="op">=</span> np.zeros_like(<span class="va">self</span>.obs)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.obs.shape[<span class="dv">1</span>]):</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            ranks <span class="op">=</span> stats.rankdata(<span class="va">self</span>.obs[:, i])</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.uniform_obs[:, i] <span class="op">=</span> ranks <span class="op">/</span> (<span class="bu">len</span>(ranks) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Estimate distance-based dependence</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_distance <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>            max_distance <span class="op">=</span> np.<span class="bu">max</span>(<span class="va">self</span>.distance_matrix) <span class="op">/</span> <span class="dv">3</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.distance_bins <span class="op">=</span> np.linspace(<span class="dv">0</span>, max_distance, <span class="dv">10</span>)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.empirical_dependence <span class="op">=</span> []</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.distance_bins) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>            d_min, d_max <span class="op">=</span> <span class="va">self</span>.distance_bins[i], <span class="va">self</span>.distance_bins[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Find pairs within distance range</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            mask <span class="op">=</span> (<span class="va">self</span>.distance_matrix <span class="op">&gt;=</span> d_min) <span class="op">&amp;</span> (<span class="va">self</span>.distance_matrix <span class="op">&lt;</span> d_max)</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>            pairs <span class="op">=</span> np.where(mask)</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(pairs[<span class="dv">0</span>]) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Calculate empirical copula dependence</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>                u1_pairs <span class="op">=</span> <span class="va">self</span>.uniform_obs[pairs[<span class="dv">0</span>], <span class="dv">0</span>]</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>                u2_pairs <span class="op">=</span> <span class="va">self</span>.uniform_obs[pairs[<span class="dv">1</span>], <span class="dv">0</span>]  <span class="co"># Assuming single variable for simplicity</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Kendall's tau</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>                tau <span class="op">=</span> stats.kendalltau(u1_pairs, u2_pairs)[<span class="dv">0</span>]</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.empirical_dependence.append(tau)</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.empirical_dependence.append(<span class="dv">0</span>)</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> simulate_spatial_field(<span class="va">self</span>, n_simulations<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate spatial random field using fitted copula"""</span></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simple spatial simulation using distance-based correlation</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">'distance_matrix'</span>):</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.calculate_distance_matrix()</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create correlation matrix based on distance</span></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>        correlation_matrix <span class="op">=</span> np.exp(<span class="op">-</span><span class="va">self</span>.distance_matrix <span class="op">/</span> <span class="dv">50</span>)  <span class="co"># Exponential decay</span></span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate from multivariate normal copula</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>        simulated_fields <span class="op">=</span> []</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>            normal_field <span class="op">=</span> np.random.multivariate_normal(</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a>                np.zeros(<span class="va">self</span>.n_locations), correlation_matrix</span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>            uniform_field <span class="op">=</span> stats.norm.cdf(normal_field)</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform back to original margins (approximate)</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>            original_field <span class="op">=</span> np.zeros_like(uniform_field)</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(uniform_field)):</span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>                original_field[i] <span class="op">=</span> np.percentile(<span class="va">self</span>.obs[:, <span class="dv">0</span>], uniform_field[i] <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a>            simulated_fields.append(original_field)</span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array(simulated_fields)</span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic spatial environmental data</span></span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a><span class="co"># Create spatial grid</span></span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a>x_coords <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">10</span>)</span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true" tabindex="-1"></a>y_coords <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">10</span>)</span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x_coords, y_coords)</span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true" tabindex="-1"></a>coordinates <span class="op">=</span> np.column_stack([X.flatten(), Y.flatten()])</span>
<span id="cb12-85"><a href="#cb12-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-86"><a href="#cb12-86" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate spatially correlated environmental data (e.g., precipitation, temperature)</span></span>
<span id="cb12-87"><a href="#cb12-87" aria-hidden="true" tabindex="-1"></a>n_locations <span class="op">=</span> <span class="bu">len</span>(coordinates)</span>
<span id="cb12-88"><a href="#cb12-88" aria-hidden="true" tabindex="-1"></a>n_variables <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Temperature and precipitation</span></span>
<span id="cb12-89"><a href="#cb12-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-90"><a href="#cb12-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Create spatial correlation based on distance</span></span>
<span id="cb12-91"><a href="#cb12-91" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial.distance <span class="im">import</span> pdist, squareform</span>
<span id="cb12-92"><a href="#cb12-92" aria-hidden="true" tabindex="-1"></a>distances <span class="op">=</span> squareform(pdist(coordinates))</span>
<span id="cb12-93"><a href="#cb12-93" aria-hidden="true" tabindex="-1"></a>spatial_corr <span class="op">=</span> np.exp(<span class="op">-</span>distances <span class="op">/</span> <span class="dv">30</span>)  <span class="co"># Exponential correlation</span></span>
<span id="cb12-94"><a href="#cb12-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-95"><a href="#cb12-95" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate base correlated data</span></span>
<span id="cb12-96"><a href="#cb12-96" aria-hidden="true" tabindex="-1"></a>base_data <span class="op">=</span> np.random.multivariate_normal(np.zeros(n_locations), spatial_corr, n_variables).T</span>
<span id="cb12-97"><a href="#cb12-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-98"><a href="#cb12-98" aria-hidden="true" tabindex="-1"></a><span class="co"># Transform to realistic environmental data</span></span>
<span id="cb12-99"><a href="#cb12-99" aria-hidden="true" tabindex="-1"></a>observations <span class="op">=</span> np.zeros((n_locations, n_variables))</span>
<span id="cb12-100"><a href="#cb12-100" aria-hidden="true" tabindex="-1"></a><span class="co"># Temperature: normal distribution with spatial trend</span></span>
<span id="cb12-101"><a href="#cb12-101" aria-hidden="true" tabindex="-1"></a>observations[:, <span class="dv">0</span>] <span class="op">=</span> base_data[:, <span class="dv">0</span>] <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">20</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> coordinates[:, <span class="dv">1</span>]  <span class="co"># Temperature increases with latitude</span></span>
<span id="cb12-102"><a href="#cb12-102" aria-hidden="true" tabindex="-1"></a><span class="co"># Precipitation: gamma distribution</span></span>
<span id="cb12-103"><a href="#cb12-103" aria-hidden="true" tabindex="-1"></a>observations[:, <span class="dv">1</span>] <span class="op">=</span> stats.gamma.ppf(stats.norm.cdf(base_data[:, <span class="dv">1</span>]), a<span class="op">=</span><span class="dv">2</span>, scale<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb12-104"><a href="#cb12-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-105"><a href="#cb12-105" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize spatial copula analysis</span></span>
<span id="cb12-106"><a href="#cb12-106" aria-hidden="true" tabindex="-1"></a>spatial_analyzer <span class="op">=</span> SpatialCopulaAnalysis(coordinates, observations)</span>
<span id="cb12-107"><a href="#cb12-107" aria-hidden="true" tabindex="-1"></a>spatial_analyzer.fit_spatial_copula()</span>
<span id="cb12-108"><a href="#cb12-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-109"><a href="#cb12-109" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">15</span>))</span>
<span id="cb12-110"><a href="#cb12-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-111"><a href="#cb12-111" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data visualization</span></span>
<span id="cb12-112"><a href="#cb12-112" aria-hidden="true" tabindex="-1"></a>scatter1 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>].scatter(coordinates[:, <span class="dv">0</span>], coordinates[:, <span class="dv">1</span>], </span>
<span id="cb12-113"><a href="#cb12-113" aria-hidden="true" tabindex="-1"></a>                             c<span class="op">=</span>observations[:, <span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'RdYlBu_r'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb12-114"><a href="#cb12-114" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Temperature Field'</span>)</span>
<span id="cb12-115"><a href="#cb12-115" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'X coordinate'</span>)</span>
<span id="cb12-116"><a href="#cb12-116" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Y coordinate'</span>)</span>
<span id="cb12-117"><a href="#cb12-117" aria-hidden="true" tabindex="-1"></a>plt.colorbar(scatter1, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb12-118"><a href="#cb12-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-119"><a href="#cb12-119" aria-hidden="true" tabindex="-1"></a>scatter2 <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">1</span>].scatter(coordinates[:, <span class="dv">0</span>], coordinates[:, <span class="dv">1</span>], </span>
<span id="cb12-120"><a href="#cb12-120" aria-hidden="true" tabindex="-1"></a>                             c<span class="op">=</span>observations[:, <span class="dv">1</span>], cmap<span class="op">=</span><span class="st">'Blues'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb12-121"><a href="#cb12-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Precipitation Field'</span>)</span>
<span id="cb12-122"><a href="#cb12-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X coordinate'</span>)</span>
<span id="cb12-123"><a href="#cb12-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Y coordinate'</span>)</span>
<span id="cb12-124"><a href="#cb12-124" aria-hidden="true" tabindex="-1"></a>plt.colorbar(scatter2, ax<span class="op">=</span>axes[<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb12-125"><a href="#cb12-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-126"><a href="#cb12-126" aria-hidden="true" tabindex="-1"></a><span class="co"># Scatter plot of variables</span></span>
<span id="cb12-127"><a href="#cb12-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].scatter(observations[:, <span class="dv">0</span>], observations[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb12-128"><a href="#cb12-128" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="st">'Temperature vs Precipitation'</span>)</span>
<span id="cb12-129"><a href="#cb12-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Temperature'</span>)</span>
<span id="cb12-130"><a href="#cb12-130" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'Precipitation'</span>)</span>
<span id="cb12-131"><a href="#cb12-131" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].grid(<span class="va">True</span>)</span>
<span id="cb12-132"><a href="#cb12-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-133"><a href="#cb12-133" aria-hidden="true" tabindex="-1"></a><span class="co"># Distance-dependence relationship</span></span>
<span id="cb12-134"><a href="#cb12-134" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">hasattr</span>(spatial_analyzer, <span class="st">'empirical_dependence'</span>):</span>
<span id="cb12-135"><a href="#cb12-135" aria-hidden="true" tabindex="-1"></a>    bin_centers <span class="op">=</span> (spatial_analyzer.distance_bins[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> spatial_analyzer.distance_bins[<span class="dv">1</span>:]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb12-136"><a href="#cb12-136" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">3</span>].plot(bin_centers, spatial_analyzer.empirical_dependence, <span class="st">'o-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-137"><a href="#cb12-137" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">3</span>].set_title(<span class="st">'Spatial Dependence Structure'</span>)</span>
<span id="cb12-138"><a href="#cb12-138" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">3</span>].set_xlabel(<span class="st">'Distance'</span>)</span>
<span id="cb12-139"><a href="#cb12-139" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">3</span>].set_ylabel(<span class="st">'Kendall</span><span class="ch">\'</span><span class="st">s τ'</span>)</span>
<span id="cb12-140"><a href="#cb12-140" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">3</span>].grid(<span class="va">True</span>)</span>
<span id="cb12-141"><a href="#cb12-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-142"><a href="#cb12-142" aria-hidden="true" tabindex="-1"></a><span class="co"># Uniform margins (copula data)</span></span>
<span id="cb12-143"><a href="#cb12-143" aria-hidden="true" tabindex="-1"></a>uniform_data <span class="op">=</span> spatial_analyzer.uniform_obs</span>
<span id="cb12-144"><a href="#cb12-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-145"><a href="#cb12-145" aria-hidden="true" tabindex="-1"></a>scatter3 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>].scatter(coordinates[:, <span class="dv">0</span>], coordinates[:, <span class="dv">1</span>], </span>
<span id="cb12-146"><a href="#cb12-146" aria-hidden="true" tabindex="-1"></a>                             c<span class="op">=</span>uniform_data[:, <span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb12-147"><a href="#cb12-147" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Temperature - Uniform Margins'</span>)</span>
<span id="cb12-148"><a href="#cb12-148" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'X coordinate'</span>)</span>
<span id="cb12-149"><a href="#cb12-149" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Y coordinate'</span>)</span>
<span id="cb12-150"><a href="#cb12-150" aria-hidden="true" tabindex="-1"></a>plt.colorbar(scatter3, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb12-151"><a href="#cb12-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-152"><a href="#cb12-152" aria-hidden="true" tabindex="-1"></a>scatter4 <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">1</span>].scatter(coordinates[:, <span class="dv">0</span>], coordinates[:, <span class="dv">1</span>], </span>
<span id="cb12-153"><a href="#cb12-153" aria-hidden="true" tabindex="-1"></a>                             c<span class="op">=</span>uniform_data[:, <span class="dv">1</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb12-154"><a href="#cb12-154" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Precipitation - Uniform Margins'</span>)</span>
<span id="cb12-155"><a href="#cb12-155" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X coordinate'</span>)</span>
<span id="cb12-156"><a href="#cb12-156" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Y coordinate'</span>)</span>
<span id="cb12-157"><a href="#cb12-157" aria-hidden="true" tabindex="-1"></a>plt.colorbar(scatter4, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb12-158"><a href="#cb12-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-159"><a href="#cb12-159" aria-hidden="true" tabindex="-1"></a><span class="co"># Copula scatter plot</span></span>
<span id="cb12-160"><a href="#cb12-160" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].scatter(uniform_data[:, <span class="dv">0</span>], uniform_data[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb12-161"><a href="#cb12-161" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'Copula Data (Uniform Margins)'</span>)</span>
<span id="cb12-162"><a href="#cb12-162" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'U₁ (Temperature)'</span>)</span>
<span id="cb12-163"><a href="#cb12-163" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'U₂ (Precipitation)'</span>)</span>
<span id="cb12-164"><a href="#cb12-164" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].grid(<span class="va">True</span>)</span>
<span id="cb12-165"><a href="#cb12-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-166"><a href="#cb12-166" aria-hidden="true" tabindex="-1"></a><span class="co"># Empirical copula density estimation</span></span>
<span id="cb12-167"><a href="#cb12-167" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb12-168"><a href="#cb12-168" aria-hidden="true" tabindex="-1"></a>kde <span class="op">=</span> gaussian_kde([uniform_data[:, <span class="dv">0</span>], uniform_data[:, <span class="dv">1</span>]])</span>
<span id="cb12-169"><a href="#cb12-169" aria-hidden="true" tabindex="-1"></a>u_grid <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">50</span>)</span>
<span id="cb12-170"><a href="#cb12-170" aria-hidden="true" tabindex="-1"></a>U1_grid, U2_grid <span class="op">=</span> np.meshgrid(u_grid, u_grid)</span>
<span id="cb12-171"><a href="#cb12-171" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> np.vstack([U1_grid.ravel(), U2_grid.ravel()])</span>
<span id="cb12-172"><a href="#cb12-172" aria-hidden="true" tabindex="-1"></a>copula_density <span class="op">=</span> kde(positions).reshape(U1_grid.shape)</span>
<span id="cb12-173"><a href="#cb12-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-174"><a href="#cb12-174" aria-hidden="true" tabindex="-1"></a>contour <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">3</span>].contourf(U1_grid, U2_grid, copula_density, levels<span class="op">=</span><span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb12-175"><a href="#cb12-175" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].set_title(<span class="st">'Empirical Copula Density'</span>)</span>
<span id="cb12-176"><a href="#cb12-176" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].set_xlabel(<span class="st">'U₁'</span>)</span>
<span id="cb12-177"><a href="#cb12-177" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].set_ylabel(<span class="st">'U₂'</span>)</span>
<span id="cb12-178"><a href="#cb12-178" aria-hidden="true" tabindex="-1"></a>plt.colorbar(contour, ax<span class="op">=</span>axes[<span class="dv">1</span>, <span class="dv">3</span>])</span>
<span id="cb12-179"><a href="#cb12-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-180"><a href="#cb12-180" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate spatial fields</span></span>
<span id="cb12-181"><a href="#cb12-181" aria-hidden="true" tabindex="-1"></a>simulated_fields <span class="op">=</span> spatial_analyzer.simulate_spatial_field(<span class="dv">100</span>)</span>
<span id="cb12-182"><a href="#cb12-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-183"><a href="#cb12-183" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot some simulated realizations</span></span>
<span id="cb12-184"><a href="#cb12-184" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb12-185"><a href="#cb12-185" aria-hidden="true" tabindex="-1"></a>    sim_field <span class="op">=</span> simulated_fields[i]</span>
<span id="cb12-186"><a href="#cb12-186" aria-hidden="true" tabindex="-1"></a>    scatter_sim <span class="op">=</span> axes[<span class="dv">2</span>, i].scatter(coordinates[:, <span class="dv">0</span>], coordinates[:, <span class="dv">1</span>], </span>
<span id="cb12-187"><a href="#cb12-187" aria-hidden="true" tabindex="-1"></a>                                    c<span class="op">=</span>sim_field, cmap<span class="op">=</span><span class="st">'RdYlBu_r'</span>, s<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb12-188"><a href="#cb12-188" aria-hidden="true" tabindex="-1"></a>                                    vmin<span class="op">=</span>observations[:, <span class="dv">0</span>].<span class="bu">min</span>(), </span>
<span id="cb12-189"><a href="#cb12-189" aria-hidden="true" tabindex="-1"></a>                                    vmax<span class="op">=</span>observations[:, <span class="dv">0</span>].<span class="bu">max</span>())</span>
<span id="cb12-190"><a href="#cb12-190" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i].set_title(<span class="ss">f'Simulated Field </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb12-191"><a href="#cb12-191" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i].set_xlabel(<span class="st">'X coordinate'</span>)</span>
<span id="cb12-192"><a href="#cb12-192" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, i].set_ylabel(<span class="st">'Y coordinate'</span>)</span>
<span id="cb12-193"><a href="#cb12-193" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(scatter_sim, ax<span class="op">=</span>axes[<span class="dv">2</span>, i])</span>
<span id="cb12-194"><a href="#cb12-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-195"><a href="#cb12-195" aria-hidden="true" tabindex="-1"></a><span class="co"># Validation: compare statistics</span></span>
<span id="cb12-196"><a href="#cb12-196" aria-hidden="true" tabindex="-1"></a>original_stats <span class="op">=</span> {</span>
<span id="cb12-197"><a href="#cb12-197" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Mean'</span>: np.mean(observations[:, <span class="dv">0</span>]),</span>
<span id="cb12-198"><a href="#cb12-198" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Std'</span>: np.std(observations[:, <span class="dv">0</span>]),</span>
<span id="cb12-199"><a href="#cb12-199" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Min'</span>: np.<span class="bu">min</span>(observations[:, <span class="dv">0</span>]),</span>
<span id="cb12-200"><a href="#cb12-200" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Max'</span>: np.<span class="bu">max</span>(observations[:, <span class="dv">0</span>])</span>
<span id="cb12-201"><a href="#cb12-201" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-202"><a href="#cb12-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-203"><a href="#cb12-203" aria-hidden="true" tabindex="-1"></a>simulated_stats <span class="op">=</span> {</span>
<span id="cb12-204"><a href="#cb12-204" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Mean'</span>: np.mean(simulated_fields),</span>
<span id="cb12-205"><a href="#cb12-205" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Std'</span>: np.std(simulated_fields),</span>
<span id="cb12-206"><a href="#cb12-206" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Min'</span>: np.<span class="bu">min</span>(simulated_fields),</span>
<span id="cb12-207"><a href="#cb12-207" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Max'</span>: np.<span class="bu">max</span>(simulated_fields)</span>
<span id="cb12-208"><a href="#cb12-208" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-209"><a href="#cb12-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-210"><a href="#cb12-210" aria-hidden="true" tabindex="-1"></a><span class="co"># Statistical comparison</span></span>
<span id="cb12-211"><a href="#cb12-211" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">3</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb12-212"><a href="#cb12-212" aria-hidden="true" tabindex="-1"></a>stats_text <span class="op">=</span> <span class="st">"Validation Statistics</span><span class="ch">\n\n</span><span class="st">"</span></span>
<span id="cb12-213"><a href="#cb12-213" aria-hidden="true" tabindex="-1"></a>stats_text <span class="op">+=</span> <span class="ss">f"</span><span class="sc">{</span><span class="st">'Statistic'</span><span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Original'</span><span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Simulated'</span><span class="sc">:&lt;10}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb12-214"><a href="#cb12-214" aria-hidden="true" tabindex="-1"></a>stats_text <span class="op">+=</span> <span class="st">"-"</span> <span class="op">*</span> <span class="dv">35</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb12-215"><a href="#cb12-215" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key <span class="kw">in</span> original_stats.keys():</span>
<span id="cb12-216"><a href="#cb12-216" aria-hidden="true" tabindex="-1"></a>    stats_text <span class="op">+=</span> <span class="ss">f"</span><span class="sc">{</span>key<span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span>original_stats[key]<span class="sc">:&lt;10.2f}</span><span class="ss"> </span><span class="sc">{</span>simulated_stats[key]<span class="sc">:&lt;10.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb12-217"><a href="#cb12-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-218"><a href="#cb12-218" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">3</span>].text(<span class="fl">0.1</span>, <span class="fl">0.9</span>, stats_text, transform<span class="op">=</span>axes[<span class="dv">2</span>, <span class="dv">3</span>].transAxes, </span>
<span id="cb12-219"><a href="#cb12-219" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">12</span>, fontfamily<span class="op">=</span><span class="st">'monospace'</span>, verticalalignment<span class="op">=</span><span class="st">'top'</span>)</span>
<span id="cb12-220"><a href="#cb12-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-221"><a href="#cb12-221" aria-hidden="true" tabindex="-1"></a><span class="co"># Add correlation analysis</span></span>
<span id="cb12-222"><a href="#cb12-222" aria-hidden="true" tabindex="-1"></a>original_spatial_corr <span class="op">=</span> np.corrcoef(observations[:, <span class="dv">0</span>].reshape(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb12-223"><a href="#cb12-223" aria-hidden="true" tabindex="-1"></a>mean_simulated_field <span class="op">=</span> np.mean(simulated_fields, axis<span class="op">=</span><span class="dv">0</span>).reshape(<span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb12-224"><a href="#cb12-224" aria-hidden="true" tabindex="-1"></a>simulated_spatial_corr <span class="op">=</span> np.corrcoef(mean_simulated_field)</span>
<span id="cb12-225"><a href="#cb12-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-226"><a href="#cb12-226" aria-hidden="true" tabindex="-1"></a>correlation_comparison <span class="op">=</span> <span class="ss">f"</span><span class="ch">\n</span><span class="ss">Spatial Correlation:</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb12-227"><a href="#cb12-227" aria-hidden="true" tabindex="-1"></a>correlation_comparison <span class="op">+=</span> <span class="ss">f"Original: </span><span class="sc">{</span>np<span class="sc">.</span>mean(original_spatial_corr[original_spatial_corr <span class="op">!=</span> <span class="dv">1</span>])<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb12-228"><a href="#cb12-228" aria-hidden="true" tabindex="-1"></a>correlation_comparison <span class="op">+=</span> <span class="ss">f"Simulated: </span><span class="sc">{</span>np<span class="sc">.</span>mean(simulated_spatial_corr[simulated_spatial_corr <span class="op">!=</span> <span class="dv">1</span>])<span class="sc">:.3f}</span><span class="ss">"</span></span>
<span id="cb12-229"><a href="#cb12-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-230"><a href="#cb12-230" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">3</span>].text(<span class="fl">0.1</span>, <span class="fl">0.4</span>, correlation_comparison, transform<span class="op">=</span>axes[<span class="dv">2</span>, <span class="dv">3</span>].transAxes, </span>
<span id="cb12-231"><a href="#cb12-231" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">12</span>, fontfamily<span class="op">=</span><span class="st">'monospace'</span>, verticalalignment<span class="op">=</span><span class="st">'top'</span>)</span>
<span id="cb12-232"><a href="#cb12-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-233"><a href="#cb12-233" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.98</span>, top<span class="op">=</span><span class="fl">0.95</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb12-234"><a href="#cb12-234" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-spatial-copulas" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spatial-copulas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-spatial-copulas-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spatial-copulas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Spatial data analysis using copulas: modeling dependence in environmental data
</figcaption>
</figure>
</div>
</div>
</div>
<p>These applications demonstrate the practical power of copulas in:</p>
<ol type="1">
<li><strong>Portfolio Risk Management</strong>:
<ul>
<li>Capturing realistic dependence between asset returns</li>
<li>Accurate VaR and Expected Shortfall estimation</li>
<li>Risk decomposition and attribution</li>
<li>Stress testing and scenario analysis</li>
</ul></li>
<li><strong>Spatial Data Analysis</strong>:
<ul>
<li>Modeling spatial dependence structures</li>
<li>Simulating realistic spatial fields</li>
<li>Preserving marginal distributions while capturing spatial correlation</li>
<li>Environmental monitoring and prediction</li>
</ul></li>
</ol>
<p>The copula framework enables practitioners to build sophisticated models that capture the complexity of real-world dependence patterns while maintaining mathematical rigor and computational tractability.</p>
</section>
</section>
<section id="sec-conclusion" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="sec-conclusion"><span class="header-section-number">8</span> Conclusion and Future Directions</h2>
<p>This comprehensive treatment of copula theory has taken us from the foundational mathematical framework established by Sklar’s theorem through advanced applications in finance and spatial statistics. The journey illustrates both the theoretical elegance and practical power of copulas in modern statistical modeling.</p>
<section id="key-insights-and-contributions" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="key-insights-and-contributions"><span class="header-section-number">8.1</span> Key Insights and Contributions</h3>
<p><strong>Theoretical Foundations</strong>: Sklar’s theorem provides the mathematical bedrock that justifies the separation of marginal distributions from dependence structure. This seemingly simple insight has profound implications, enabling the construction of flexible multivariate models that would be impossible using traditional approaches.</p>
<p><strong>Methodological Advances</strong>: The major copula families—Archimedean and elliptical—offer complementary tools for different modeling scenarios: - <strong>Archimedean copulas</strong> excel at capturing asymmetric dependence and provide analytical tractability through their generator functions - <strong>Elliptical copulas</strong> leverage familiar multivariate distributions and offer natural extensions of classical methods - <strong>Vine copulas</strong> (briefly mentioned) extend these concepts to high-dimensional settings through hierarchical constructions</p>
<p><strong>Practical Impact</strong>: The applications demonstrated here showcase copulas’ transformative effect on quantitative modeling: - In <strong>portfolio risk management</strong>, copulas enable more accurate tail risk assessment by capturing realistic dependence during market stress - In <strong>spatial statistics</strong>, they allow flexible modeling of environmental phenomena while preserving both marginal characteristics and spatial correlation patterns</p>
</section>
<section id="methodological-considerations" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="methodological-considerations"><span class="header-section-number">8.2</span> Methodological Considerations</h3>
<p><strong>Model Selection</strong>: Choosing appropriate copula families requires careful consideration of: - The nature of the dependence structure (symmetric vs.&nbsp;asymmetric, tail dependence properties) - Computational requirements and analytical tractability - Goodness-of-fit to observed data patterns - Robustness to model misspecification</p>
<p><strong>Estimation Challenges</strong>: Parameter estimation in copula models involves several considerations: - <strong>Two-stage methods</strong> (fit margins first, then copula) are computationally efficient but may not be fully efficient - <strong>Full maximum likelihood</strong> provides optimal statistical properties but can be computationally demanding - <strong>Rank-based methods</strong> offer robustness to marginal misspecification</p>
<p><strong>Validation and Diagnostics</strong>: Proper model validation is crucial and should include: - Graphical diagnostics (P-P plots, Q-Q plots, residual analysis) - Formal goodness-of-fit tests designed specifically for copulas - Out-of-sample validation and backtesting for risk management applications</p>
</section>
<section id="future-research-directions" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="future-research-directions"><span class="header-section-number">8.3</span> Future Research Directions</h3>
<p><strong>High-Dimensional Extensions</strong>: While vine copulas provide one approach to high-dimensional modeling, developing more efficient methods for truly high-dimensional applications remains an active area of research. Factor copula models and sparse representations offer promising directions.</p>
<p><strong>Dynamic and Time-Varying Copulas</strong>: Many applications require modeling dependence structures that evolve over time. Dynamic copula models, regime-switching approaches, and non-parametric time-varying methods represent important research frontiers.</p>
<p><strong>Machine Learning Integration</strong>: The intersection of copula theory with machine learning offers exciting possibilities, including: - Neural network-based copula approximations - Deep generative models informed by copula structure - Automated copula selection using machine learning techniques</p>
<p><strong>Computational Advances</strong>: As data sizes grow and models become more complex, computational efficiency becomes increasingly important. Research into: - Fast simulation algorithms - Approximate inference methods - Parallel and distributed computing approaches - GPU acceleration of copula computations</p>
</section>
<section id="final-thoughts" class="level3" data-number="8.4">
<h3 data-number="8.4" class="anchored" data-anchor-id="final-thoughts"><span class="header-section-number">8.4</span> Final Thoughts</h3>
<p>Copulas represent a mature theoretical framework that continues to find new applications and inspire methodological innovations. Their success stems from addressing a fundamental challenge in multivariate modeling: how to flexibly capture dependence while allowing for realistic marginal behavior.</p>
<p>For practitioners, copulas offer a principled approach to building models that can capture the complexity observed in real data. For theorists, they provide a rich mathematical structure that continues to yield new insights and extensions.</p>
<p>As we move forward, the integration of copula theory with emerging computational methods and new application domains promises to further expand their impact across statistics, economics, environmental science, and beyond. The framework established by Sklar more than six decades ago continues to provide the foundation for understanding and modeling the intricate web of dependencies that characterize our complex world.</p>
<p>The Python implementations provided throughout this primer offer a starting point for readers to explore these concepts further and adapt them to their own applications. The mathematical rigor combined with practical implementations demonstrates that copulas are not merely theoretical constructs but powerful tools for solving real-world problems.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-aas2009" class="csl-entry" role="listitem">
Aas, Kjersti, Claudia Czado, Arnoldo Frigessi, and Henrik Bakken. 2009. <span>“Pair-Copula Constructions of Multiple Dependence.”</span> <em>Insurance: Mathematics and Economics</em> 44 (2): 182–98.
</div>
<div id="ref-bedford2002" class="csl-entry" role="listitem">
Bedford, Tim, and Roger M Cooke. 2002. <span>“Vines–a New Graphical Model for Dependent Random Variables.”</span> <em>The Annals of Statistics</em> 30 (4): 1031–68.
</div>
<div id="ref-clayton1978" class="csl-entry" role="listitem">
Clayton, David G. 1978. <span>“A Model for Association in Bivariate Life Tables and Its Application in Epidemiological Studies of Familial Tendency in Chronic Disease Incidence.”</span> <em>Biometrika</em> 65 (1): 141–51.
</div>
<div id="ref-durante2015" class="csl-entry" role="listitem">
Durante, Fabrizio, and Carlo Sempi. 2015. <em>Principles of Copula Theory</em>. CRC press.
</div>
<div id="ref-embrechts2002" class="csl-entry" role="listitem">
Embrechts, Paul, Alexander McNeil, and Daniel Straumann. 2002. <span>“Correlation and Dependence in Risk Management: Properties and Pitfalls.”</span> <em>Risk Management: Value at Risk and Beyond</em>, 176–223.
</div>
<div id="ref-frank1979" class="csl-entry" role="listitem">
Frank, Maurice J. 1979. <span>“On the Simultaneous Associativity of f(x,y) and x+y-f(x,y).”</span> <em>Aequationes Mathematicae</em> 19 (1): 194–226.
</div>
<div id="ref-genest1995" class="csl-entry" role="listitem">
Genest, Christian, Bruno Rémillard, and David Beaudoin. 2009. <span>“Goodness-of-Fit Tests for Copulas: A Review and a Power Study.”</span> <em>Insurance: Mathematics and Economics</em> 44 (2): 199–213.
</div>
<div id="ref-gumbel1960" class="csl-entry" role="listitem">
Gumbel, Emil J. 1960. <span>“Bivariate Exponential Distributions.”</span> <em>Journal of the American Statistical Association</em> 55 (292): 698–707.
</div>
<div id="ref-joe1997" class="csl-entry" role="listitem">
Joe, Harry. 1997. <em>Multivariate Models and Dependence Concepts</em>. Vol. 73. Chapman; Hall/CRC.
</div>
<div id="ref-mcneil2015quantitative" class="csl-entry" role="listitem">
McNeil, Alexander J, Rüdiger Frey, and Paul Embrechts. 2015. <em>Quantitative Risk Management: Concepts, Techniques and Tools</em>. Princeton university press.
</div>
<div id="ref-nelsen2006" class="csl-entry" role="listitem">
Nelsen, Roger B. 2006. <em>An Introduction to Copulas</em>. Vol. 139. Springer.
</div>
<div id="ref-patton2006" class="csl-entry" role="listitem">
Patton, Andrew J. 2006. <span>“Modelling Asymmetric Exchange Rate Dependence.”</span> <em>International Economic Review</em> 47 (2): 527–56.
</div>
<div id="ref-sklar1959" class="csl-entry" role="listitem">
Sklar, Abe. 1959. <span>“Fonctions de r<span>é</span>partition <span class="nocase">à</span> n Dimensions Et Leurs Marges.”</span> <em>Publications de l’Institut de Statistique de l’Universit<span>é</span> de Paris</em> 8: 229–31.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>