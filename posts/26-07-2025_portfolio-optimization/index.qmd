---
title: "A Guide to Portfolio Optimization"
abstract: "This post provides a practical introduction to portfolio optimization, focusing on the foundational Mean-Variance framework by Harry Markowitz. We'll explore the concepts of risk, return, the efficient frontier, and show how to implement it in Python."
categories:
  - Finance
  - Python
  - Optimization
author: "Jan Schlegel"
date: "2025-07-26"
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 3
number-sections: true
fig-width: 10
fig-height: 7
fig-dpi: 150
jupyter: python3
---

![Portfolio optimization combines mathematical rigor with practical financial applications](img/portfolio_optimization_thumbnail.png)

```python
#| echo: false
#| warning: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf
from scipy.optimize import minimize
import warnings
warnings.filterwarnings('ignore')

plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("husl")
plt.rcParams['figure.dpi'] = 150
```

## What is Portfolio Optimization?

Portfolio optimization is the process of selecting the best portfolio (asset distribution), out of the set of all possible portfolios, according to some objective. The objective typically maximizes factors such as expected return, and minimizes costs like financial risk.

The idea was pioneered by Harry Markowitz in 1952, who laid the foundation for Modern Portfolio Theory (MPT). The core idea of MPT is that you can construct a portfolio of multiple assets that will have less risk than any single asset on its own. This is the power of diversification.

## The Basics: Risk and Return

When we talk about portfolio optimization, we are always trying to balance two things: **return** and **risk**.

*   **Return** is the profit you make from your investments. We usually look at the *expected return*, which is a weighted average of the expected returns of the individual assets in the portfolio.
*   **Risk** is the uncertainty of the returns. The most common measure of risk is the **volatility**, which is the standard deviation of the returns.

A good portfolio is one that gives you the highest possible return for a given level of risk.

## Markowitz Mean-Variance Optimization

The classic approach to portfolio optimization is the **Mean-Variance framework**. It's a mathematical way to find the optimal portfolio by analyzing the trade-off between the mean (expected return) and the variance (risk) of a portfolio.

### The Efficient Frontier

Imagine you have a bunch of stocks. You can create an infinite number of portfolios by combining them in different proportions. Each of these portfolios will have its own expected return and volatility.

If you plot all these possible portfolios on a chart with risk on the x-axis and return on the y-axis, you will get a region of points. The **efficient frontier** is the edge of this region that represents the set of portfolios with the highest expected return for a given level of risk.

No rational investor would choose a portfolio that is not on the efficient frontier, because there is always a portfolio on the frontier that offers a better return for the same or lower risk.

### The Tangency Portfolio

To find the single "best" portfolio on the efficient frontier, we need to introduce the concept of a **risk-free asset** (like a government bond). The **tangency portfolio**, also known as the **maximum Sharpe ratio portfolio**, is the portfolio on the efficient frontier that gives the highest Sharpe ratio.

The **Sharpe ratio** is a measure of risk-adjusted return. It's calculated as:

$$ 	ext{Sharpe Ratio} = rac{	ext{Portfolio Return} - 	ext{Risk-Free Rate}}{	ext{Portfolio Volatility}} $$ 

The tangency portfolio is "optimal" because it provides the best return per unit of risk. An investor can then combine this portfolio with the risk-free asset to achieve their desired level of risk.

## A Python Implementation

Let's see how this works in practice. We'll use Python to download some stock data and find the efficient frontier and the tangency portfolio.

First, let's get some data for a few tech stocks.

```python
# Define our portfolio universe
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'TSLA']
start_date = '2020-01-01'
end_date = '2024-07-01'

# Download price data
data = yf.download(tickers, start=start_date, end=end_date)['Adj Close']

# Calculate daily returns
returns = data.pct_change().dropna()

# Annualized mean returns and covariance matrix
mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252
```

Now we have the returns data. Let's define some functions to calculate the portfolio performance and find the optimal portfolios.

```python
def portfolio_performance(weights, mean_returns, cov_matrix):
    returns = np.sum(mean_returns * weights) * 252
    std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)
    return returns, std

def neg_sharpe_ratio(weights, mean_returns, cov_matrix, risk_free_rate=0.02):
    p_returns, p_std = portfolio_performance(weights, mean_returns, cov_matrix)
    return -(p_returns - risk_free_rate) / p_std

def max_sharpe_ratio(mean_returns, cov_matrix, risk_free_rate=0.02):
    num_assets = len(mean_returns)
    args = (mean_returns, cov_matrix, risk_free_rate)
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bound = (0.0, 1.0)
    bounds = tuple(bound for asset in range(num_assets))
    result = minimize(neg_sharpe_ratio, num_assets* [1./num_assets,], args=args,
                        method='SLSQP', bounds=bounds, constraints=constraints)
    return result

def portfolio_volatility(weights, mean_returns, cov_matrix):
    return portfolio_performance(weights, mean_returns, cov_matrix)[1]

def min_variance(mean_returns, cov_matrix):
    num_assets = len(mean_returns)
    args = (mean_returns, cov_matrix)
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bound = (0.0, 1.0)
    bounds = tuple(bound for asset in range(num_assets))
    result = minimize(portfolio_volatility, num_assets* [1./num_assets,], args=args,
                        method='SLSQP', bounds=bounds, constraints=constraints)
    return result
```

Now we can find the efficient frontier by simulating many random portfolios and also by optimizing for the minimum variance for a range of target returns.

```python
#| label: fig-efficient-frontier
#| fig-cap: "Mean-variance efficient frontier with the tangency portfolio."
#| fig-width: 10
#| fig-height: 8

# Find the tangency portfolio (maximum Sharpe ratio)
max_sharpe = max_sharpe_ratio(returns.mean(), returns.cov())
max_sharpe_weights = max_sharpe['x']
max_sharpe_ret, max_sharpe_std = portfolio_performance(max_sharpe_weights, returns.mean(), returns.cov())

# Find the minimum variance portfolio
min_var = min_variance(returns.mean(), returns.cov())
min_var_weights = min_var['x']
min_var_ret, min_var_std = portfolio_performance(min_var_weights, returns.mean(), returns.cov())


# Simulate random portfolios
n_portfolios = 30000
results = np.zeros((3, n_portfolios))
weights_record = []
for i in range(n_portfolios):
    weights = np.random.random(len(tickers))
    weights /= np.sum(weights)
    weights_record.append(weights)
    portfolio_return = np.sum(returns.mean() * weights) * 252
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))
    results[0,i] = portfolio_return
    results[1,i] = portfolio_std_dev
    results[2,i] = (portfolio_return - 0.02) / portfolio_std_dev

plt.figure(figsize=(10, 8))
plt.scatter(results[1,:], results[0,:], c=results[2,:], cmap='viridis', marker='o', s=10, alpha=0.3)
plt.colorbar(label='Sharpe Ratio')

# Plot tangency and min variance portfolios
plt.scatter(max_sharpe_std, max_sharpe_ret, marker='*', color='r', s=200, label='Maximum Sharpe ratio')
plt.scatter(min_var_std, min_var_ret, marker='*', color='g', s=200, label='Minimum variance')

# Plot individual assets
for i, txt in enumerate(tickers):
    plt.scatter(np.sqrt(cov_matrix.iloc[i,i]), mean_returns[i], label=txt, s=50)

plt.title('Efficient Frontier')
plt.xlabel('Volatility')
plt.ylabel('Expected Return')
plt.legend()
plt.grid(True)
plt.show()
```

The plot above shows the efficient frontier. The colored points are thousands of randomly generated portfolios. The red star is the tangency portfolio (the one with the highest Sharpe ratio), and the green star is the global minimum variance portfolio. The individual stocks are also plotted. As you can see, you can get a better risk-return trade-off by diversifying.

## Beyond Mean-Variance

The Mean-Variance framework is a great starting point, but it has its limitations. It assumes that returns are normally distributed and that variance is a good measure of risk. In reality, financial returns often have "fat tails," meaning that extreme events are more common than a normal distribution would suggest.

To address these issues, more advanced methods have been developed:

*   **CVaR Optimization:** Instead of minimizing variance, this method minimizes Conditional Value-at-Risk (CVaR), which is the expected loss in the worst-case scenarios. This is better at capturing tail risk.
*   **Genetic Algorithms:** These are optimization techniques inspired by natural evolution. They can be used to solve very complex portfolio optimization problems with many constraints.

These methods are more complex, but they can provide a more robust and realistic approach to portfolio optimization.

## Conclusion

Portfolio optimization is a fundamental concept in finance that helps investors make informed decisions about how to allocate their capital. The Mean-Variance framework developed by Markowitz provides a solid foundation for understanding the trade-off between risk and return. While more advanced methods exist, the principles of diversification and the efficient frontier remain as relevant as ever.
