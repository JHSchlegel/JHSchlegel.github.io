<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jan Schlegel">
<meta name="dcterms.date" content="2025-04-03">

<title>Jan Schlegel – Stochastic Differential Equations: From Mathematical Foundations to Modern Applications</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="color-scheme" content="dark light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jan Schlegel</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jan-heinrich-schlegel/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JHSchlegel"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Stochastic Differential Equations: From Mathematical Foundations to Modern Applications</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Mathematics</div>
                <div class="quarto-category">Finance</div>
                <div class="quarto-category">Machine Learning</div>
                <div class="quarto-category">Python</div>
                <div class="quarto-category">Stochastic Processes</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jan Schlegel </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 3, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">Abstract</div>
      This comprehensive treatment of stochastic differential equation theory covers fundamental concepts from Brownian motion and Itô calculus to advanced applications in mathematical finance, neural processes, and diffusion models. We provide rigorous mathematical foundations, numerical solution methods, and extensive Python implementations with publication-ready visualizations, bridging classical stochastic analysis with cutting-edge machine learning applications.
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-introduction" id="toc-sec-introduction" class="nav-link active" data-scroll-target="#sec-introduction"><span class="header-section-number">1</span> Introduction</a>
  <ul>
  <li><a href="#historical-development-and-motivation" id="toc-historical-development-and-motivation" class="nav-link" data-scroll-target="#historical-development-and-motivation"><span class="header-section-number">1.1</span> Historical Development and Motivation</a></li>
  <li><a href="#contemporary-relevance-and-applications" id="toc-contemporary-relevance-and-applications" class="nav-link" data-scroll-target="#contemporary-relevance-and-applications"><span class="header-section-number">1.2</span> Contemporary Relevance and Applications</a></li>
  <li><a href="#scope-and-mathematical-prerequisites" id="toc-scope-and-mathematical-prerequisites" class="nav-link" data-scroll-target="#scope-and-mathematical-prerequisites"><span class="header-section-number">1.3</span> Scope and Mathematical Prerequisites</a></li>
  </ul></li>
  <li><a href="#sec-foundations" id="toc-sec-foundations" class="nav-link" data-scroll-target="#sec-foundations"><span class="header-section-number">2</span> Mathematical Foundations</a>
  <ul>
  <li><a href="#probability-spaces-and-filtrations" id="toc-probability-spaces-and-filtrations" class="nav-link" data-scroll-target="#probability-spaces-and-filtrations"><span class="header-section-number">2.1</span> Probability Spaces and Filtrations</a></li>
  <li><a href="#brownian-motion-and-the-wiener-process" id="toc-brownian-motion-and-the-wiener-process" class="nav-link" data-scroll-target="#brownian-motion-and-the-wiener-process"><span class="header-section-number">2.2</span> Brownian Motion and the Wiener Process</a></li>
  <li><a href="#multi-dimensional-brownian-motion" id="toc-multi-dimensional-brownian-motion" class="nav-link" data-scroll-target="#multi-dimensional-brownian-motion"><span class="header-section-number">2.3</span> Multi-dimensional Brownian Motion</a></li>
  <li><a href="#martingales-and-stopping-times" id="toc-martingales-and-stopping-times" class="nav-link" data-scroll-target="#martingales-and-stopping-times"><span class="header-section-number">2.4</span> Martingales and Stopping Times</a></li>
  </ul></li>
  <li><a href="#sec-ito-calculus" id="toc-sec-ito-calculus" class="nav-link" data-scroll-target="#sec-ito-calculus"><span class="header-section-number">3</span> Itô Calculus and Stochastic Integration</a>
  <ul>
  <li><a href="#the-need-for-stochastic-calculus" id="toc-the-need-for-stochastic-calculus" class="nav-link" data-scroll-target="#the-need-for-stochastic-calculus"><span class="header-section-number">3.1</span> The Need for Stochastic Calculus</a></li>
  <li><a href="#construction-of-the-itô-integral" id="toc-construction-of-the-itô-integral" class="nav-link" data-scroll-target="#construction-of-the-itô-integral"><span class="header-section-number">3.2</span> Construction of the Itô Integral</a></li>
  <li><a href="#itôs-lemma-the-fundamental-theorem" id="toc-itôs-lemma-the-fundamental-theorem" class="nav-link" data-scroll-target="#itôs-lemma-the-fundamental-theorem"><span class="header-section-number">3.3</span> Itô’s Lemma: The Fundamental Theorem</a></li>
  <li><a href="#multi-dimensional-itôs-lemma" id="toc-multi-dimensional-itôs-lemma" class="nav-link" data-scroll-target="#multi-dimensional-itôs-lemma"><span class="header-section-number">3.4</span> Multi-dimensional Itô’s Lemma</a></li>
  <li><a href="#applications-of-itôs-lemma" id="toc-applications-of-itôs-lemma" class="nav-link" data-scroll-target="#applications-of-itôs-lemma"><span class="header-section-number">3.5</span> Applications of Itô’s Lemma</a></li>
  </ul></li>
  <li><a href="#sec-sde-theory" id="toc-sec-sde-theory" class="nav-link" data-scroll-target="#sec-sde-theory"><span class="header-section-number">4</span> Stochastic Differential Equations: Theory and Existence</a>
  <ul>
  <li><a href="#mathematical-definition-and-classification" id="toc-mathematical-definition-and-classification" class="nav-link" data-scroll-target="#mathematical-definition-and-classification"><span class="header-section-number">4.1</span> Mathematical Definition and Classification</a></li>
  <li><a href="#existence-and-uniqueness-theory" id="toc-existence-and-uniqueness-theory" class="nav-link" data-scroll-target="#existence-and-uniqueness-theory"><span class="header-section-number">4.2</span> Existence and Uniqueness Theory</a></li>
  <li><a href="#the-markov-property-and-generator" id="toc-the-markov-property-and-generator" class="nav-link" data-scroll-target="#the-markov-property-and-generator"><span class="header-section-number">4.3</span> The Markov Property and Generator</a></li>
  <li><a href="#feynman-kac-theorem" id="toc-feynman-kac-theorem" class="nav-link" data-scroll-target="#feynman-kac-theorem"><span class="header-section-number">4.4</span> Feynman-Kac Theorem</a></li>
  </ul></li>
  <li><a href="#sec-numerical-methods" id="toc-sec-numerical-methods" class="nav-link" data-scroll-target="#sec-numerical-methods"><span class="header-section-number">5</span> Numerical Methods for SDEs</a>
  <ul>
  <li><a href="#euler-maruyama-scheme" id="toc-euler-maruyama-scheme" class="nav-link" data-scroll-target="#euler-maruyama-scheme"><span class="header-section-number">5.1</span> Euler-Maruyama Scheme</a></li>
  <li><a href="#milstein-scheme" id="toc-milstein-scheme" class="nav-link" data-scroll-target="#milstein-scheme"><span class="header-section-number">5.2</span> Milstein Scheme</a></li>
  <li><a href="#higher-order-methods-and-multi-dimensional-extensions" id="toc-higher-order-methods-and-multi-dimensional-extensions" class="nav-link" data-scroll-target="#higher-order-methods-and-multi-dimensional-extensions"><span class="header-section-number">5.3</span> Higher-Order Methods and Multi-dimensional Extensions</a></li>
  <li><a href="#weak-vs-strong-convergence" id="toc-weak-vs-strong-convergence" class="nav-link" data-scroll-target="#weak-vs-strong-convergence"><span class="header-section-number">5.4</span> Weak vs Strong Convergence</a></li>
  </ul></li>
  <li><a href="#sec-finance-applications" id="toc-sec-finance-applications" class="nav-link" data-scroll-target="#sec-finance-applications"><span class="header-section-number">6</span> Applications in Mathematical Finance</a>
  <ul>
  <li><a href="#the-black-scholes-model" id="toc-the-black-scholes-model" class="nav-link" data-scroll-target="#the-black-scholes-model"><span class="header-section-number">6.1</span> The Black-Scholes Model</a></li>
  <li><a href="#interest-rate-models" id="toc-interest-rate-models" class="nav-link" data-scroll-target="#interest-rate-models"><span class="header-section-number">6.2</span> Interest Rate Models</a>
  <ul class="collapse">
  <li><a href="#vasicek-model" id="toc-vasicek-model" class="nav-link" data-scroll-target="#vasicek-model"><span class="header-section-number">6.2.1</span> Vasicek Model</a></li>
  <li><a href="#cox-ingersoll-ross-cir-model" id="toc-cox-ingersoll-ross-cir-model" class="nav-link" data-scroll-target="#cox-ingersoll-ross-cir-model"><span class="header-section-number">6.2.2</span> Cox-Ingersoll-Ross (CIR) Model</a></li>
  </ul></li>
  <li><a href="#stochastic-volatility-models" id="toc-stochastic-volatility-models" class="nav-link" data-scroll-target="#stochastic-volatility-models"><span class="header-section-number">6.3</span> Stochastic Volatility Models</a>
  <ul class="collapse">
  <li><a href="#heston-model" id="toc-heston-model" class="nav-link" data-scroll-target="#heston-model"><span class="header-section-number">6.3.1</span> Heston Model</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-ml-applications" id="toc-sec-ml-applications" class="nav-link" data-scroll-target="#sec-ml-applications"><span class="header-section-number">7</span> SDEs in Modern Machine Learning</a>
  <ul>
  <li><a href="#neural-ordinary-differential-equations-nodes" id="toc-neural-ordinary-differential-equations-nodes" class="nav-link" data-scroll-target="#neural-ordinary-differential-equations-nodes"><span class="header-section-number">7.1</span> Neural Ordinary Differential Equations (NODEs)</a></li>
  <li><a href="#neural-stochastic-differential-equations" id="toc-neural-stochastic-differential-equations" class="nav-link" data-scroll-target="#neural-stochastic-differential-equations"><span class="header-section-number">7.2</span> Neural Stochastic Differential Equations</a></li>
  <li><a href="#gaussian-processes-and-sdes" id="toc-gaussian-processes-and-sdes" class="nav-link" data-scroll-target="#gaussian-processes-and-sdes"><span class="header-section-number">7.3</span> Gaussian Processes and SDEs</a></li>
  <li><a href="#neural-processes-bridging-gps-and-neural-networks" id="toc-neural-processes-bridging-gps-and-neural-networks" class="nav-link" data-scroll-target="#neural-processes-bridging-gps-and-neural-networks"><span class="header-section-number">7.4</span> Neural Processes: Bridging GPs and Neural Networks</a></li>
  <li><a href="#diffusion-models-sdes-for-generative-ai" id="toc-diffusion-models-sdes-for-generative-ai" class="nav-link" data-scroll-target="#diffusion-models-sdes-for-generative-ai"><span class="header-section-number">7.5</span> Diffusion Models: SDEs for Generative AI</a></li>
  <li><a href="#stochastic-neural-differential-equations" id="toc-stochastic-neural-differential-equations" class="nav-link" data-scroll-target="#stochastic-neural-differential-equations"><span class="header-section-number">7.6</span> Stochastic Neural Differential Equations</a>
  <ul class="collapse">
  <li><a href="#implementation-example-simple-neural-sde-in-pytorch" id="toc-implementation-example-simple-neural-sde-in-pytorch" class="nav-link" data-scroll-target="#implementation-example-simple-neural-sde-in-pytorch"><span class="header-section-number">7.6.1</span> Implementation Example: Simple Neural SDE in PyTorch</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-conclusion" id="toc-sec-conclusion" class="nav-link" data-scroll-target="#sec-conclusion"><span class="header-section-number">8</span> Conclusion and Future Directions</a>
  <ul>
  <li><a href="#key-contributions-and-insights" id="toc-key-contributions-and-insights" class="nav-link" data-scroll-target="#key-contributions-and-insights"><span class="header-section-number">8.1</span> Key Contributions and Insights</a></li>
  <li><a href="#future-research-directions" id="toc-future-research-directions" class="nav-link" data-scroll-target="#future-research-directions"><span class="header-section-number">8.2</span> Future Research Directions</a></li>
  <li><a href="#final-reflections" id="toc-final-reflections" class="nav-link" data-scroll-target="#final-reflections"><span class="header-section-number">8.3</span> Final Reflections</a></li>
  </ul></li>
  <li><a href="#sec-references" id="toc-sec-references" class="nav-link" data-scroll-target="#sec-references"><span class="header-section-number">9</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/sde_thumbnail.png" class="img-fluid figure-img"></p>
<figcaption>Stochastic differential equations provide the mathematical framework for modeling continuous-time random processes, with applications spanning from option pricing to generative AI models</figcaption>
</figure>
</div>
<section id="sec-introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>Stochastic differential equations (SDEs) represent one of the most profound and mathematically elegant frameworks in modern probability theory and applied mathematics. These equations describe the evolution of random processes in continuous time, providing the mathematical foundation for modeling phenomena characterized by both deterministic trends and random fluctuations <span class="citation" data-cites="oksendal2003 karatzas1991">(<a href="#ref-oksendal2003" role="doc-biblioref">Øksendal 2003</a>; <a href="#ref-karatzas1991" role="doc-biblioref">Karatzas and Shreve 1991</a>)</span>.</p>
<p>The theoretical development of SDE theory emerged from the intersection of probability theory, differential equations, and mathematical finance, culminating in the revolutionary work of Kiyoshi Itô in the 1940s. Itô’s groundbreaking construction of stochastic integration transformed our understanding of random processes and established the mathematical framework that now underpins modern quantitative finance, statistical physics, and machine learning <span class="citation" data-cites="ito1951 mckean1969">(<a href="#ref-ito1951" role="doc-biblioref">Itô 1951</a>; <a href="#ref-mckean1969" role="doc-biblioref">McKean 1969</a>)</span>.</p>
<section id="historical-development-and-motivation" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="historical-development-and-motivation"><span class="header-section-number">1.1</span> Historical Development and Motivation</h3>
<p>The genesis of stochastic differential equations can be traced to Louis Bachelier’s pioneering 1900 thesis on option pricing, where he first applied Brownian motion to financial markets <span class="citation" data-cites="bachelier1900">(<a href="#ref-bachelier1900" role="doc-biblioref">Bachelier 1900</a>)</span>. However, it was not until Norbert Wiener’s rigorous mathematical construction of Brownian motion in the 1920s that the field gained its theoretical foundation <span class="citation" data-cites="wiener1923">(<a href="#ref-wiener1923" role="doc-biblioref">Wiener 1923</a>)</span>.</p>
<p>The transformative breakthrough came with Itô’s development of stochastic calculus in the 1940s and 1950s. Itô recognized that classical calculus was inadequate for handling functions of Brownian motion due to their non-differentiable nature, leading to his construction of stochastic integration and the famous Itô’s lemma <span class="citation" data-cites="ito1951">(<a href="#ref-ito1951" role="doc-biblioref">Itô 1951</a>)</span>. This work established the mathematical machinery necessary for:</p>
<ul>
<li><strong>Rigorous treatment of random processes</strong>: Moving beyond heuristic arguments to mathematically precise formulations</li>
<li><strong>Financial modeling</strong>: Providing the foundation for modern option pricing theory through the Black-Scholes model</li>
<li><strong>Engineering applications</strong>: Enabling analysis of systems subject to random disturbances</li>
<li><strong>Machine learning</strong>: Supporting modern developments in neural differential equations and diffusion models</li>
</ul>
</section>
<section id="contemporary-relevance-and-applications" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="contemporary-relevance-and-applications"><span class="header-section-number">1.2</span> Contemporary Relevance and Applications</h3>
<p>In the 21st century, SDEs have experienced a renaissance driven by advances in computational methods and emerging applications in machine learning. Key contemporary developments include:</p>
<p><strong>Mathematical Finance</strong>: SDEs form the backbone of modern derivatives pricing, risk management, and portfolio optimization. Models like the Heston stochastic volatility model and interest rate models (Vasicek, Cox-Ingersoll-Ross) are built on SDE foundations <span class="citation" data-cites="heston1993 cox1985">(<a href="#ref-heston1993" role="doc-biblioref">Heston 1993</a>; <a href="#ref-cox1985" role="doc-biblioref">Cox, Ingersoll Jr, and Ross 1985</a>)</span>.</p>
<p><strong>Machine Learning and AI</strong>: Recent breakthroughs in generative modeling, particularly diffusion models for image generation, rely heavily on SDE theory. Neural ordinary differential equations (NODEs) and neural SDEs represent cutting-edge applications of stochastic analysis to deep learning <span class="citation" data-cites="chen2018 song2021">(<a href="#ref-chen2018" role="doc-biblioref">Chen et al. 2018</a>; <a href="#ref-song2021" role="doc-biblioref">Song et al. 2021</a>)</span>.</p>
<p><strong>Scientific Computing</strong>: SDEs provide essential tools for modeling complex systems in physics, biology, and engineering where random effects play a crucial role <span class="citation" data-cites="gardiner2009">(<a href="#ref-gardiner2009" role="doc-biblioref">Gardiner 2009</a>)</span>.</p>
</section>
<section id="scope-and-mathematical-prerequisites" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="scope-and-mathematical-prerequisites"><span class="header-section-number">1.3</span> Scope and Mathematical Prerequisites</h3>
<p>This treatise provides a comprehensive, PhD-level treatment of stochastic differential equation theory and applications. We assume familiarity with:</p>
<ul>
<li><strong>Real analysis</strong>: Measure theory, Lebesgue integration, and functional analysis</li>
<li><strong>Probability theory</strong>: Probability spaces, random variables, and basic stochastic processes</li>
<li><strong>Differential equations</strong>: Ordinary differential equations and partial differential equations</li>
<li><strong>Linear algebra</strong>: Matrix theory and spectral analysis</li>
</ul>
<p>Our systematic development progresses through:</p>
<p><strong>Theoretical Foundations</strong> (Sections 2-4): We establish the mathematical framework, beginning with Brownian motion and filtrations, developing Itô calculus, and proving fundamental existence and uniqueness theorems.</p>
<p><strong>Numerical Methods</strong> (Section 5): We examine computational approaches including Euler-Maruyama and Milstein schemes, analyzing convergence properties and implementation considerations.</p>
<p><strong>Financial Applications</strong> (Section 6): We explore classical applications in option pricing, interest rate modeling, and risk management, providing complete derivations and implementations.</p>
<p><strong>Modern Machine Learning Applications</strong> (Sections 7-8): We investigate contemporary applications in neural differential equations, diffusion models, and Gaussian processes, connecting classical theory to cutting-edge developments.</p>
<p><strong>Advanced Topics</strong> (Section 9): We cover jump-diffusion processes, stochastic volatility models, and path-dependent derivatives.</p>
<p>Throughout, we provide rigorous mathematical proofs, comprehensive Python implementations optimized with modern computational libraries, and publication-quality visualizations that illuminate key concepts and facilitate practical application.</p>
</section>
</section>
<section id="sec-foundations" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-foundations"><span class="header-section-number">2</span> Mathematical Foundations</h2>
<section id="probability-spaces-and-filtrations" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="probability-spaces-and-filtrations"><span class="header-section-number">2.1</span> Probability Spaces and Filtrations</h3>
<p>The rigorous development of stochastic differential equation theory requires careful construction of the underlying probability framework. We begin with the fundamental mathematical structures that support stochastic analysis.</p>
<p><strong>Definition 2.1 (Probability Space)</strong>: A probability space is a triple <span class="math inline">\((\Omega, \mathcal{F}, \mathbb{P})\)</span> where: - <span class="math inline">\(\Omega\)</span> is the sample space representing all possible outcomes - <span class="math inline">\(\mathcal{F}\)</span> is a <span class="math inline">\(\sigma\)</span>-algebra on <span class="math inline">\(\Omega\)</span> representing measurable events - <span class="math inline">\(\mathbb{P}: \mathcal{F} \to [0,1]\)</span> is a probability measure satisfying <span class="math inline">\(\mathbb{P}(\Omega) = 1\)</span></p>
<p><strong>Definition 2.2 (Filtration)</strong>: A filtration <span class="math inline">\(\{\mathcal{F}_t\}_{t \geq 0}\)</span> is an increasing family of sub-<span class="math inline">\(\sigma\)</span>-algebras of <span class="math inline">\(\mathcal{F}\)</span>: <span class="math display">\[\mathcal{F}_s \subseteq \mathcal{F}_t \subseteq \mathcal{F} \quad \text{for all } 0 \leq s \leq t\]</span></p>
<p>The filtration represents the evolution of information over time, where <span class="math inline">\(\mathcal{F}_t\)</span> contains all events observable up to time <span class="math inline">\(t\)</span>.</p>
</section>
<section id="brownian-motion-and-the-wiener-process" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="brownian-motion-and-the-wiener-process"><span class="header-section-number">2.2</span> Brownian Motion and the Wiener Process</h3>
<p>Brownian motion forms the cornerstone of stochastic calculus, providing the fundamental building block for constructing more complex stochastic processes.</p>
<p><strong>Definition 2.3 (Standard Brownian Motion)</strong>: A stochastic process <span class="math inline">\(\{W_t\}_{t \geq 0}\)</span> defined on <span class="math inline">\((\Omega, \mathcal{F}, \mathbb{P})\)</span> is called standard Brownian motion if:</p>
<ol type="1">
<li><strong>Initial condition</strong>: <span class="math inline">\(W_0 = 0\)</span> almost surely</li>
<li><strong>Independent increments</strong>: For any <span class="math inline">\(0 \leq t_1 &lt; t_2 &lt; \cdots &lt; t_n\)</span>, the increments <span class="math inline">\(W_{t_2} - W_{t_1}, W_{t_3} - W_{t_2}, \ldots, W_{t_n} - W_{t_{n-1}}\)</span> are independent</li>
<li><strong>Gaussian increments</strong>: For any <span class="math inline">\(s &lt; t\)</span>, <span class="math inline">\(W_t - W_s \sim \mathcal{N}(0, t-s)\)</span></li>
<li><strong>Continuous paths</strong>: <span class="math inline">\(t \mapsto W_t(\omega)\)</span> is continuous for almost all <span class="math inline">\(\omega \in \Omega\)</span></li>
</ol>
<div id="cell-fig-brownian-motion" class="cell" data-fig-height="12" data-fig-width="18" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">@njit</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_brownian_motion(T, N, n_paths<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Efficiently simulate Brownian motion paths using Numba acceleration."""</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_paths):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, N <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            paths[i, j] <span class="op">=</span> paths[i, j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> sqrt_dt <span class="op">*</span> np.random.randn()</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> paths</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># Time horizon</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># Number of time steps</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>n_paths <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate multiple Brownian motion paths</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>paths <span class="op">=</span> simulate_brownian_motion(T, N, n_paths)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">12</span>))</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample paths</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, paths[:<span class="dv">20</span>].T, alpha<span class="op">=</span><span class="fl">0.6</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, paths[<span class="dv">0</span>], <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Sample Paths of Brownian Motion'</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'W(t)'</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution at fixed time</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>t_fixed <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>W_fixed <span class="op">=</span> paths[:, <span class="bu">int</span>(t_fixed <span class="op">*</span> N)]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].hist(W_fixed, bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'skyblue'</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>x_range <span class="op">=</span> np.linspace(W_fixed.<span class="bu">min</span>(), W_fixed.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>theoretical_pdf <span class="op">=</span> stats.norm.pdf(x_range, <span class="dv">0</span>, np.sqrt(t_fixed))</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(x_range, theoretical_pdf, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'N(0, </span><span class="sc">{</span>t_fixed<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="ss">f'Distribution of W(</span><span class="sc">{</span>t_fixed<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Value'</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Increment distribution</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>increments <span class="op">=</span> np.diff(paths[<span class="dv">0</span>])</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].hist(increments, bins<span class="op">=</span><span class="dv">40</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'lightcoral'</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>x_inc <span class="op">=</span> np.linspace(increments.<span class="bu">min</span>(), increments.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>theoretical_inc <span class="op">=</span> stats.norm.pdf(x_inc, <span class="dv">0</span>, np.sqrt(dt))</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].plot(x_inc, theoretical_inc, <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'N(0, </span><span class="sc">{</span>dt<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="st">'Increment Distribution'</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Increment Value'</span>)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].legend()</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Quadratic variation approximation</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quadratic_variation(path, dt):</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute empirical quadratic variation."""</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    increments <span class="op">=</span> np.diff(path)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.cumsum(increments<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>qv <span class="op">=</span> quadratic_variation(paths[<span class="dv">0</span>], dt)</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t[<span class="dv">1</span>:], qv, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Empirical [W,W]_t'</span>)</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, t, <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Theoretical t'</span>)</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Quadratic Variation'</span>)</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'[W,W]_t'</span>)</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Path roughness (non-differentiability)</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute finite difference approximations to derivatives</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>h_values <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.05</span>, <span class="fl">0.01</span>, <span class="fl">0.005</span>]</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'red'</span>, <span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'orange'</span>]</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, h <span class="kw">in</span> <span class="bu">enumerate</span>(h_values):</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    n_h <span class="op">=</span> <span class="bu">int</span>(h <span class="op">/</span> dt)</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_h <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        t_deriv <span class="op">=</span> t[:<span class="op">-</span>n_h]</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        finite_diff <span class="op">=</span> (paths[<span class="dv">0</span>, n_h:] <span class="op">-</span> paths[<span class="dv">0</span>, :<span class="op">-</span>n_h]) <span class="op">/</span> h</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(t_deriv, finite_diff, color<span class="op">=</span>colors[i], alpha<span class="op">=</span><span class="fl">0.7</span>, </span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>                       linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="ss">f'h = </span><span class="sc">{</span>h<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Finite Difference Approximations</span><span class="ch">\n</span><span class="st">(Illustrating Non-differentiability)'</span>)</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'(W(t+h) - W(t))/h'</span>)</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="co"># Scaling property demonstration</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>scaled_paths <span class="op">=</span> []</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>scale_factors <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>]</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>colors_scale <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'red'</span>, <span class="st">'green'</span>]</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(scale_factors):</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># W(ct) has same distribution as sqrt(c) * W(t)</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> c <span class="op">!=</span> <span class="fl">1.0</span>:</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        t_scaled <span class="op">=</span> t <span class="op">*</span> c</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c <span class="op">&lt;</span> <span class="fl">1.0</span>:</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Subsample for c &lt; 1</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>            indices <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span>, <span class="bu">int</span>(<span class="bu">len</span>(t)<span class="op">*</span>c)).astype(<span class="bu">int</span>)</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>            scaled_path <span class="op">=</span> paths[<span class="dv">0</span>, indices] <span class="op">/</span> np.sqrt(c)</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>            t_plot <span class="op">=</span> t[:<span class="bu">len</span>(indices)]</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extend time for c &gt; 1</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>            extended_path <span class="op">=</span> simulate_brownian_motion(T<span class="op">*</span>c, <span class="bu">int</span>(N<span class="op">*</span>c), <span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>            scaled_path <span class="op">=</span> extended_path <span class="op">/</span> np.sqrt(c)</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>            t_plot <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, <span class="bu">len</span>(scaled_path))</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>        scaled_path <span class="op">=</span> paths[<span class="dv">0</span>]</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>        t_plot <span class="op">=</span> t</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">2</span>].plot(t_plot, scaled_path, color<span class="op">=</span>colors_scale[i], </span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>                   linewidth<span class="op">=</span><span class="fl">1.5</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="ss">f'c = </span><span class="sc">{</span>c<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'Self-Similarity Property</span><span class="ch">\n</span><span class="st">W(ct) ~ √c · W(t)'</span>)</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'Scaled W(t)'</span>)</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].legend()</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-brownian-motion" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-brownian-motion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-brownian-motion-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-brownian-motion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Sample paths of Brownian motion and their key properties
</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Theorem 2.4 (Properties of Brownian Motion)</strong>: Standard Brownian motion possesses the following fundamental properties:</p>
<ol type="1">
<li><strong>Martingale property</strong>: <span class="math inline">\(\{W_t\}\)</span> is a martingale with respect to its natural filtration</li>
<li><strong>Quadratic variation</strong>: <span class="math inline">\([W,W]_t = t\)</span> (in the sense of convergence in probability)</li>
<li><strong>Markov property</strong>: For <span class="math inline">\(s &lt; t\)</span>, <span class="math inline">\(\mathbb{E}[f(W_t) | \mathcal{F}_s] = \mathbb{E}[f(W_t) | W_s]\)</span></li>
<li><strong>Self-similarity</strong>: <span class="math inline">\(\{W_{ct}\}_{t \geq 0} \stackrel{d}{=} \{\sqrt{c} W_t\}_{t \geq 0}\)</span> for any <span class="math inline">\(c &gt; 0\)</span></li>
<li><strong>Path properties</strong>: Paths are continuous but nowhere differentiable with probability 1</li>
</ol>
</section>
<section id="multi-dimensional-brownian-motion" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="multi-dimensional-brownian-motion"><span class="header-section-number">2.3</span> Multi-dimensional Brownian Motion</h3>
<p><strong>Definition 2.5 (d-dimensional Brownian Motion)</strong>: A <span class="math inline">\(d\)</span>-dimensional Brownian motion is a vector process <span class="math inline">\(\mathbf{W}_t = (W_t^{(1)}, \ldots, W_t^{(d)})^T\)</span> where each component <span class="math inline">\(W_t^{(i)}\)</span> is independent standard Brownian motion.</p>
<p>For correlated Brownian motions, we can construct them using: <span class="math display">\[\mathbf{W}_t = \mathbf{L} \mathbf{Z}_t\]</span> where <span class="math inline">\(\mathbf{Z}_t\)</span> is <span class="math inline">\(d\)</span>-dimensional independent Brownian motion and <span class="math inline">\(\mathbf{L}\)</span> is the Cholesky decomposition of the correlation matrix <span class="math inline">\(\boldsymbol{\Sigma}\)</span>.</p>
<div id="cell-fig-multidimensional-brownian" class="cell" data-fig-height="10" data-fig-width="16" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_correlated_brownian(T, N, correlation_matrix, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate correlated multi-dimensional Brownian motion."""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> correlation_matrix.shape[<span class="dv">0</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cholesky decomposition for correlation</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> cholesky(correlation_matrix, lower<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> np.zeros((n_paths, d, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> path <span class="kw">in</span> <span class="bu">range</span>(n_paths):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, N <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Generate independent increments</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            dZ <span class="op">=</span> np.random.randn(d) <span class="op">*</span> sqrt_dt</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply correlation structure</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            dW <span class="op">=</span> L <span class="op">@</span> dZ</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            paths[path, :, i] <span class="op">=</span> paths[path, :, i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dW</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> paths</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Correlation matrices</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>correlations <span class="op">=</span> [</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    np.array([[<span class="fl">1.0</span>, <span class="fl">0.0</span>], [<span class="fl">0.0</span>, <span class="fl">1.0</span>]]),  <span class="co"># Independent</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    np.array([[<span class="fl">1.0</span>, <span class="fl">0.7</span>], [<span class="fl">0.7</span>, <span class="fl">1.0</span>]]),  <span class="co"># Positive correlation</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    np.array([[<span class="fl">1.0</span>, <span class="op">-</span><span class="fl">0.5</span>], [<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.0</span>]]) <span class="co"># Negative correlation</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>correlation_names <span class="op">=</span> [<span class="st">'Independent (ρ=0)'</span>, <span class="st">'Positive (ρ=0.7)'</span>, <span class="st">'Negative (ρ=-0.5)'</span>]</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">10</span>))</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (corr_matrix, name) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(correlations, correlation_names)):</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate paths</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> simulate_correlated_brownian(T, N, corr_matrix, n_paths<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Time series plot</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>):  <span class="co"># Plot subset of paths</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].plot(t, paths[j, <span class="dv">0</span>, :], alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'blue'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].plot(t, paths[j, <span class="dv">1</span>, :], alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight one path</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].plot(t, paths[<span class="dv">0</span>, <span class="dv">0</span>, :], color<span class="op">=</span><span class="st">'blue'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'W₁(t)'</span>)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].plot(t, paths[<span class="dv">0</span>, <span class="dv">1</span>, :], color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'W₂(t)'</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f'Time Series: </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_ylabel(<span class="st">'W(t)'</span>)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].legend()</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Phase plot (W₁ vs W₂)</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">50</span>):</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].plot(paths[j, <span class="dv">0</span>, :], paths[j, <span class="dv">1</span>, :], alpha<span class="op">=</span><span class="fl">0.4</span>, linewidth<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].scatter(<span class="dv">0</span>, <span class="dv">0</span>, color<span class="op">=</span><span class="st">'green'</span>, s<span class="op">=</span><span class="dv">100</span>, marker<span class="op">=</span><span class="st">'o'</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Origin'</span>)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'Phase Plot: </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_xlabel(<span class="st">'W₁(t)'</span>)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_ylabel(<span class="st">'W₂(t)'</span>)</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].legend()</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].axis(<span class="st">'equal'</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-multidimensional-brownian" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-multidimensional-brownian-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-multidimensional-brownian-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multidimensional-brownian-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Multi-dimensional Brownian motion with correlation structure
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="martingales-and-stopping-times" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="martingales-and-stopping-times"><span class="header-section-number">2.4</span> Martingales and Stopping Times</h3>
<p><strong>Definition 2.6 (Martingale)</strong>: A stochastic process <span class="math inline">\(\{M_t\}_{t \geq 0}\)</span> adapted to filtration <span class="math inline">\(\{\mathcal{F}_t\}\)</span> is a martingale if: 1. <span class="math inline">\(\mathbb{E}[|M_t|] &lt; \infty\)</span> for all <span class="math inline">\(t \geq 0\)</span> 2. <span class="math inline">\(\mathbb{E}[M_t | \mathcal{F}_s] = M_s\)</span> for all <span class="math inline">\(0 \leq s \leq t\)</span></p>
<p><strong>Theorem 2.7 (Examples of Martingales)</strong>: The following processes are martingales: 1. Brownian motion <span class="math inline">\(W_t\)</span> 2. <span class="math inline">\(W_t^2 - t\)</span> (compensated quadratic variation) 3. <span class="math inline">\(\exp(\sigma W_t - \frac{\sigma^2 t}{2})\)</span> for any <span class="math inline">\(\sigma \in \mathbb{R}\)</span> (exponential martingale)</p>
<p><strong>Definition 2.8 (Stopping Time)</strong>: A random variable <span class="math inline">\(\tau: \Omega \to [0, \infty]\)</span> is a stopping time with respect to <span class="math inline">\(\{\mathcal{F}_t\}\)</span> if for every <span class="math inline">\(t \geq 0\)</span>: <span class="math display">\[\{\tau \leq t\} \in \mathcal{F}_t\]</span></p>
<p><strong>Theorem 2.9 (Optional Stopping Theorem)</strong>: If <span class="math inline">\(M_t\)</span> is a martingale and <span class="math inline">\(\tau\)</span> is a bounded stopping time, then: <span class="math display">\[\mathbb{E}[M_\tau] = \mathbb{E}[M_0]\]</span></p>
<p>These foundational concepts provide the mathematical infrastructure necessary for constructing stochastic integrals and developing the theory of stochastic differential equations. In the next section, we will build upon this foundation to develop Itô calculus, the cornerstone of stochastic analysis.</p>
</section>
</section>
<section id="sec-ito-calculus" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-ito-calculus"><span class="header-section-number">3</span> Itô Calculus and Stochastic Integration</h2>
<p>The development of stochastic calculus represents one of the most profound mathematical achievements of the 20th century. Classical calculus fails when applied to functions of Brownian motion due to their infinite variation and non-differentiable nature. Itô’s revolutionary insight was to develop a new form of calculus specifically designed for stochastic processes.</p>
<section id="the-need-for-stochastic-calculus" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="the-need-for-stochastic-calculus"><span class="header-section-number">3.1</span> The Need for Stochastic Calculus</h3>
<p>Consider attempting to define the integral <span class="math inline">\(\int_0^t W_s \, dW_s\)</span> using classical Riemann-Stieltjes integration. The fundamental problem arises from the fact that Brownian motion has infinite variation on any interval, making classical integration impossible.</p>
<div id="cell-fig-variation-problem" class="cell" data-fig-height="8" data-fig-width="14" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_variation(path, time_grid):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute total variation of a function on given grid."""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(np.diff(path)))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_quadratic_variation(path, time_grid):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute quadratic variation approximation."""</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(np.diff(path)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate fine Brownian motion path</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>N_fine <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>t_fine <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N_fine <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>dt_fine <span class="op">=</span> T <span class="op">/</span> N_fine</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>W_fine <span class="op">=</span> np.cumsum(np.concatenate([[<span class="dv">0</span>], np.random.randn(N_fine) <span class="op">*</span> np.sqrt(dt_fine)]))</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute variations for different grid sizes</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>grid_sizes <span class="op">=</span> np.logspace(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">20</span>).astype(<span class="bu">int</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>total_variations <span class="op">=</span> []</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>quadratic_variations <span class="op">=</span> []</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> N <span class="kw">in</span> grid_sizes:</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> N <span class="op">&lt;=</span> N_fine:</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> np.linspace(<span class="dv">0</span>, N_fine, N <span class="op">+</span> <span class="dv">1</span>).astype(<span class="bu">int</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        subpath <span class="op">=</span> W_fine[indices]</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        t_sub <span class="op">=</span> t_fine[indices]</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        total_var <span class="op">=</span> compute_variation(subpath, t_sub)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        quad_var <span class="op">=</span> compute_quadratic_variation(subpath, t_sub)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        total_variations.append(total_var)</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        quadratic_variations.append(quad_var)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">8</span>))</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot path and variations</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>N_display <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.linspace(<span class="dv">0</span>, N_fine, N_display <span class="op">+</span> <span class="dv">1</span>).astype(<span class="bu">int</span>)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].plot(t_fine[indices], W_fine[indices], <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Sample Brownian Motion Path'</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'W(t)'</span>)</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot variation convergence</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].loglog(grid_sizes[:<span class="bu">len</span>(total_variations)], total_variations, <span class="st">'ro-'</span>, </span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">'Total Variation'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].loglog(grid_sizes[:<span class="bu">len</span>(quadratic_variations)], quadratic_variations, <span class="st">'bs-'</span>, </span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">'Quadratic Variation'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].axhline(y<span class="op">=</span>T, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="ss">f'Theoretical QV = </span><span class="sc">{</span>T<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'Number of Grid Points'</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">'Variation'</span>)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Variation Behavior as Grid Refines'</span>)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].legend()</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Final total variation: </span><span class="sc">{</span>total_variations[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Final quadratic variation: </span><span class="sc">{</span>quadratic_variations[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Theoretical quadratic variation: </span><span class="sc">{</span>T<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-variation-problem" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-variation-problem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-variation-problem-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-variation-problem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Illustration of infinite variation in Brownian motion
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Final total variation: 79.95
Final quadratic variation: 1.007
Theoretical quadratic variation: 1.0</code></pre>
</div>
</div>
</section>
<section id="construction-of-the-itô-integral" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="construction-of-the-itô-integral"><span class="header-section-number">3.2</span> Construction of the Itô Integral</h3>
<p><strong>Definition 3.1 (Simple Process)</strong>: A stochastic process <span class="math inline">\(\{H_t\}\)</span> is simple if it can be written as: <span class="math display">\[H_t = H_0 \mathbf{1}_{\{0\}}(t) + \sum_{i=1}^n H_{t_i} \mathbf{1}_{(t_i, t_{i+1}]}(t)\]</span> where <span class="math inline">\(0 = t_0 &lt; t_1 &lt; \cdots &lt; t_n &lt; \infty\)</span> and each <span class="math inline">\(H_{t_i}\)</span> is <span class="math inline">\(\mathcal{F}_{t_i}\)</span>-measurable.</p>
<p><strong>Definition 3.2 (Itô Integral for Simple Processes)</strong>: For a simple process <span class="math inline">\(H_t\)</span>, the Itô integral is defined as: <span class="math display">\[\int_0^t H_s \, dW_s = \sum_{i=0}^{n-1} H_{t_i}(W_{t_{i+1} \wedge t} - W_{t_i \wedge t})\]</span></p>
<p><strong>Theorem 3.3 (Itô Isometry)</strong>: For simple processes <span class="math inline">\(H_t\)</span>: <span class="math display">\[\mathbb{E}\left[\left(\int_0^t H_s \, dW_s\right)^2\right] = \mathbb{E}\left[\int_0^t H_s^2 \, ds\right]\]</span></p>
<p><strong>Definition 3.4 (General Itô Integral)</strong>: For adapted processes <span class="math inline">\(H_t\)</span> satisfying <span class="math inline">\(\mathbb{E}\left[\int_0^t H_s^2 \, ds\right] &lt; \infty\)</span>, the Itô integral <span class="math inline">\(\int_0^t H_s \, dW_s\)</span> is defined as the <span class="math inline">\(L^2\)</span> limit of Itô integrals of simple processes approximating <span class="math inline">\(H_t\)</span>.</p>
</section>
<section id="itôs-lemma-the-fundamental-theorem" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="itôs-lemma-the-fundamental-theorem"><span class="header-section-number">3.3</span> Itô’s Lemma: The Fundamental Theorem</h3>
<p><strong>Theorem 3.5 (Itô’s Lemma)</strong>: Let <span class="math inline">\(W_t\)</span> be Brownian motion and <span class="math inline">\(f(t,x) \in C^{1,2}([0,\infty) \times \mathbb{R})\)</span>. Then:</p>
<p><span class="math display">\[df(t, W_t) = \frac{\partial f}{\partial t}(t, W_t) dt + \frac{\partial f}{\partial x}(t, W_t) dW_t + \frac{1}{2}\frac{\partial^2 f}{\partial x^2}(t, W_t) dt\]</span></p>
<p><strong>Proof Sketch</strong>: The key insight is the quadratic variation term. Using Taylor expansion: <span class="math display">\[df = f_t dt + f_x dW_t + \frac{1}{2}f_{xx}(dW_t)^2 + \frac{1}{2}f_{tt}(dt)^2 + f_{tx} dt \, dW_t + \cdots\]</span></p>
<p>Since <span class="math inline">\((dW_t)^2 = dt\)</span> in the sense of quadratic variation, and higher-order terms vanish, we obtain Itô’s formula. □</p>
<div id="cell-fig-ito-lemma-demo" class="cell" data-fig-height="10" data-fig-width="16" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ito_lemma_verification(f, df_dt, df_dx, d2f_dx2, W_path, dt):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Verify Itô's lemma numerically by comparing direct computation</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    with the Itô formula prediction.</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.arange(<span class="bu">len</span>(W_path)) <span class="op">*</span> dt</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Direct computation of f(t, W_t)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    f_values <span class="op">=</span> f(t, W_path)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    df_direct <span class="op">=</span> np.diff(f_values)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Itô formula prediction</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    t_mid <span class="op">=</span> t[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dt<span class="op">/</span><span class="dv">2</span>  <span class="co"># Midpoint rule for better accuracy</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    W_mid <span class="op">=</span> (W_path[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> W_path[<span class="dv">1</span>:]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    dW <span class="op">=</span> np.diff(W_path)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    df_ito <span class="op">=</span> (df_dt(t_mid, W_mid) <span class="op">*</span> dt <span class="op">+</span> </span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>              df_dx(t_mid, W_mid) <span class="op">*</span> dW <span class="op">+</span> </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>              <span class="fl">0.5</span> <span class="op">*</span> d2f_dx2(t_mid, W_mid) <span class="op">*</span> dt)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_direct, df_ito, f_values</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 1: f(t,x) = x^2</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f1(t, x):</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> df1_dt(t, x):</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.zeros_like(x)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> df1_dx(t, x):</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>x</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> d2f1_dx2(t, x):</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> np.ones_like(x)</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 2: f(t,x) = exp(x - t/2) (Exponential martingale)</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f2(t, x):</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(x <span class="op">-</span> t<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> df2_dt(t, x):</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.exp(x <span class="op">-</span> t<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> df2_dx(t, x):</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(x <span class="op">-</span> t<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> d2f2_dx2(t, x):</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(x <span class="op">-</span> t<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.cumsum(np.concatenate([[<span class="dv">0</span>], np.random.randn(N) <span class="op">*</span> np.sqrt(dt)]))</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">10</span>))</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 1: f(t,x) = x^2</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>df1_direct, df1_ito, f1_values <span class="op">=</span> ito_lemma_verification(</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    f1, df1_dt, df1_dx, d2f1_dx2, W, dt)</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, f1_values, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'W²(t)'</span>)</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Function: f(t,x) = x²'</span>)</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'f(t, W(t))'</span>)</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t[:<span class="op">-</span><span class="dv">1</span>], df1_direct, <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Direct: Δf'</span>)</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t[:<span class="op">-</span><span class="dv">1</span>], df1_ito, <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Itô formula'</span>)</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Increment Comparison'</span>)</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'df'</span>)</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a><span class="co"># Error analysis</span></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>error1 <span class="op">=</span> df1_direct <span class="op">-</span> df1_ito</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].plot(t[:<span class="op">-</span><span class="dv">1</span>], error1, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_title(<span class="ss">f'Error (RMS: </span><span class="sc">{</span>np<span class="sc">.</span>sqrt(np.mean(error1<span class="op">**</span><span class="dv">2</span>))<span class="sc">:.6f}</span><span class="ss">)'</span>)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'Direct - Itô'</span>)</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">2</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Example 2: Exponential martingale</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>df2_direct, df2_ito, f2_values <span class="op">=</span> ito_lemma_verification(</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>    f2, df2_dt, df2_dx, d2f2_dx2, W, dt)</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, f2_values, <span class="st">'purple'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'exp(W(t) - t/2)'</span>)</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Exponential Martingale'</span>)</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'f(t, W(t))'</span>)</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(t[:<span class="op">-</span><span class="dv">1</span>], df2_direct, <span class="st">'purple'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Direct: Δf'</span>)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(t[:<span class="op">-</span><span class="dv">1</span>], df2_ito, <span class="st">'orange'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Itô formula'</span>)</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Increment Comparison'</span>)</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'df'</span>)</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>error2 <span class="op">=</span> df2_direct <span class="op">-</span> df2_ito</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].plot(t[:<span class="op">-</span><span class="dv">1</span>], error2, <span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="ss">f'Error (RMS: </span><span class="sc">{</span>np<span class="sc">.</span>sqrt(np.mean(error2<span class="op">**</span><span class="dv">2</span>))<span class="sc">:.6f}</span><span class="ss">)'</span>)</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'Direct - Itô'</span>)</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a><span class="co"># Theoretical verification for x^2</span></span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Theoretical verification for f(t,x) = x²:"</span>)</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"df = 2W dW + dt"</span>)</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This gives: d(W²) = 2W dW + dt"</span>)</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"So W²(t) = 2∫₀ᵗ W(s) dW(s) + t"</span>)</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Empirical: W²(</span><span class="sc">{</span>T<span class="sc">:.1f}</span><span class="ss">) = </span><span class="sc">{</span>W[<span class="op">-</span><span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span><span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Formula:   2∫WdW + t = </span><span class="sc">{</span><span class="dv">2</span> <span class="op">*</span> np<span class="sc">.</span><span class="bu">sum</span>(W[:<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> np.diff(W)) <span class="op">+</span> T<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-ito-lemma-demo" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ito-lemma-demo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-ito-lemma-demo-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ito-lemma-demo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Demonstration of Itô’s lemma with geometric Brownian motion
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Theoretical verification for f(t,x) = x²:
df = 2W dW + dt
This gives: d(W²) = 2W dW + dt
So W²(t) = 2∫₀ᵗ W(s) dW(s) + t
Empirical: W²(1.0) = 0.374
Formula:   2∫WdW + t = 0.415</code></pre>
</div>
</div>
</section>
<section id="multi-dimensional-itôs-lemma" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="multi-dimensional-itôs-lemma"><span class="header-section-number">3.4</span> Multi-dimensional Itô’s Lemma</h3>
<p><strong>Theorem 3.6 (Multi-dimensional Itô’s Lemma)</strong>: Let <span class="math inline">\(\mathbf{X}_t = (X_t^{(1)}, \ldots, X_t^{(d)})^T\)</span> be an Itô process satisfying: <span class="math display">\[d\mathbf{X}_t = \boldsymbol{\mu}(t, \mathbf{X}_t) dt + \boldsymbol{\sigma}(t, \mathbf{X}_t) d\mathbf{W}_t\]</span></p>
<p>For <span class="math inline">\(f(t, \mathbf{x}) \in C^{1,2}([0,\infty) \times \mathbb{R}^d)\)</span>:</p>
<p><span class="math display">\[df(t, \mathbf{X}_t) = \frac{\partial f}{\partial t} dt + \sum_{i=1}^d \frac{\partial f}{\partial x_i} dX_t^{(i)} + \frac{1}{2} \sum_{i,j=1}^d \frac{\partial^2 f}{\partial x_i \partial x_j} d\langle X^{(i)}, X^{(j)} \rangle_t\]</span></p>
<p>where <span class="math inline">\(d\langle X^{(i)}, X^{(j)} \rangle_t = \sum_{k=1}^m \sigma_{ik} \sigma_{jk} dt\)</span> is the quadratic covariation.</p>
</section>
<section id="applications-of-itôs-lemma" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="applications-of-itôs-lemma"><span class="header-section-number">3.5</span> Applications of Itô’s Lemma</h3>
<div id="cell-fig-ito-applications" class="cell" data-fig-height="12" data-fig-width="18" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_geometric_brownian(S0, mu, sigma, T, N, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate geometric Brownian motion using exact solution."""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate Brownian increments</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    dW <span class="op">=</span> np.random.randn(n_paths, N) <span class="op">*</span> np.sqrt(dt)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> np.column_stack([np.zeros(n_paths), np.cumsum(dW, axis<span class="op">=</span><span class="dv">1</span>)])</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exact solution: S(t) = S0 * exp((mu - sigma²/2)t + sigma*W(t))</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> S0 <span class="op">*</span> np.exp((mu <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> t[np.newaxis, :] <span class="op">+</span> sigma <span class="op">*</span> W)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t, S</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_ornstein_uhlenbeck(X0, theta, mu, sigma, T, N, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate Ornstein-Uhlenbeck process using exact solution."""</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    X[:, <span class="dv">0</span>] <span class="op">=</span> X0</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Exact transition: X(t+dt) = X(t)*exp(-theta*dt) + mu*(1-exp(-theta*dt)) + noise</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        exp_theta_dt <span class="op">=</span> np.exp(<span class="op">-</span>theta <span class="op">*</span> dt)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> X[:, i] <span class="op">*</span> exp_theta_dt <span class="op">+</span> mu <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> exp_theta_dt)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        var <span class="op">=</span> sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> theta <span class="op">*</span> dt)) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> theta)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        X[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> mean <span class="op">+</span> np.sqrt(var) <span class="op">*</span> np.random.randn(n_paths)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t, X</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>n_paths <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Geometric Brownian Motion parameters</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Ornstein-Uhlenbeck parameters</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>X0 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>mu_ou <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>sigma_ou <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">12</span>))</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a><span class="co"># Geometric Brownian Motion</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>t_gbm, S_gbm <span class="op">=</span> simulate_geometric_brownian(S0, mu, sigma, T, N, n_paths)</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot sample paths</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">50</span>, n_paths)):</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t_gbm, S_gbm[i], alpha<span class="op">=</span><span class="fl">0.3</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t_gbm, S_gbm[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Geometric Brownian Motion</span><span class="ch">\n</span><span class="st">dS = μS dt + σS dW'</span>)</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'S(t)'</span>)</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Log-returns distribution</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>log_returns <span class="op">=</span> np.log(S_gbm[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> S_gbm[:, <span class="dv">0</span>])</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].hist(log_returns, bins<span class="op">=</span><span class="dv">40</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'skyblue'</span>)</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>theoretical_mean <span class="op">=</span> (mu <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>theoretical_std <span class="op">=</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>x_range <span class="op">=</span> np.linspace(log_returns.<span class="bu">min</span>(), log_returns.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>theoretical_pdf <span class="op">=</span> stats.norm.pdf(x_range, theoretical_mean, theoretical_std)</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(x_range, theoretical_pdf, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="ss">f'N(</span><span class="sc">{</span>theoretical_mean<span class="sc">:.3f}</span><span class="ss">, </span><span class="sc">{</span>theoretical_std<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Log-Return Distribution'</span>)</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'log(S(T)/S(0))'</span>)</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a><span class="co"># Mean and variance evolution</span></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>means <span class="op">=</span> np.mean(S_gbm, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a><span class="bu">vars</span> <span class="op">=</span> np.var(S_gbm, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>theoretical_mean <span class="op">=</span> S0 <span class="op">*</span> np.exp(mu <span class="op">*</span> t_gbm)</span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>theoretical_var <span class="op">=</span> S0<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.exp(<span class="dv">2</span><span class="op">*</span>mu <span class="op">*</span> t_gbm) <span class="op">*</span> (np.exp(sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> t_gbm) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(t_gbm, means, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Empirical mean'</span>)</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(t_gbm, theoretical_mean, <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Theoretical mean'</span>)</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Mean Evolution'</span>)</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'E[S(t)]'</span>)</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a><span class="co"># Ornstein-Uhlenbeck Process</span></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>t_ou, X_ou <span class="op">=</span> simulate_ornstein_uhlenbeck(X0, theta, mu_ou, sigma_ou, T, N, n_paths)</span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot sample paths</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">50</span>, n_paths)):</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_ou, X_ou[i], alpha<span class="op">=</span><span class="fl">0.3</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_ou, X_ou[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span>mu_ou, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="ss">f'Long-term mean = </span><span class="sc">{</span>mu_ou<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Ornstein-Uhlenbeck Process</span><span class="ch">\n</span><span class="st">dX = θ(μ - X) dt + σ dW'</span>)</span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'X(t)'</span>)</span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a><span class="co"># Stationary distribution</span></span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>final_values <span class="op">=</span> X_ou[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(final_values, bins<span class="op">=</span><span class="dv">40</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'lightgreen'</span>)</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a><span class="co"># Theoretical stationary distribution: N(μ, σ²/(2θ))</span></span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>stationary_var <span class="op">=</span> sigma_ou<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> theta)</span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a>x_range_ou <span class="op">=</span> np.linspace(final_values.<span class="bu">min</span>(), final_values.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>stationary_pdf <span class="op">=</span> stats.norm.pdf(x_range_ou, mu_ou, np.sqrt(stationary_var))</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(x_range_ou, stationary_pdf, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="ss">f'N(</span><span class="sc">{</span>mu_ou<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>np<span class="sc">.</span>sqrt(stationary_var)<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Terminal Distribution (t=2)'</span>)</span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X(T)'</span>)</span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a><span class="co"># Mean reversion demonstration</span></span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a>means_ou <span class="op">=</span> np.mean(X_ou, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-123"><a href="#cb7-123" aria-hidden="true" tabindex="-1"></a>vars_ou <span class="op">=</span> np.var(X_ou, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-124"><a href="#cb7-124" aria-hidden="true" tabindex="-1"></a>theoretical_mean_ou <span class="op">=</span> mu_ou <span class="op">+</span> (X0 <span class="op">-</span> mu_ou) <span class="op">*</span> np.exp(<span class="op">-</span>theta <span class="op">*</span> t_ou)</span>
<span id="cb7-125"><a href="#cb7-125" aria-hidden="true" tabindex="-1"></a>theoretical_var_ou <span class="op">=</span> sigma_ou<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> theta) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> theta <span class="op">*</span> t_ou))</span>
<span id="cb7-126"><a href="#cb7-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-127"><a href="#cb7-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(t_ou, means_ou, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Empirical mean'</span>)</span>
<span id="cb7-128"><a href="#cb7-128" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(t_ou, theoretical_mean_ou, <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Theoretical mean'</span>)</span>
<span id="cb7-129"><a href="#cb7-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(t_ou, vars_ou, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Empirical variance'</span>)</span>
<span id="cb7-130"><a href="#cb7-130" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(t_ou, theoretical_var_ou, <span class="st">'orange'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb7-131"><a href="#cb7-131" aria-hidden="true" tabindex="-1"></a>               alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Theoretical variance'</span>)</span>
<span id="cb7-132"><a href="#cb7-132" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Mean Reversion and Variance Evolution'</span>)</span>
<span id="cb7-133"><a href="#cb7-133" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb7-134"><a href="#cb7-134" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Moments'</span>)</span>
<span id="cb7-135"><a href="#cb7-135" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb7-136"><a href="#cb7-136" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-137"><a href="#cb7-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-138"><a href="#cb7-138" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-139"><a href="#cb7-139" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-ito-applications" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ito-applications-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-ito-applications-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ito-applications-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Applications of Itô’s lemma: Geometric Brownian motion and Ornstein-Uhlenbeck process
</figcaption>
</figure>
</div>
</div>
</div>
<p>The development of Itô calculus provides the mathematical foundation for analyzing stochastic differential equations. The key insights are:</p>
<ol type="1">
<li><strong>Quadratic variation matters</strong>: Unlike classical calculus, <span class="math inline">\((dW_t)^2 = dt\)</span> contributes to the dynamics</li>
<li><strong>Martingale preservation</strong>: Properly constructed stochastic integrals preserve the martingale property</li>
<li><strong>Chain rule modification</strong>: Itô’s lemma includes an additional second-order term due to quadratic variation</li>
</ol>
<p>In the next section, we will use these tools to develop the general theory of stochastic differential equations and their solutions.</p>
</section>
</section>
<section id="sec-sde-theory" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-sde-theory"><span class="header-section-number">4</span> Stochastic Differential Equations: Theory and Existence</h2>
<p>Having established the foundations of stochastic calculus, we now turn to the central object of study: stochastic differential equations. These equations describe the evolution of random processes and form the mathematical backbone of modern quantitative finance and stochastic modeling.</p>
<section id="mathematical-definition-and-classification" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="mathematical-definition-and-classification"><span class="header-section-number">4.1</span> Mathematical Definition and Classification</h3>
<p><strong>Definition 4.1 (Stochastic Differential Equation)</strong>: A stochastic differential equation (SDE) is an equation of the form: <span class="math display">\[dX_t = \mu(t, X_t) dt + \sigma(t, X_t) dW_t, \quad X_0 = x_0\]</span></p>
<p>where: - <span class="math inline">\(X_t\)</span> is the unknown stochastic process - <span class="math inline">\(\mu: [0,\infty) \times \mathbb{R} \to \mathbb{R}\)</span> is the drift coefficient - <span class="math inline">\(\sigma: [0,\infty) \times \mathbb{R} \to \mathbb{R}\)</span> is the diffusion coefficient<br>
- <span class="math inline">\(W_t\)</span> is standard Brownian motion - <span class="math inline">\(x_0\)</span> is the initial condition</p>
<p>The integral form is: <span class="math display">\[X_t = x_0 + \int_0^t \mu(s, X_s) ds + \int_0^t \sigma(s, X_s) dW_s\]</span></p>
<p><strong>Definition 4.2 (Strong vs Weak Solutions)</strong>: - A <strong>strong solution</strong> to an SDE is an adapted process <span class="math inline">\(X_t\)</span> defined on the same probability space as the driving Brownian motion <span class="math inline">\(W_t\)</span> - A <strong>weak solution</strong> exists on some probability space with some Brownian motion that has the same law as the original problem</p>
</section>
<section id="existence-and-uniqueness-theory" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="existence-and-uniqueness-theory"><span class="header-section-number">4.2</span> Existence and Uniqueness Theory</h3>
<p>The fundamental question in SDE theory concerns when solutions exist and when they are unique. The classical result is due to Itô and provides sufficient conditions.</p>
<p><strong>Theorem 4.3 (Existence and Uniqueness - Lipschitz Case)</strong>: Consider the SDE: <span class="math display">\[dX_t = \mu(t, X_t) dt + \sigma(t, X_t) dW_t, \quad X_0 = x_0\]</span></p>
<p>If <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span> satisfy: 1. <strong>Lipschitz condition</strong>: There exists <span class="math inline">\(K &gt; 0\)</span> such that for all <span class="math inline">\(t \geq 0\)</span> and <span class="math inline">\(x, y \in \mathbb{R}\)</span>: <span class="math display">\[|\mu(t,x) - \mu(t,y)| + |\sigma(t,x) - \sigma(t,y)| \leq K|x-y|\]</span></p>
<ol start="2" type="1">
<li><strong>Linear growth condition</strong>: There exists <span class="math inline">\(K &gt; 0\)</span> such that for all <span class="math inline">\(t \geq 0\)</span> and <span class="math inline">\(x \in \mathbb{R}\)</span>: <span class="math display">\[|\mu(t,x)| + |\sigma(t,x)| \leq K(1 + |x|)\]</span></li>
</ol>
<p>Then there exists a unique strong solution <span class="math inline">\(X_t\)</span> such that <span class="math inline">\(\mathbb{E}[\sup_{0 \leq s \leq t} |X_s|^2] &lt; \infty\)</span> for all <span class="math inline">\(t \geq 0\)</span>.</p>
<p><strong>Proof Sketch</strong>: The proof uses Picard iteration combined with the Grönwall inequality. Define the sequence: <span class="math display">\[X_t^{(0)} = x_0\]</span> <span class="math display">\[X_t^{(n+1)} = x_0 + \int_0^t \mu(s, X_s^{(n)}) ds + \int_0^t \sigma(s, X_s^{(n)}) dW_s\]</span></p>
<p>The Lipschitz condition ensures the sequence converges uniformly, while the growth condition guarantees the limit has finite moments. □</p>
<div id="cell-fig-existence-uniqueness" class="cell" data-fig-height="12" data-fig-width="16" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lipschitz_example_sde(x, t):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Example SDE coefficients satisfying Lipschitz conditions."""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> x  <span class="co"># Linear drift (Lipschitz constant = 0.5)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> <span class="fl">0.3</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> x)  <span class="co"># Near-constant diffusion (Lipschitz constant ≈ 0.03)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu, sigma</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> non_lipschitz_example_sde(x, t):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Example with non-Lipschitz coefficient leading to non-uniqueness."""</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(x))  <span class="co"># Non-Lipschitz at x=0</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu, sigma</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler_maruyama_step(x, dt, sde_func, t, dW):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Single Euler-Maruyama step."""</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    mu, sigma <span class="op">=</span> sde_func(x, t)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> mu <span class="op">*</span> dt <span class="op">+</span> sigma <span class="op">*</span> dW</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_sde_euler(x0, T, N, sde_func, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate SDE using Euler-Maruyama scheme."""</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    X[:, <span class="dv">0</span>] <span class="op">=</span> x0</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> sqrt_dt</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_paths):</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            X[j, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> euler_maruyama_step(X[j, i], dt, sde_func, t[i], dW[j])</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t, X</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>n_paths <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">12</span>))</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Lipschitz case: Unique solutions</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>t_lip, X_lip <span class="op">=</span> simulate_sde_euler(x0, T, N, lipschitz_example_sde, n_paths<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_lip.shape[<span class="dv">0</span>]):</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t_lip, X_lip[i], alpha<span class="op">=</span><span class="fl">0.4</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t_lip, X_lip[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Lipschitz Case: dX = -0.5X dt + 0.3(1+0.1X) dW</span><span class="ch">\n</span><span class="st">(Unique Solution)'</span>)</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'X(t)'</span>)</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution evolution for Lipschitz case</span></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>times_to_plot <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">1.5</span>, <span class="fl">2.0</span>]</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'orange'</span>, <span class="st">'red'</span>]</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (time_point, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(times_to_plot, colors)):</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>    time_idx <span class="op">=</span> <span class="bu">int</span>(time_point <span class="op">*</span> N <span class="op">/</span> T)</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> X_lip[:, time_idx]</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kernel density estimation for smooth histogram</span></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>    kde <span class="op">=</span> gaussian_kde(values)</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>    x_range <span class="op">=</span> np.linspace(values.<span class="bu">min</span>() <span class="op">-</span> <span class="fl">0.5</span>, values.<span class="bu">max</span>() <span class="op">+</span> <span class="fl">0.5</span>, <span class="dv">100</span>)</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>    density <span class="op">=</span> kde(x_range)</span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].fill_between(x_range, density, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span>color, </span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>                           label<span class="op">=</span><span class="ss">f't = </span><span class="sc">{</span>time_point<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(x_range, density, color<span class="op">=</span>color, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Distribution Evolution (Lipschitz Case)'</span>)</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'X(t)'</span>)</span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a><span class="co"># Mean and variance evolution</span></span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>means_lip <span class="op">=</span> np.mean(X_lip, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>vars_lip <span class="op">=</span> np.var(X_lip, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(t_lip, means_lip, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Empirical mean'</span>)</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(t_lip, vars_lip, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Empirical variance'</span>)</span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Moment Evolution (Lipschitz Case)'</span>)</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Moments'</span>)</span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a><span class="co"># Non-Lipschitz case: Potential non-uniqueness</span></span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a><span class="co"># Start very close to zero to illustrate the issue</span></span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>x0_small <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>t_nonlip, X_nonlip <span class="op">=</span> simulate_sde_euler(x0_small, T, N, non_lipschitz_example_sde, n_paths<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_nonlip.shape[<span class="dv">0</span>]):</span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_nonlip, X_nonlip[i], alpha<span class="op">=</span><span class="fl">0.4</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'purple'</span>)</span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_nonlip, X_nonlip[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Non-Lipschitz Case: dX = √|X| dW</span><span class="ch">\n</span><span class="st">(Starting near zero)'</span>)</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'X(t)'</span>)</span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the pathological behavior near zero</span></span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(X_nonlip[:, N<span class="op">//</span><span class="dv">2</span>], bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'lightcoral'</span>)</span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Distribution at t=1.0 (Non-Lipschitz Case)'</span>)</span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X(1)'</span>)</span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a><span class="co"># Coefficient comparison</span></span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a>x_range <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">100</span>)</span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a>mu_lip <span class="op">=</span> np.array([<span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> x <span class="cf">for</span> x <span class="kw">in</span> x_range])</span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a>sigma_lip <span class="op">=</span> np.array([<span class="fl">0.3</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> x) <span class="cf">for</span> x <span class="kw">in</span> x_range])</span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a>sigma_nonlip <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(x_range))</span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-119"><a href="#cb8-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(x_range, mu_lip, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'μ(x) = -0.5x (Lipschitz)'</span>)</span>
<span id="cb8-120"><a href="#cb8-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(x_range, sigma_lip, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'σ(x) = 0.3(1+0.1x) (Lipschitz)'</span>)</span>
<span id="cb8-121"><a href="#cb8-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(x_range, sigma_nonlip, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'σ(x) = √|x| (Non-Lipschitz)'</span>)</span>
<span id="cb8-122"><a href="#cb8-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Coefficient Functions'</span>)</span>
<span id="cb8-123"><a href="#cb8-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'x'</span>)</span>
<span id="cb8-124"><a href="#cb8-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Coefficient value'</span>)</span>
<span id="cb8-125"><a href="#cb8-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb8-126"><a href="#cb8-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-127"><a href="#cb8-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-128"><a href="#cb8-128" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-129"><a href="#cb8-129" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb8-130"><a href="#cb8-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-131"><a href="#cb8-131" aria-hidden="true" tabindex="-1"></a><span class="co"># Demonstrate Lipschitz constant computation</span></span>
<span id="cb8-132"><a href="#cb8-132" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Lipschitz Constant Analysis:"</span>)</span>
<span id="cb8-133"><a href="#cb8-133" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"For μ(x) = -0.5x: |μ(x) - μ(y)| = 0.5|x - y|, so L_μ = 0.5"</span>)</span>
<span id="cb8-134"><a href="#cb8-134" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"For σ(x) = 0.3(1 + 0.1x): |σ(x) - σ(y)| = 0.03|x - y|, so L_σ = 0.03"</span>)</span>
<span id="cb8-135"><a href="#cb8-135" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Combined Lipschitz constant: K = L_μ + L_σ = 0.53"</span>)</span>
<span id="cb8-136"><a href="#cb8-136" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb8-137"><a href="#cb8-137" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"For σ(x) = √|x|: |σ(x) - σ(y)| / |x - y| → ∞ as x,y → 0"</span>)</span>
<span id="cb8-138"><a href="#cb8-138" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"This violates the Lipschitz condition at x = 0"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-existence-uniqueness" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-existence-uniqueness-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-existence-uniqueness-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-existence-uniqueness-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Illustration of existence and uniqueness theory through pathwise solutions
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Lipschitz Constant Analysis:
For μ(x) = -0.5x: |μ(x) - μ(y)| = 0.5|x - y|, so L_μ = 0.5
For σ(x) = 0.3(1 + 0.1x): |σ(x) - σ(y)| = 0.03|x - y|, so L_σ = 0.03
Combined Lipschitz constant: K = L_μ + L_σ = 0.53

For σ(x) = √|x|: |σ(x) - σ(y)| / |x - y| → ∞ as x,y → 0
This violates the Lipschitz condition at x = 0</code></pre>
</div>
</div>
</section>
<section id="the-markov-property-and-generator" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="the-markov-property-and-generator"><span class="header-section-number">4.3</span> The Markov Property and Generator</h3>
<p><strong>Definition 4.4 (Markov Property)</strong>: A process <span class="math inline">\(X_t\)</span> has the Markov property if for any measurable function <span class="math inline">\(f\)</span> and times <span class="math inline">\(0 \leq s &lt; t\)</span>: <span class="math display">\[\mathbb{E}[f(X_t) | \mathcal{F}_s] = \mathbb{E}[f(X_t) | X_s]\]</span></p>
<p><strong>Theorem 4.5</strong>: Solutions to SDEs possess the strong Markov property.</p>
<p><strong>Definition 4.6 (Infinitesimal Generator)</strong>: For an SDE <span class="math inline">\(dX_t = \mu(X_t) dt + \sigma(X_t) dW_t\)</span>, the infinitesimal generator <span class="math inline">\(\mathcal{A}\)</span> is defined as: <span class="math display">\[\mathcal{A}f(x) = \mu(x) f'(x) + \frac{1}{2}\sigma^2(x) f''(x)\]</span></p>
<p>for functions <span class="math inline">\(f \in C^2(\mathbb{R})\)</span>.</p>
<p><strong>Theorem 4.7 (Dynkin’s Formula)</strong>: If <span class="math inline">\(\tau\)</span> is a stopping time with <span class="math inline">\(\mathbb{E}[\tau] &lt; \infty\)</span> and <span class="math inline">\(f \in C^2\)</span> with appropriate growth conditions, then: <span class="math display">\[\mathbb{E}[f(X_\tau)] = f(X_0) + \mathbb{E}\left[\int_0^\tau \mathcal{A}f(X_s) ds\right]\]</span></p>
</section>
<section id="feynman-kac-theorem" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="feynman-kac-theorem"><span class="header-section-number">4.4</span> Feynman-Kac Theorem</h3>
<p>One of the most profound connections in mathematical analysis links stochastic differential equations with partial differential equations through the Feynman-Kac theorem.</p>
<p><strong>Theorem 4.8 (Feynman-Kac)</strong>: Consider the PDE: <span class="math display">\[\frac{\partial u}{\partial t} + \mu(x) \frac{\partial u}{\partial x} + \frac{1}{2}\sigma^2(x) \frac{\partial^2 u}{\partial x^2} + c(x)u = 0\]</span></p>
<p>with terminal condition <span class="math inline">\(u(T,x) = g(x)\)</span>. If <span class="math inline">\(X_t\)</span> solves: <span class="math display">\[dX_t = \mu(X_t) dt + \sigma(X_t) dW_t, \quad X_0 = x\]</span></p>
<p>then: <span class="math display">\[u(t,x) = \mathbb{E}\left[g(X_T) \exp\left(-\int_t^T c(X_s) ds\right) \bigg| X_t = x\right]\]</span></p>
<p>This theorem provides the foundation for Monte Carlo methods in finance and connects probabilistic and analytical approaches to solving PDEs.</p>
<div id="cell-fig-feynman-kac" class="cell" data-fig-height="10" data-fig-width="15" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> feynman_kac_mc(x0, T, mu_func, sigma_func, c_func, g_func, n_paths<span class="op">=</span><span class="dv">10000</span>, n_steps<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Solve PDE using Feynman-Kac theorem via Monte Carlo.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns u(0, x0) = E[g(X_T) * exp(-∫₀ᵀ c(X_s) ds) | X_0 = x0]</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> n_steps</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Storage for paths and integrals</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((n_paths, n_steps <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    X[:, <span class="dv">0</span>] <span class="op">=</span> x0</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    integral_c <span class="op">=</span> np.zeros(n_paths)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate paths</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> i <span class="op">*</span> dt</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> sqrt_dt</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_paths):</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            mu <span class="op">=</span> mu_func(X[j, i], t)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            sigma <span class="op">=</span> sigma_func(X[j, i], t)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            X[j, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> X[j, i] <span class="op">+</span> mu <span class="op">*</span> dt <span class="op">+</span> sigma <span class="op">*</span> dW[j]</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Accumulate integral of c(X_s)</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>            integral_c[j] <span class="op">+=</span> c_func(X[j, i], t) <span class="op">*</span> dt</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Final payoff with discounting</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    payoffs <span class="op">=</span> g_func(X[:, <span class="op">-</span><span class="dv">1</span>]) <span class="op">*</span> np.exp(<span class="op">-</span>integral_c)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(payoffs), np.std(payoffs) <span class="op">/</span> np.sqrt(n_paths), X</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: Heat equation with killing</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="co"># PDE: ∂u/∂t + (1/2)∂²u/∂x² - ru = 0</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Terminal condition: u(T,x) = max(x - K, 0) (call option payoff)</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mu_heat(x, t):</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.0</span>  <span class="co"># No drift</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigma_heat(x, t):</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.0</span>  <span class="co"># Unit diffusion</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> c_heat(x, t):</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.05</span>  <span class="co"># Killing rate (interest rate)</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g_call(x, K<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(x <span class="op">-</span> K, <span class="dv">0</span>)  <span class="co"># Call option payoff</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>x_values_base <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">11</span>)</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>x_values_additional <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">1.5</span>])</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>x_values <span class="op">=</span> np.sort(np.unique(np.concatenate((x_values_base, x_values_additional))))</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>n_paths <span class="op">=</span> <span class="dv">50000</span></span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute solution at different initial points</span></span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>mc_solutions <span class="op">=</span> []</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>mc_errors <span class="op">=</span> []</span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>sample_paths <span class="op">=</span> {}</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x0 <span class="kw">in</span> x_values:</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>    u_mc, error, paths <span class="op">=</span> feynman_kac_mc(x0, T, mu_heat, sigma_heat, c_heat, </span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>                                       <span class="kw">lambda</span> x: g_call(x, K), n_paths)</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a>    mc_solutions.append(u_mc)</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a>    mc_errors.append(error)</span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store sample paths for visualization if x0 is close to 0.5, 1.0, or 1.5</span></span>
<span id="cb10-70"><a href="#cb10-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.isclose(x0, <span class="fl">0.5</span>):</span>
<span id="cb10-71"><a href="#cb10-71" aria-hidden="true" tabindex="-1"></a>        sample_paths[<span class="st">'0.5'</span>] <span class="op">=</span> paths</span>
<span id="cb10-72"><a href="#cb10-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> np.isclose(x0, <span class="fl">1.0</span>):</span>
<span id="cb10-73"><a href="#cb10-73" aria-hidden="true" tabindex="-1"></a>        sample_paths[<span class="st">'1.0'</span>] <span class="op">=</span> paths</span>
<span id="cb10-74"><a href="#cb10-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> np.isclose(x0, <span class="fl">1.5</span>):</span>
<span id="cb10-75"><a href="#cb10-75" aria-hidden="true" tabindex="-1"></a>        sample_paths[<span class="st">'1.5'</span>] <span class="op">=</span> paths</span>
<span id="cb10-76"><a href="#cb10-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-77"><a href="#cb10-77" aria-hidden="true" tabindex="-1"></a>mc_solutions <span class="op">=</span> np.array(mc_solutions)</span>
<span id="cb10-78"><a href="#cb10-78" aria-hidden="true" tabindex="-1"></a>mc_errors <span class="op">=</span> np.array(mc_errors)</span>
<span id="cb10-79"><a href="#cb10-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-80"><a href="#cb10-80" aria-hidden="true" tabindex="-1"></a><span class="co"># Analytical solution for comparison (Black-Scholes with r=0.05, σ=1, T=1)</span></span>
<span id="cb10-81"><a href="#cb10-81" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_call(S, K, T, r, sigma):</span>
<span id="cb10-82"><a href="#cb10-82" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb10-83"><a href="#cb10-83" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K) <span class="op">+</span> (r <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T) <span class="op">/</span> (sigma<span class="op">*</span>np.sqrt(T))</span>
<span id="cb10-84"><a href="#cb10-84" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma<span class="op">*</span>np.sqrt(T)</span>
<span id="cb10-85"><a href="#cb10-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S <span class="op">*</span> norm.cdf(d1) <span class="op">-</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> norm.cdf(d2)</span>
<span id="cb10-86"><a href="#cb10-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-87"><a href="#cb10-87" aria-hidden="true" tabindex="-1"></a>analytical_solutions <span class="op">=</span> black_scholes_call(x_values, K, T, <span class="fl">0.05</span>, <span class="fl">1.0</span>)</span>
<span id="cb10-88"><a href="#cb10-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-89"><a href="#cb10-89" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb10-90"><a href="#cb10-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-91"><a href="#cb10-91" aria-hidden="true" tabindex="-1"></a><span class="co"># Solution comparison</span></span>
<span id="cb10-92"><a href="#cb10-92" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(x_values, analytical_solutions, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">'Analytical (Black-Scholes)'</span>)</span>
<span id="cb10-93"><a href="#cb10-93" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].errorbar(x_values, mc_solutions, yerr<span class="op">=</span><span class="dv">2</span><span class="op">*</span>mc_errors, fmt<span class="op">=</span><span class="st">'bo-'</span>, </span>
<span id="cb10-94"><a href="#cb10-94" aria-hidden="true" tabindex="-1"></a>                   capsize<span class="op">=</span><span class="dv">3</span>, capthick<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Monte Carlo ± 2σ'</span>)</span>
<span id="cb10-95"><a href="#cb10-95" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'PDE Solution: u(0,x) = E[max(X(T)-K,0)e^{-rT}]'</span>)</span>
<span id="cb10-96"><a href="#cb10-96" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Initial value x'</span>)</span>
<span id="cb10-97"><a href="#cb10-97" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'u(0,x)'</span>)</span>
<span id="cb10-98"><a href="#cb10-98" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb10-99"><a href="#cb10-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-100"><a href="#cb10-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-101"><a href="#cb10-101" aria-hidden="true" tabindex="-1"></a><span class="co"># Error analysis</span></span>
<span id="cb10-102"><a href="#cb10-102" aria-hidden="true" tabindex="-1"></a>relative_errors <span class="op">=</span> np.<span class="bu">abs</span>(mc_solutions <span class="op">-</span> analytical_solutions) <span class="op">/</span> analytical_solutions</span>
<span id="cb10-103"><a href="#cb10-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].semilogy(x_values, relative_errors, <span class="st">'go-'</span>, markersize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb10-104"><a href="#cb10-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Relative Error: |MC - Analytical| / Analytical'</span>)</span>
<span id="cb10-105"><a href="#cb10-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Initial value x'</span>)</span>
<span id="cb10-106"><a href="#cb10-106" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Relative Error'</span>)</span>
<span id="cb10-107"><a href="#cb10-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-108"><a href="#cb10-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-109"><a href="#cb10-109" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample paths for different initial conditions</span></span>
<span id="cb10-110"><a href="#cb10-110" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, <span class="dv">1001</span>)</span>
<span id="cb10-111"><a href="#cb10-111" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'red'</span>, <span class="st">'green'</span>]</span>
<span id="cb10-112"><a href="#cb10-112" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (x0_str, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>([<span class="st">'0.5'</span>, <span class="st">'1.0'</span>, <span class="st">'1.5'</span>], colors)):</span>
<span id="cb10-113"><a href="#cb10-113" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> sample_paths[x0_str]</span>
<span id="cb10-114"><a href="#cb10-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot subset of paths</span></span>
<span id="cb10-115"><a href="#cb10-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">min</span>(<span class="dv">100</span>, paths.shape[<span class="dv">0</span>]), <span class="dv">10</span>):</span>
<span id="cb10-116"><a href="#cb10-116" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, paths[j], color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.3</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb10-117"><a href="#cb10-117" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight one path</span></span>
<span id="cb10-118"><a href="#cb10-118" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, paths[<span class="dv">0</span>], color<span class="op">=</span>color, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'X₀ = </span><span class="sc">{</span>x0<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-119"><a href="#cb10-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-120"><a href="#cb10-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span>K, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="ss">f'Strike K = </span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-121"><a href="#cb10-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Sample Paths for Different Initial Conditions'</span>)</span>
<span id="cb10-122"><a href="#cb10-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb10-123"><a href="#cb10-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'X(t)'</span>)</span>
<span id="cb10-124"><a href="#cb10-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb10-125"><a href="#cb10-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-126"><a href="#cb10-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-127"><a href="#cb10-127" aria-hidden="true" tabindex="-1"></a><span class="co"># Terminal distribution and payoff</span></span>
<span id="cb10-128"><a href="#cb10-128" aria-hidden="true" tabindex="-1"></a>final_values <span class="op">=</span> sample_paths[<span class="st">'1.0'</span>][:, <span class="op">-</span><span class="dv">1</span>]  <span class="co"># Terminal values starting from x=1</span></span>
<span id="cb10-129"><a href="#cb10-129" aria-hidden="true" tabindex="-1"></a>payoffs <span class="op">=</span> np.maximum(final_values <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="cb10-130"><a href="#cb10-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-131"><a href="#cb10-131" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(final_values, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, color<span class="op">=</span><span class="st">'skyblue'</span>, </span>
<span id="cb10-132"><a href="#cb10-132" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">'X(T) distribution'</span>)</span>
<span id="cb10-133"><a href="#cb10-133" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(payoffs, bins<span class="op">=</span><span class="dv">50</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, color<span class="op">=</span><span class="st">'lightcoral'</span>, </span>
<span id="cb10-134"><a href="#cb10-134" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">'Payoff distribution'</span>)</span>
<span id="cb10-135"><a href="#cb10-135" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axvline(x<span class="op">=</span>K, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="ss">f'Strike K = </span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb10-136"><a href="#cb10-136" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Terminal Distribution and Payoff (X₀ = 1.0)'</span>)</span>
<span id="cb10-137"><a href="#cb10-137" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Value'</span>)</span>
<span id="cb10-138"><a href="#cb10-138" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb10-139"><a href="#cb10-139" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb10-140"><a href="#cb10-140" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-141"><a href="#cb10-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-142"><a href="#cb10-142" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-143"><a href="#cb10-143" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb10-144"><a href="#cb10-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-145"><a href="#cb10-145" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Monte Carlo estimate at x=1.0: </span><span class="sc">{</span>mc_solutions[x_values <span class="op">==</span> <span class="fl">1.0</span>][<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span><span class="dv">2</span><span class="op">*</span>mc_errors[x_values <span class="op">==</span> <span class="fl">1.0</span>][<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb10-146"><a href="#cb10-146" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Analytical solution at x=1.0:  </span><span class="sc">{</span>analytical_solutions[x_values <span class="op">==</span> <span class="fl">1.0</span>][<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb10-147"><a href="#cb10-147" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Relative error: </span><span class="sc">{</span>relative_errors[x_values <span class="op">==</span> <span class="fl">1.0</span>][<span class="dv">0</span>]<span class="sc">:.2%}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-feynman-kac" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-feynman-kac-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-feynman-kac-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-feynman-kac-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Feynman-Kac theorem illustration: PDE solution via Monte Carlo
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Monte Carlo estimate at x=1.0: 0.3831 ± 0.0050
Analytical solution at x=1.0:  0.3984
Relative error: 3.84%</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-numerical-methods" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-numerical-methods"><span class="header-section-number">5</span> Numerical Methods for SDEs</h2>
<p>While analytical solutions to SDEs exist only in special cases, numerical methods provide essential tools for practical applications. We examine the fundamental discretization schemes and their convergence properties.</p>
<section id="euler-maruyama-scheme" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="euler-maruyama-scheme"><span class="header-section-number">5.1</span> Euler-Maruyama Scheme</h3>
<p>The most basic numerical method for SDEs is the Euler-Maruyama scheme, which discretizes the SDE:</p>
<p><span class="math display">\[dX_t = \mu(t, X_t) dt + \sigma(t, X_t) dW_t\]</span></p>
<p>using the approximation: <span class="math display">\[X_{n+1} = X_n + \mu(t_n, X_n) \Delta t + \sigma(t_n, X_n) \Delta W_n\]</span></p>
<p>where <span class="math inline">\(\Delta W_n = W_{t_{n+1}} - W_{t_n} \sim \mathcal{N}(0, \Delta t)\)</span> are independent Gaussian increments.</p>
<p><strong>Theorem 5.1 (Strong Convergence of Euler-Maruyama)</strong>: Under Lipschitz and linear growth conditions, the Euler-Maruyama scheme has strong convergence order 0.5: <span class="math display">\[\mathbb{E}[|X_T - X_T^{\Delta t}|] = O(\sqrt{\Delta t})\]</span></p>
<p>where <span class="math inline">\(X_T^{\Delta t}\)</span> is the numerical approximation at time <span class="math inline">\(T\)</span>.</p>
</section>
<section id="milstein-scheme" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="milstein-scheme"><span class="header-section-number">5.2</span> Milstein Scheme</h3>
<p>The Milstein scheme improves upon Euler-Maruyama by including an additional correction term derived from Itô’s lemma, achieving higher-order strong convergence.</p>
<p><strong>Definition 5.2 (Milstein Scheme)</strong>: The Milstein discretization is: <span class="math display">\[X_{n+1} = X_n + \mu(t_n, X_n) \Delta t + \sigma(t_n, X_n) \Delta W_n + \frac{1}{2}\sigma(t_n, X_n)\sigma'(t_n, X_n)[(\Delta W_n)^2 - \Delta t]\]</span></p>
<p>where <span class="math inline">\(\sigma'(t,x) = \frac{\partial \sigma}{\partial x}(t,x)\)</span>.</p>
<p><strong>Theorem 5.3 (Strong Convergence of Milstein)</strong>: Under appropriate regularity conditions, the Milstein scheme has strong convergence order 1.0: <span class="math display">\[\mathbb{E}[|X_T - X_T^{\Delta t}|] = O(\Delta t)\]</span></p>
<div id="cell-fig-numerical-methods" class="cell" data-fig-height="14" data-fig-width="18" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">@njit</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler_maruyama_simulation(x0, T, N, mu_params, sigma_params, n_paths):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Efficient Euler-Maruyama simulation using Numba.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes linear drift μ(x) = a*x + b and linear diffusion σ(x) = c*x + d.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> mu_params</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    c, d <span class="op">=</span> sigma_params</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    X[:, <span class="dv">0</span>] <span class="op">=</span> x0</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> sqrt_dt</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        X_curr <span class="op">=</span> X[:, i]</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> a <span class="op">*</span> X_curr <span class="op">+</span> b</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> c <span class="op">*</span> X_curr <span class="op">+</span> d</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        X[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> X_curr <span class="op">+</span> mu <span class="op">*</span> dt <span class="op">+</span> sigma <span class="op">*</span> dW</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="at">@njit</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> milstein_simulation(x0, T, N, mu_params, sigma_params, n_paths):</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="co">    Efficient Milstein simulation using Numba.</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes linear drift μ(x) = a*x + b and linear diffusion σ(x) = c*x + d.</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> mu_params</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>    c, d <span class="op">=</span> sigma_params</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>    X[:, <span class="dv">0</span>] <span class="op">=</span> x0</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> sqrt_dt</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        X_curr <span class="op">=</span> X[:, i]</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> a <span class="op">*</span> X_curr <span class="op">+</span> b</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> c <span class="op">*</span> X_curr <span class="op">+</span> d</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        sigma_prime <span class="op">=</span> c  <span class="co"># d/dx(c*x + d) = c</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Milstein correction term</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>        correction <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">*</span> sigma_prime <span class="op">*</span> (dW<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> dt)</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>        X[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> X_curr <span class="op">+</span> mu <span class="op">*</span> dt <span class="op">+</span> sigma <span class="op">*</span> dW <span class="op">+</span> correction</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analytical_solution_gbm(x0, mu, sigma, T, N, n_paths):</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Analytical solution for geometric Brownian motion."""</span></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate Brownian motion</span></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>    dW <span class="op">=</span> np.random.randn(n_paths, N) <span class="op">*</span> np.sqrt(dt)</span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> np.column_stack([np.zeros(n_paths), np.cumsum(dW, axis<span class="op">=</span><span class="dv">1</span>)])</span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exact solution: X(t) = x0 * exp((mu - sigma²/2)t + sigma*W(t))</span></span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a>    X_exact <span class="op">=</span> x0 <span class="op">*</span> np.exp((mu <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> t[np.newaxis, :] <span class="op">+</span> sigma <span class="op">*</span> W)</span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X_exact</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Test case: Geometric Brownian Motion dX = μX dt + σX dW</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters for linear approximation: μ(x) = μ*x, σ(x) = σ*x</span></span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a>mu_params <span class="op">=</span> (mu, <span class="fl">0.0</span>)  <span class="co"># a=μ, b=0</span></span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>sigma_params <span class="op">=</span> (sigma, <span class="fl">0.0</span>)  <span class="co"># c=σ, d=0</span></span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-78"><a href="#cb12-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Convergence study</span></span>
<span id="cb12-79"><a href="#cb12-79" aria-hidden="true" tabindex="-1"></a>step_sizes <span class="op">=</span> np.array([<span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">4000</span>, <span class="dv">8000</span>, <span class="dv">16000</span>])</span>
<span id="cb12-80"><a href="#cb12-80" aria-hidden="true" tabindex="-1"></a>n_paths_convergence <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb12-81"><a href="#cb12-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-82"><a href="#cb12-82" aria-hidden="true" tabindex="-1"></a>errors_euler <span class="op">=</span> []</span>
<span id="cb12-83"><a href="#cb12-83" aria-hidden="true" tabindex="-1"></a>errors_milstein <span class="op">=</span> []</span>
<span id="cb12-84"><a href="#cb12-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-85"><a href="#cb12-85" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-86"><a href="#cb12-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-87"><a href="#cb12-87" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">14</span>))</span>
<span id="cb12-88"><a href="#cb12-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-89"><a href="#cb12-89" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convergence Analysis:"</span>)</span>
<span id="cb12-90"><a href="#cb12-90" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"N</span><span class="ch">\t\t</span><span class="st">Euler Error</span><span class="ch">\t\t</span><span class="st">Milstein Error</span><span class="ch">\t\t</span><span class="st">Ratio"</span>)</span>
<span id="cb12-91"><a href="#cb12-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb12-92"><a href="#cb12-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-93"><a href="#cb12-93" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> N <span class="kw">in</span> step_sizes:</span>
<span id="cb12-94"><a href="#cb12-94" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set random seed for fair comparison</span></span>
<span id="cb12-95"><a href="#cb12-95" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-96"><a href="#cb12-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-97"><a href="#cb12-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Analytical solution</span></span>
<span id="cb12-98"><a href="#cb12-98" aria-hidden="true" tabindex="-1"></a>    X_exact <span class="op">=</span> analytical_solution_gbm(x0, mu, sigma, T, N, n_paths_convergence)</span>
<span id="cb12-99"><a href="#cb12-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-100"><a href="#cb12-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reset seed for numerical methods</span></span>
<span id="cb12-101"><a href="#cb12-101" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-102"><a href="#cb12-102" aria-hidden="true" tabindex="-1"></a>    X_euler <span class="op">=</span> euler_maruyama_simulation(x0, T, N, mu_params, sigma_params, n_paths_convergence)</span>
<span id="cb12-103"><a href="#cb12-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-104"><a href="#cb12-104" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-105"><a href="#cb12-105" aria-hidden="true" tabindex="-1"></a>    X_milstein <span class="op">=</span> milstein_simulation(x0, T, N, mu_params, sigma_params, n_paths_convergence)</span>
<span id="cb12-106"><a href="#cb12-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-107"><a href="#cb12-107" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute strong errors (L1 norm at terminal time)</span></span>
<span id="cb12-108"><a href="#cb12-108" aria-hidden="true" tabindex="-1"></a>    error_euler <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(X_euler[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> X_exact[:, <span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb12-109"><a href="#cb12-109" aria-hidden="true" tabindex="-1"></a>    error_milstein <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(X_milstein[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> X_exact[:, <span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb12-110"><a href="#cb12-110" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-111"><a href="#cb12-111" aria-hidden="true" tabindex="-1"></a>    errors_euler.append(error_euler)</span>
<span id="cb12-112"><a href="#cb12-112" aria-hidden="true" tabindex="-1"></a>    errors_milstein.append(error_milstein)</span>
<span id="cb12-113"><a href="#cb12-113" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-114"><a href="#cb12-114" aria-hidden="true" tabindex="-1"></a>    ratio <span class="op">=</span> error_euler <span class="op">/</span> error_milstein <span class="cf">if</span> error_milstein <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.inf</span>
<span id="cb12-115"><a href="#cb12-115" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>N<span class="sc">}</span><span class="ch">\t\t</span><span class="sc">{</span>error_euler<span class="sc">:.6f}</span><span class="ch">\t\t</span><span class="sc">{</span>error_milstein<span class="sc">:.6f}</span><span class="ch">\t\t</span><span class="sc">{</span>ratio<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb12-116"><a href="#cb12-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-117"><a href="#cb12-117" aria-hidden="true" tabindex="-1"></a><span class="co"># Convergence plots</span></span>
<span id="cb12-118"><a href="#cb12-118" aria-hidden="true" tabindex="-1"></a>dt_values <span class="op">=</span> T <span class="op">/</span> step_sizes</span>
<span id="cb12-119"><a href="#cb12-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].loglog(dt_values, errors_euler, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'Euler-Maruyama'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb12-120"><a href="#cb12-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].loglog(dt_values, errors_milstein, <span class="st">'rs-'</span>, label<span class="op">=</span><span class="st">'Milstein'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb12-121"><a href="#cb12-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-122"><a href="#cb12-122" aria-hidden="true" tabindex="-1"></a><span class="co"># Theoretical convergence rates</span></span>
<span id="cb12-123"><a href="#cb12-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].loglog(dt_values, <span class="fl">0.1</span> <span class="op">*</span> np.sqrt(dt_values), <span class="st">'b--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'O(√Δt)'</span>)</span>
<span id="cb12-124"><a href="#cb12-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].loglog(dt_values, <span class="fl">0.02</span> <span class="op">*</span> dt_values, <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'O(Δt)'</span>)</span>
<span id="cb12-125"><a href="#cb12-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-126"><a href="#cb12-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Step Size Δt'</span>)</span>
<span id="cb12-127"><a href="#cb12-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Strong Error E[|X_T - X_T^Δt|]'</span>)</span>
<span id="cb12-128"><a href="#cb12-128" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Strong Convergence Rates'</span>)</span>
<span id="cb12-129"><a href="#cb12-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb12-130"><a href="#cb12-130" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb12-131"><a href="#cb12-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-132"><a href="#cb12-132" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample path comparison</span></span>
<span id="cb12-133"><a href="#cb12-133" aria-hidden="true" tabindex="-1"></a>N_demo <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb12-134"><a href="#cb12-134" aria-hidden="true" tabindex="-1"></a>n_paths_demo <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb12-135"><a href="#cb12-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-136"><a href="#cb12-136" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-137"><a href="#cb12-137" aria-hidden="true" tabindex="-1"></a>X_exact_demo <span class="op">=</span> analytical_solution_gbm(x0, mu, sigma, T, N_demo, n_paths_demo)</span>
<span id="cb12-138"><a href="#cb12-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-139"><a href="#cb12-139" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-140"><a href="#cb12-140" aria-hidden="true" tabindex="-1"></a>X_euler_demo <span class="op">=</span> euler_maruyama_simulation(x0, T, N_demo, mu_params, sigma_params, n_paths_demo)</span>
<span id="cb12-141"><a href="#cb12-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-142"><a href="#cb12-142" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-143"><a href="#cb12-143" aria-hidden="true" tabindex="-1"></a>X_milstein_demo <span class="op">=</span> milstein_simulation(x0, T, N_demo, mu_params, sigma_params, n_paths_demo)</span>
<span id="cb12-144"><a href="#cb12-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-145"><a href="#cb12-145" aria-hidden="true" tabindex="-1"></a>t_demo <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N_demo <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-146"><a href="#cb12-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-147"><a href="#cb12-147" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot a few sample paths</span></span>
<span id="cb12-148"><a href="#cb12-148" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">5</span>, n_paths_demo)):</span>
<span id="cb12-149"><a href="#cb12-149" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_demo, X_exact_demo[i], <span class="st">'k-'</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-150"><a href="#cb12-150" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_demo, X_euler_demo[i], <span class="st">'b--'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-151"><a href="#cb12-151" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_demo, X_milstein_demo[i], <span class="st">'r:'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-152"><a href="#cb12-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-153"><a href="#cb12-153" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot([], [], <span class="st">'k-'</span>, label<span class="op">=</span><span class="st">'Exact'</span>)</span>
<span id="cb12-154"><a href="#cb12-154" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot([], [], <span class="st">'b--'</span>, label<span class="op">=</span><span class="st">'Euler-Maruyama'</span>)</span>
<span id="cb12-155"><a href="#cb12-155" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot([], [], <span class="st">'r:'</span>, label<span class="op">=</span><span class="st">'Milstein'</span>)</span>
<span id="cb12-156"><a href="#cb12-156" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Sample Path Comparison'</span>)</span>
<span id="cb12-157"><a href="#cb12-157" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb12-158"><a href="#cb12-158" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'X(t)'</span>)</span>
<span id="cb12-159"><a href="#cb12-159" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb12-160"><a href="#cb12-160" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb12-161"><a href="#cb12-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-162"><a href="#cb12-162" aria-hidden="true" tabindex="-1"></a><span class="co"># Error distributions at terminal time</span></span>
<span id="cb12-163"><a href="#cb12-163" aria-hidden="true" tabindex="-1"></a>errors_euler_paths <span class="op">=</span> X_euler_demo[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> X_exact_demo[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-164"><a href="#cb12-164" aria-hidden="true" tabindex="-1"></a>errors_milstein_paths <span class="op">=</span> X_milstein_demo[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> X_exact_demo[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-165"><a href="#cb12-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-166"><a href="#cb12-166" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].hist(errors_euler_paths, bins<span class="op">=</span><span class="dv">30</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb12-167"><a href="#cb12-167" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="ss">f'Euler (std=</span><span class="sc">{</span>np<span class="sc">.</span>std(errors_euler_paths)<span class="sc">:.4f}</span><span class="ss">)'</span>)</span>
<span id="cb12-168"><a href="#cb12-168" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].hist(errors_milstein_paths, bins<span class="op">=</span><span class="dv">30</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb12-169"><a href="#cb12-169" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="ss">f'Milstein (std=</span><span class="sc">{</span>np<span class="sc">.</span>std(errors_milstein_paths)<span class="sc">:.4f}</span><span class="ss">)'</span>)</span>
<span id="cb12-170"><a href="#cb12-170" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb12-171"><a href="#cb12-171" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Error Distribution at Terminal Time'</span>)</span>
<span id="cb12-172"><a href="#cb12-172" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Error: X_T^numerical - X_T^exact'</span>)</span>
<span id="cb12-173"><a href="#cb12-173" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb12-174"><a href="#cb12-174" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb12-175"><a href="#cb12-175" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb12-176"><a href="#cb12-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-177"><a href="#cb12-177" aria-hidden="true" tabindex="-1"></a><span class="co"># Weak convergence: Compare distributions</span></span>
<span id="cb12-178"><a href="#cb12-178" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(X_exact_demo[:, <span class="op">-</span><span class="dv">1</span>], bins<span class="op">=</span><span class="dv">40</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb12-179"><a href="#cb12-179" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'black'</span>, label<span class="op">=</span><span class="st">'Exact'</span>)</span>
<span id="cb12-180"><a href="#cb12-180" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(X_euler_demo[:, <span class="op">-</span><span class="dv">1</span>], bins<span class="op">=</span><span class="dv">40</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb12-181"><a href="#cb12-181" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'Euler-Maruyama'</span>)</span>
<span id="cb12-182"><a href="#cb12-182" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(X_milstein_demo[:, <span class="op">-</span><span class="dv">1</span>], bins<span class="op">=</span><span class="dv">40</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb12-183"><a href="#cb12-183" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Milstein'</span>)</span>
<span id="cb12-184"><a href="#cb12-184" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Terminal Distribution Comparison'</span>)</span>
<span id="cb12-185"><a href="#cb12-185" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'X(T)'</span>)</span>
<span id="cb12-186"><a href="#cb12-186" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb12-187"><a href="#cb12-187" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb12-188"><a href="#cb12-188" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb12-189"><a href="#cb12-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-190"><a href="#cb12-190" aria-hidden="true" tabindex="-1"></a><span class="co"># Computational cost analysis</span></span>
<span id="cb12-191"><a href="#cb12-191" aria-hidden="true" tabindex="-1"></a>step_sizes_cost <span class="op">=</span> np.array([<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">5000</span>])</span>
<span id="cb12-192"><a href="#cb12-192" aria-hidden="true" tabindex="-1"></a>n_paths_cost <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb12-193"><a href="#cb12-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-194"><a href="#cb12-194" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb12-195"><a href="#cb12-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-196"><a href="#cb12-196" aria-hidden="true" tabindex="-1"></a>times_euler <span class="op">=</span> []</span>
<span id="cb12-197"><a href="#cb12-197" aria-hidden="true" tabindex="-1"></a>times_milstein <span class="op">=</span> []</span>
<span id="cb12-198"><a href="#cb12-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-199"><a href="#cb12-199" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> N <span class="kw">in</span> step_sizes_cost:</span>
<span id="cb12-200"><a href="#cb12-200" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Time Euler-Maruyama</span></span>
<span id="cb12-201"><a href="#cb12-201" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb12-202"><a href="#cb12-202" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):  <span class="co"># Average over multiple runs</span></span>
<span id="cb12-203"><a href="#cb12-203" aria-hidden="true" tabindex="-1"></a>        np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-204"><a href="#cb12-204" aria-hidden="true" tabindex="-1"></a>        X_euler_cost <span class="op">=</span> euler_maruyama_simulation(x0, T, N, mu_params, sigma_params, n_paths_cost)</span>
<span id="cb12-205"><a href="#cb12-205" aria-hidden="true" tabindex="-1"></a>    time_euler <span class="op">=</span> (time.time() <span class="op">-</span> start_time) <span class="op">/</span> <span class="dv">10</span></span>
<span id="cb12-206"><a href="#cb12-206" aria-hidden="true" tabindex="-1"></a>    times_euler.append(time_euler)</span>
<span id="cb12-207"><a href="#cb12-207" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-208"><a href="#cb12-208" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Time Milstein</span></span>
<span id="cb12-209"><a href="#cb12-209" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb12-210"><a href="#cb12-210" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):  <span class="co"># Average over multiple runs</span></span>
<span id="cb12-211"><a href="#cb12-211" aria-hidden="true" tabindex="-1"></a>        np.random.seed(<span class="dv">42</span>)</span>
<span id="cb12-212"><a href="#cb12-212" aria-hidden="true" tabindex="-1"></a>        X_milstein_cost <span class="op">=</span> milstein_simulation(x0, T, N, mu_params, sigma_params, n_paths_cost)</span>
<span id="cb12-213"><a href="#cb12-213" aria-hidden="true" tabindex="-1"></a>    time_milstein <span class="op">=</span> (time.time() <span class="op">-</span> start_time) <span class="op">/</span> <span class="dv">10</span></span>
<span id="cb12-214"><a href="#cb12-214" aria-hidden="true" tabindex="-1"></a>    times_milstein.append(time_milstein)</span>
<span id="cb12-215"><a href="#cb12-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-216"><a href="#cb12-216" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].loglog(step_sizes_cost, times_euler, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'Euler-Maruyama'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb12-217"><a href="#cb12-217" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].loglog(step_sizes_cost, times_milstein, <span class="st">'rs-'</span>, label<span class="op">=</span><span class="st">'Milstein'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb12-218"><a href="#cb12-218" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Number of Steps N'</span>)</span>
<span id="cb12-219"><a href="#cb12-219" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Computation Time (seconds)'</span>)</span>
<span id="cb12-220"><a href="#cb12-220" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Computational Cost Comparison'</span>)</span>
<span id="cb12-221"><a href="#cb12-221" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb12-222"><a href="#cb12-222" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb12-223"><a href="#cb12-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-224"><a href="#cb12-224" aria-hidden="true" tabindex="-1"></a><span class="co"># Efficiency comparison: Error vs computational cost</span></span>
<span id="cb12-225"><a href="#cb12-225" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].loglog(times_euler[<span class="op">-</span><span class="bu">len</span>(errors_euler):], errors_euler, <span class="st">'bo-'</span>, </span>
<span id="cb12-226"><a href="#cb12-226" aria-hidden="true" tabindex="-1"></a>                 label<span class="op">=</span><span class="st">'Euler-Maruyama'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb12-227"><a href="#cb12-227" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].loglog(times_milstein[<span class="op">-</span><span class="bu">len</span>(errors_milstein):], errors_milstein, <span class="st">'rs-'</span>, </span>
<span id="cb12-228"><a href="#cb12-228" aria-hidden="true" tabindex="-1"></a>                 label<span class="op">=</span><span class="st">'Milstein'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb12-229"><a href="#cb12-229" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Computation Time (seconds)'</span>)</span>
<span id="cb12-230"><a href="#cb12-230" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Strong Error'</span>)</span>
<span id="cb12-231"><a href="#cb12-231" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Efficiency: Error vs Computational Cost'</span>)</span>
<span id="cb12-232"><a href="#cb12-232" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb12-233"><a href="#cb12-233" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb12-234"><a href="#cb12-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-235"><a href="#cb12-235" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb12-236"><a href="#cb12-236" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb12-237"><a href="#cb12-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-238"><a href="#cb12-238" aria-hidden="true" tabindex="-1"></a><span class="co"># Summary statistics</span></span>
<span id="cb12-239"><a href="#cb12-239" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Final comparison (N=</span><span class="sc">{</span>step_sizes[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">):"</span>)</span>
<span id="cb12-240"><a href="#cb12-240" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Euler-Maruyama error: </span><span class="sc">{</span>errors_euler[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb12-241"><a href="#cb12-241" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Milstein error: </span><span class="sc">{</span>errors_milstein[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb12-242"><a href="#cb12-242" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Improvement factor: </span><span class="sc">{</span>errors_euler[<span class="op">-</span><span class="dv">1</span>]<span class="op">/</span>errors_milstein[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss">x"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Convergence Analysis:
N       Euler Error     Milstein Error      Ratio
------------------------------------------------------------
1000        0.371105        0.366835        1.01
2000        0.368514        0.367438        1.00
4000        0.368665        0.365833        1.01
8000        0.369580        0.366111        1.01
16000       0.372657        0.371818        1.00</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-numerical-methods" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-numerical-methods-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-numerical-methods-output-2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-numerical-methods-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Comparison of numerical methods for SDEs: Euler-Maruyama vs Milstein schemes
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Final comparison (N=16000):
Euler-Maruyama error: 0.372657
Milstein error: 0.371818
Improvement factor: 1.00x</code></pre>
</div>
</div>
</section>
<section id="higher-order-methods-and-multi-dimensional-extensions" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="higher-order-methods-and-multi-dimensional-extensions"><span class="header-section-number">5.3</span> Higher-Order Methods and Multi-dimensional Extensions</h3>
<p>For multi-dimensional SDEs: <span class="math display">\[d\mathbf{X}_t = \boldsymbol{\mu}(t, \mathbf{X}_t) dt + \boldsymbol{\sigma}(t, \mathbf{X}_t) d\mathbf{W}_t\]</span></p>
<p>the schemes generalize naturally, but the Milstein scheme requires knowledge of mixed derivatives of the diffusion matrix.</p>
<p><strong>Definition 5.4 (Multi-dimensional Euler-Maruyama)</strong>: <span class="math display">\[\mathbf{X}_{n+1} = \mathbf{X}_n + \boldsymbol{\mu}(t_n, \mathbf{X}_n) \Delta t + \boldsymbol{\sigma}(t_n, \mathbf{X}_n) \Delta \mathbf{W}_n\]</span></p>
<p>where <span class="math inline">\(\Delta \mathbf{W}_n\)</span> are independent <span class="math inline">\(m\)</span>-dimensional Gaussian vectors.</p>
</section>
<section id="weak-vs-strong-convergence" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="weak-vs-strong-convergence"><span class="header-section-number">5.4</span> Weak vs Strong Convergence</h3>
<p><strong>Definition 5.5</strong>: - <strong>Strong convergence</strong> measures pathwise accuracy: <span class="math inline">\(\mathbb{E}[|X_T - X_T^{\Delta t}|] \to 0\)</span> - <strong>Weak convergence</strong> measures distributional accuracy: <span class="math inline">\(|\mathbb{E}[f(X_T)] - \mathbb{E}[f(X_T^{\Delta t})]| \to 0\)</span></p>
<p>For many applications (e.g., option pricing), weak convergence is sufficient and can be achieved with larger step sizes.</p>
<div id="cell-fig-weak-vs-strong" class="cell" data-fig-height="10" data-fig-width="15" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> weak_convergence_study(payoff_func, step_sizes, n_paths<span class="op">=</span><span class="dv">50000</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Study weak convergence for a given payoff function."""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    weak_errors_euler <span class="op">=</span> []</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    weak_errors_milstein <span class="op">=</span> []</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reference solution with very fine discretization</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    N_ref <span class="op">=</span> <span class="dv">32000</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    X_ref <span class="op">=</span> euler_maruyama_simulation(x0, T, N_ref, mu_params, sigma_params, n_paths)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    exact_expectation <span class="op">=</span> np.mean(payoff_func(X_ref[:, <span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> N <span class="kw">in</span> step_sizes:</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Euler-Maruyama</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        np.random.seed(<span class="dv">42</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        X_euler <span class="op">=</span> euler_maruyama_simulation(x0, T, N, mu_params, sigma_params, n_paths)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        euler_expectation <span class="op">=</span> np.mean(payoff_func(X_euler[:, <span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        weak_error_euler <span class="op">=</span> <span class="bu">abs</span>(euler_expectation <span class="op">-</span> exact_expectation)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        weak_errors_euler.append(weak_error_euler)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Milstein</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        np.random.seed(<span class="dv">42</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        X_milstein <span class="op">=</span> milstein_simulation(x0, T, N, mu_params, sigma_params, n_paths)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        milstein_expectation <span class="op">=</span> np.mean(payoff_func(X_milstein[:, <span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        weak_error_milstein <span class="op">=</span> <span class="bu">abs</span>(milstein_expectation <span class="op">-</span> exact_expectation)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        weak_errors_milstein.append(weak_error_milstein)</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> weak_errors_euler, weak_errors_milstein, exact_expectation</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Different payoff functions</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> linear_payoff(x):</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quadratic_payoff(x):</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> call_option_payoff(x, K<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(x <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> digital_option_payoff(x, K<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x <span class="op">&gt;</span> K).astype(<span class="bu">float</span>)</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>step_sizes_weak <span class="op">=</span> np.array([<span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">2000</span>])</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>payoff_functions <span class="op">=</span> [</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    (linear_payoff, <span class="st">"Linear: E[X(T)]"</span>),</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    (quadratic_payoff, <span class="st">"Quadratic: E[X²(T)]"</span>),</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> x: call_option_payoff(x, <span class="fl">1.0</span>), <span class="st">"Call Option: E[(X(T)-1)⁺]"</span>),</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> x: digital_option_payoff(x, <span class="fl">1.0</span>), <span class="st">"Digital Option: P(X(T)&gt;1)"</span>)</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.flatten()</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (payoff_func, title) <span class="kw">in</span> <span class="bu">enumerate</span>(payoff_functions):</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>    weak_errors_euler, weak_errors_milstein, exact_value <span class="op">=</span> weak_convergence_study(</span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>        payoff_func, step_sizes_weak, n_paths<span class="op">=</span><span class="dv">20000</span>)</span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>    dt_values <span class="op">=</span> T <span class="op">/</span> step_sizes_weak</span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>    axes[i].loglog(dt_values, weak_errors_euler, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'Euler-Maruyama'</span>, markersize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>    axes[i].loglog(dt_values, weak_errors_milstein, <span class="st">'rs-'</span>, label<span class="op">=</span><span class="st">'Milstein'</span>, markersize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Theoretical weak convergence rates (typically one order higher than strong)</span></span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a>    axes[i].loglog(dt_values, <span class="fl">0.01</span> <span class="op">*</span> dt_values, <span class="st">'b--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'O(Δt)'</span>)</span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a>    axes[i].loglog(dt_values, <span class="fl">0.001</span> <span class="op">*</span> dt_values<span class="op">**</span><span class="dv">2</span>, <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'O(Δt²)'</span>)</span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a>    axes[i].set_xlabel(<span class="st">'Step Size Δt'</span>)</span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a>    axes[i].set_ylabel(<span class="st">'Weak Error |E[f(X_T)] - E[f(X_T^Δt)]|'</span>)</span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a>    axes[i].set_title(<span class="ss">f'</span><span class="sc">{</span>title<span class="sc">}</span><span class="ch">\n</span><span class="ss">(Exact: </span><span class="sc">{</span>exact_value<span class="sc">:.4f}</span><span class="ss">)'</span>)</span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a>    axes[i].legend()</span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a>    axes[i].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-weak-vs-strong" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-weak-vs-strong-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-weak-vs-strong-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-weak-vs-strong-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Weak vs strong convergence illustration
</figcaption>
</figure>
</div>
</div>
</div>
<p>The numerical analysis demonstrates several key insights:</p>
<ol type="1">
<li><strong>Strong convergence</strong>: Euler-Maruyama achieves <span class="math inline">\(O(\sqrt{\Delta t})\)</span> while Milstein achieves <span class="math inline">\(O(\Delta t)\)</span></li>
<li><strong>Weak convergence</strong>: Both methods typically achieve one order higher convergence for smooth payoffs</li>
<li><strong>Computational cost</strong>: Milstein requires additional derivative calculations but provides better accuracy</li>
<li><strong>Practical choice</strong>: The optimal method depends on the specific application and computational budget</li>
</ol>
<p>These numerical methods provide the computational foundation for practical SDE applications in finance, engineering, and machine learning. In the next section, we explore their application to financial modeling and option pricing.</p>
</section>
</section>
<section id="sec-finance-applications" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="sec-finance-applications"><span class="header-section-number">6</span> Applications in Mathematical Finance</h2>
<p>Stochastic differential equations form the mathematical backbone of modern quantitative finance. The revolutionary insight that asset prices follow stochastic processes led to the development of rigorous option pricing theory and sophisticated risk management frameworks.</p>
<section id="the-black-scholes-model" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="the-black-scholes-model"><span class="header-section-number">6.1</span> The Black-Scholes Model</h3>
<p>The Black-Scholes model represents the foundational application of SDEs in finance, providing the first rigorous framework for option pricing.</p>
<p><strong>Model Specification</strong>: Under the Black-Scholes framework, the stock price <span class="math inline">\(S_t\)</span> follows geometric Brownian motion: <span class="math display">\[dS_t = \mu S_t dt + \sigma S_t dW_t\]</span></p>
<p>where: - <span class="math inline">\(\mu\)</span> is the expected return (drift) - <span class="math inline">\(\sigma\)</span> is the volatility - <span class="math inline">\(W_t\)</span> is Brownian motion under the physical measure</p>
<p><strong>Risk-Neutral Pricing</strong>: The fundamental theorem of asset pricing requires pricing under the risk-neutral measure <span class="math inline">\(\mathbb{Q}\)</span>, where: <span class="math display">\[dS_t = r S_t dt + \sigma S_t dW_t^{\mathbb{Q}}\]</span></p>
<p>where <span class="math inline">\(r\)</span> is the risk-free rate and <span class="math inline">\(W_t^{\mathbb{Q}}\)</span> is Brownian motion under <span class="math inline">\(\mathbb{Q}\)</span>.</p>
<p><strong>Theorem 6.1 (Black-Scholes Formula)</strong>: The price at time <span class="math inline">\(t\)</span> of a European call option with strike <span class="math inline">\(K\)</span> and maturity <span class="math inline">\(T\)</span> is:</p>
<p><span class="math display">\[C(t, S_t) = S_t \Phi(d_1) - K e^{-r(T-t)} \Phi(d_2)\]</span></p>
<p>where: <span class="math display">\[d_1 = \frac{\ln(S_t/K) + (r + \sigma^2/2)(T-t)}{\sigma\sqrt{T-t}}, \quad d_2 = d_1 - \sigma\sqrt{T-t}\]</span></p>
<p>and <span class="math inline">\(\Phi\)</span> is the standard normal cumulative distribution function.</p>
<p><strong>Derivation</strong>: The derivation follows from the Feynman-Kac theorem applied to the Black-Scholes PDE: <span class="math display">\[\frac{\partial V}{\partial t} + \frac{1}{2}\sigma^2 S^2 \frac{\partial^2 V}{\partial S^2} + rS \frac{\partial V}{\partial S} - rV = 0\]</span></p>
<p>with terminal condition <span class="math inline">\(V(T,S) = \max(S-K, 0)\)</span>.</p>
<div id="cell-fig-black-scholes" class="cell" data-fig-height="16" data-fig-width="18" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_call(S, K, T, r, sigma):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Black-Scholes call option price."""</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K) <span class="op">+</span> (r <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T) <span class="op">/</span> (sigma<span class="op">*</span>np.sqrt(T))</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma<span class="op">*</span>np.sqrt(T)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S <span class="op">*</span> stats.norm.cdf(d1) <span class="op">-</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> stats.norm.cdf(d2)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_put(S, K, T, r, sigma):</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Black-Scholes put option price."""</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K) <span class="op">+</span> (r <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T) <span class="op">/</span> (sigma<span class="op">*</span>np.sqrt(T))</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma<span class="op">*</span>np.sqrt(T)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> stats.norm.cdf(<span class="op">-</span>d2) <span class="op">-</span> S <span class="op">*</span> stats.norm.cdf(<span class="op">-</span>d1)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_greeks(S, K, T, r, sigma):</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate option Greeks."""</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K) <span class="op">+</span> (r <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T) <span class="op">/</span> (sigma<span class="op">*</span>np.sqrt(T))</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma<span class="op">*</span>np.sqrt(T)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Delta</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    delta_call <span class="op">=</span> stats.norm.cdf(d1)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    delta_put <span class="op">=</span> stats.norm.cdf(d1) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gamma</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> stats.norm.pdf(d1) <span class="op">/</span> (S <span class="op">*</span> sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Theta</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    theta_call <span class="op">=</span> (<span class="op">-</span>S <span class="op">*</span> stats.norm.pdf(d1) <span class="op">*</span> sigma <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> np.sqrt(T)) </span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>                  <span class="op">-</span> r <span class="op">*</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> stats.norm.cdf(d2))</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    theta_put <span class="op">=</span> (<span class="op">-</span>S <span class="op">*</span> stats.norm.pdf(d1) <span class="op">*</span> sigma <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> np.sqrt(T)) </span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>                 <span class="op">+</span> r <span class="op">*</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> stats.norm.cdf(<span class="op">-</span>d2))</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Vega</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    vega <span class="op">=</span> S <span class="op">*</span> stats.norm.pdf(d1) <span class="op">*</span> np.sqrt(T)</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rho</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>    rho_call <span class="op">=</span> K <span class="op">*</span> T <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> stats.norm.cdf(d2)</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>    rho_put <span class="op">=</span> <span class="op">-</span>K <span class="op">*</span> T <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> stats.norm.cdf(<span class="op">-</span>d2)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>        <span class="st">'delta_call'</span>: delta_call, <span class="st">'delta_put'</span>: delta_put,</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>        <span class="st">'gamma'</span>: gamma,</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>        <span class="st">'theta_call'</span>: theta_call, <span class="st">'theta_put'</span>: theta_put,</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>        <span class="st">'vega'</span>: vega,</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>        <span class="st">'rho_call'</span>: rho_call, <span class="st">'rho_put'</span>: rho_put</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> monte_carlo_option_price(S0, K, T, r, sigma, n_paths<span class="op">=</span><span class="dv">100000</span>, option_type<span class="op">=</span><span class="st">'call'</span>):</span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Monte Carlo option pricing."""</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> <span class="dv">252</span>  <span class="co"># Daily steps</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    n_steps <span class="op">=</span> <span class="bu">int</span>(T <span class="op">/</span> dt)</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate stock price paths</span></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    paths <span class="op">=</span> np.zeros((n_paths, n_steps <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    paths[:, <span class="dv">0</span>] <span class="op">=</span> S0</span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>        Z <span class="op">=</span> np.random.randn(n_paths)</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        paths[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> paths[:, i] <span class="op">*</span> np.exp((r <span class="op">-</span> <span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>dt <span class="op">+</span> sigma<span class="op">*</span>np.sqrt(dt)<span class="op">*</span>Z)</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate payoffs</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> option_type <span class="op">==</span> <span class="st">'call'</span>:</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>        payoffs <span class="op">=</span> np.maximum(paths[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  <span class="co"># put</span></span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>        payoffs <span class="op">=</span> np.maximum(K <span class="op">-</span> paths[:, <span class="op">-</span><span class="dv">1</span>], <span class="dv">0</span>)</span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Discount to present value</span></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>    price <span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> np.mean(payoffs)</span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>    std_error <span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span> np.std(payoffs) <span class="op">/</span> np.sqrt(n_paths)</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> price, std_error, paths</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">100</span>  <span class="co"># Initial stock price</span></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">100</span>   <span class="co"># Strike price</span></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span>  <span class="co"># Risk-free rate</span></span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span>  <span class="co"># Volatility</span></span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a>T_range <span class="op">=</span> np.linspace(<span class="fl">0.1</span>, <span class="dv">2</span>, <span class="dv">50</span>)  <span class="co"># Time to maturity range</span></span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a>S_range <span class="op">=</span> np.linspace(<span class="dv">80</span>, <span class="dv">120</span>, <span class="dv">50</span>)  <span class="co"># Stock price range</span></span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">16</span>))</span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a><span class="co"># Option prices vs underlying price</span></span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a>call_prices <span class="op">=</span> [black_scholes_call(S, K, <span class="fl">0.5</span>, r, sigma) <span class="cf">for</span> S <span class="kw">in</span> S_range]</span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a>put_prices <span class="op">=</span> [black_scholes_put(S, K, <span class="fl">0.5</span>, r, sigma) <span class="cf">for</span> S <span class="kw">in</span> S_range]</span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(S_range, call_prices, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Call Option'</span>)</span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(S_range, put_prices, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Put Option'</span>)</span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(S_range, np.maximum(S_range <span class="op">-</span> K, <span class="dv">0</span>), <span class="st">'b--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Call Intrinsic'</span>)</span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(S_range, np.maximum(K <span class="op">-</span> S_range, <span class="dv">0</span>), <span class="st">'r--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'Put Intrinsic'</span>)</span>
<span id="cb16-89"><a href="#cb16-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Stock Price S'</span>)</span>
<span id="cb16-90"><a href="#cb16-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Option Price'</span>)</span>
<span id="cb16-91"><a href="#cb16-91" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Option Prices vs Underlying Price (T=0.5)'</span>)</span>
<span id="cb16-92"><a href="#cb16-92" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb16-93"><a href="#cb16-93" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-94"><a href="#cb16-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-95"><a href="#cb16-95" aria-hidden="true" tabindex="-1"></a><span class="co"># Option prices vs time to maturity</span></span>
<span id="cb16-96"><a href="#cb16-96" aria-hidden="true" tabindex="-1"></a>call_prices_time <span class="op">=</span> [black_scholes_call(S0, K, T, r, sigma) <span class="cf">for</span> T <span class="kw">in</span> T_range]</span>
<span id="cb16-97"><a href="#cb16-97" aria-hidden="true" tabindex="-1"></a>put_prices_time <span class="op">=</span> [black_scholes_put(S0, K, T, r, sigma) <span class="cf">for</span> T <span class="kw">in</span> T_range]</span>
<span id="cb16-98"><a href="#cb16-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-99"><a href="#cb16-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(T_range, call_prices_time, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Call Option'</span>)</span>
<span id="cb16-100"><a href="#cb16-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(T_range, put_prices_time, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Put Option'</span>)</span>
<span id="cb16-101"><a href="#cb16-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time to Maturity T'</span>)</span>
<span id="cb16-102"><a href="#cb16-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Option Price'</span>)</span>
<span id="cb16-103"><a href="#cb16-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="ss">f'Option Prices vs Time to Maturity (S=</span><span class="sc">{</span>S0<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb16-104"><a href="#cb16-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb16-105"><a href="#cb16-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-106"><a href="#cb16-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-107"><a href="#cb16-107" aria-hidden="true" tabindex="-1"></a><span class="co"># Greeks calculation</span></span>
<span id="cb16-108"><a href="#cb16-108" aria-hidden="true" tabindex="-1"></a>greeks_data <span class="op">=</span> [calculate_greeks(S, K, <span class="fl">0.5</span>, r, sigma) <span class="cf">for</span> S <span class="kw">in</span> S_range]</span>
<span id="cb16-109"><a href="#cb16-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-110"><a href="#cb16-110" aria-hidden="true" tabindex="-1"></a><span class="co"># Delta</span></span>
<span id="cb16-111"><a href="#cb16-111" aria-hidden="true" tabindex="-1"></a>deltas_call <span class="op">=</span> [g[<span class="st">'delta_call'</span>] <span class="cf">for</span> g <span class="kw">in</span> greeks_data]</span>
<span id="cb16-112"><a href="#cb16-112" aria-hidden="true" tabindex="-1"></a>deltas_put <span class="op">=</span> [g[<span class="st">'delta_put'</span>] <span class="cf">for</span> g <span class="kw">in</span> greeks_data]</span>
<span id="cb16-113"><a href="#cb16-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-114"><a href="#cb16-114" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(S_range, deltas_call, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Call Delta'</span>)</span>
<span id="cb16-115"><a href="#cb16-115" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(S_range, deltas_put, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Put Delta'</span>)</span>
<span id="cb16-116"><a href="#cb16-116" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb16-117"><a href="#cb16-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'blue'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb16-118"><a href="#cb16-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Stock Price S'</span>)</span>
<span id="cb16-119"><a href="#cb16-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Delta'</span>)</span>
<span id="cb16-120"><a href="#cb16-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Delta: Price Sensitivity'</span>)</span>
<span id="cb16-121"><a href="#cb16-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb16-122"><a href="#cb16-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-123"><a href="#cb16-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-124"><a href="#cb16-124" aria-hidden="true" tabindex="-1"></a><span class="co"># Gamma</span></span>
<span id="cb16-125"><a href="#cb16-125" aria-hidden="true" tabindex="-1"></a>gammas <span class="op">=</span> [g[<span class="st">'gamma'</span>] <span class="cf">for</span> g <span class="kw">in</span> greeks_data]</span>
<span id="cb16-126"><a href="#cb16-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-127"><a href="#cb16-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(S_range, gammas, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Gamma'</span>)</span>
<span id="cb16-128"><a href="#cb16-128" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Stock Price S'</span>)</span>
<span id="cb16-129"><a href="#cb16-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Gamma'</span>)</span>
<span id="cb16-130"><a href="#cb16-130" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Gamma: Delta Sensitivity'</span>)</span>
<span id="cb16-131"><a href="#cb16-131" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb16-132"><a href="#cb16-132" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-133"><a href="#cb16-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-134"><a href="#cb16-134" aria-hidden="true" tabindex="-1"></a><span class="co"># Vega</span></span>
<span id="cb16-135"><a href="#cb16-135" aria-hidden="true" tabindex="-1"></a>vegas <span class="op">=</span> [g[<span class="st">'vega'</span>] <span class="cf">for</span> g <span class="kw">in</span> greeks_data]</span>
<span id="cb16-136"><a href="#cb16-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-137"><a href="#cb16-137" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(S_range, vegas, <span class="st">'purple'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Vega'</span>)</span>
<span id="cb16-138"><a href="#cb16-138" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Stock Price S'</span>)</span>
<span id="cb16-139"><a href="#cb16-139" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Vega'</span>)</span>
<span id="cb16-140"><a href="#cb16-140" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Vega: Volatility Sensitivity'</span>)</span>
<span id="cb16-141"><a href="#cb16-141" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb16-142"><a href="#cb16-142" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-143"><a href="#cb16-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-144"><a href="#cb16-144" aria-hidden="true" tabindex="-1"></a><span class="co"># Theta</span></span>
<span id="cb16-145"><a href="#cb16-145" aria-hidden="true" tabindex="-1"></a>thetas_call <span class="op">=</span> [g[<span class="st">'theta_call'</span>] <span class="cf">for</span> g <span class="kw">in</span> greeks_data]</span>
<span id="cb16-146"><a href="#cb16-146" aria-hidden="true" tabindex="-1"></a>thetas_put <span class="op">=</span> [g[<span class="st">'theta_put'</span>] <span class="cf">for</span> g <span class="kw">in</span> greeks_data]</span>
<span id="cb16-147"><a href="#cb16-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-148"><a href="#cb16-148" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(S_range, thetas_call, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Call Theta'</span>)</span>
<span id="cb16-149"><a href="#cb16-149" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(S_range, thetas_put, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Put Theta'</span>)</span>
<span id="cb16-150"><a href="#cb16-150" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb16-151"><a href="#cb16-151" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Stock Price S'</span>)</span>
<span id="cb16-152"><a href="#cb16-152" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Theta'</span>)</span>
<span id="cb16-153"><a href="#cb16-153" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Theta: Time Decay'</span>)</span>
<span id="cb16-154"><a href="#cb16-154" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb16-155"><a href="#cb16-155" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-156"><a href="#cb16-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-157"><a href="#cb16-157" aria-hidden="true" tabindex="-1"></a><span class="co"># Monte Carlo vs Black-Scholes comparison</span></span>
<span id="cb16-158"><a href="#cb16-158" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb16-159"><a href="#cb16-159" aria-hidden="true" tabindex="-1"></a>mc_call_price, mc_call_error, sample_paths <span class="op">=</span> monte_carlo_option_price(S0, K, <span class="fl">0.5</span>, r, sigma, <span class="dv">50000</span>, <span class="st">'call'</span>)</span>
<span id="cb16-160"><a href="#cb16-160" aria-hidden="true" tabindex="-1"></a>bs_call_price <span class="op">=</span> black_scholes_call(S0, K, <span class="fl">0.5</span>, r, sigma)</span>
<span id="cb16-161"><a href="#cb16-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-162"><a href="#cb16-162" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot sample paths</span></span>
<span id="cb16-163"><a href="#cb16-163" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">50</span>, sample_paths.shape[<span class="dv">0</span>])):</span>
<span id="cb16-164"><a href="#cb16-164" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">3</span>, <span class="dv">0</span>].plot(np.linspace(<span class="dv">0</span>, <span class="fl">0.5</span>, sample_paths.shape[<span class="dv">1</span>]), sample_paths[i], </span>
<span id="cb16-165"><a href="#cb16-165" aria-hidden="true" tabindex="-1"></a>                   alpha<span class="op">=</span><span class="fl">0.3</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb16-166"><a href="#cb16-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-167"><a href="#cb16-167" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span>K, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Strike K=</span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb16-168"><a href="#cb16-168" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span>S0, color<span class="op">=</span><span class="st">'green'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Initial S₀=</span><span class="sc">{</span>S0<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb16-169"><a href="#cb16-169" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time'</span>)</span>
<span id="cb16-170"><a href="#cb16-170" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Stock Price'</span>)</span>
<span id="cb16-171"><a href="#cb16-171" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].set_title(<span class="st">'Monte Carlo Sample Paths'</span>)</span>
<span id="cb16-172"><a href="#cb16-172" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].legend()</span>
<span id="cb16-173"><a href="#cb16-173" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-174"><a href="#cb16-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-175"><a href="#cb16-175" aria-hidden="true" tabindex="-1"></a><span class="co"># Terminal distribution and payoff</span></span>
<span id="cb16-176"><a href="#cb16-176" aria-hidden="true" tabindex="-1"></a>terminal_prices <span class="op">=</span> sample_paths[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb16-177"><a href="#cb16-177" aria-hidden="true" tabindex="-1"></a>payoffs <span class="op">=</span> np.maximum(terminal_prices <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="cb16-178"><a href="#cb16-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-179"><a href="#cb16-179" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].hist(terminal_prices, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'skyblue'</span>, </span>
<span id="cb16-180"><a href="#cb16-180" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">'Terminal Stock Price'</span>)</span>
<span id="cb16-181"><a href="#cb16-181" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].hist(payoffs, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">'lightcoral'</span>, </span>
<span id="cb16-182"><a href="#cb16-182" aria-hidden="true" tabindex="-1"></a>               label<span class="op">=</span><span class="st">'Call Payoff'</span>)</span>
<span id="cb16-183"><a href="#cb16-183" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].axvline(x<span class="op">=</span>K, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Strike K=</span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb16-184"><a href="#cb16-184" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Price/Payoff'</span>)</span>
<span id="cb16-185"><a href="#cb16-185" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb16-186"><a href="#cb16-186" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].set_title(<span class="ss">f'Terminal Distribution</span><span class="ch">\n</span><span class="ss">MC: </span><span class="sc">{</span>mc_call_price<span class="sc">:.4f}</span><span class="ss">±</span><span class="sc">{</span><span class="dv">2</span><span class="op">*</span>mc_call_error<span class="sc">:.4f}</span><span class="ss">, BS: </span><span class="sc">{</span>bs_call_price<span class="sc">:.4f}</span><span class="ss">'</span>)</span>
<span id="cb16-187"><a href="#cb16-187" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].legend()</span>
<span id="cb16-188"><a href="#cb16-188" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb16-189"><a href="#cb16-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-190"><a href="#cb16-190" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb16-191"><a href="#cb16-191" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb16-192"><a href="#cb16-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-193"><a href="#cb16-193" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Black-Scholes vs Monte Carlo Comparison:"</span>)</span>
<span id="cb16-194"><a href="#cb16-194" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Black-Scholes Price: </span><span class="sc">{</span>bs_call_price<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb16-195"><a href="#cb16-195" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Monte Carlo Price:   </span><span class="sc">{</span>mc_call_price<span class="sc">:.6f}</span><span class="ss"> ± </span><span class="sc">{</span><span class="dv">2</span><span class="op">*</span>mc_call_error<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb16-196"><a href="#cb16-196" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Difference:          </span><span class="sc">{</span><span class="bu">abs</span>(bs_call_price <span class="op">-</span> mc_call_price)<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb16-197"><a href="#cb16-197" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Relative Error:      </span><span class="sc">{</span><span class="bu">abs</span>(bs_call_price <span class="op">-</span> mc_call_price)<span class="op">/</span>bs_call_price<span class="sc">:.4%}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-black-scholes" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-black-scholes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-black-scholes-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-black-scholes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Black-Scholes model: Option pricing and Greeks analysis
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Black-Scholes vs Monte Carlo Comparison:
Black-Scholes Price: 6.888729
Monte Carlo Price:   6.867335 ± 0.087221
Difference:          0.021394
Relative Error:      0.3106%</code></pre>
</div>
</div>
</section>
<section id="interest-rate-models" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="interest-rate-models"><span class="header-section-number">6.2</span> Interest Rate Models</h3>
<p>Interest rate modeling requires more sophisticated SDEs due to the mean-reverting nature of rates and term structure considerations.</p>
<section id="vasicek-model" class="level4" data-number="6.2.1">
<h4 data-number="6.2.1" class="anchored" data-anchor-id="vasicek-model"><span class="header-section-number">6.2.1</span> Vasicek Model</h4>
<p><strong>Model Specification</strong>: The Vasicek model describes the short rate <span class="math inline">\(r_t\)</span> as: <span class="math display">\[dr_t = \kappa(\theta - r_t) dt + \sigma dW_t\]</span></p>
<p>where: - <span class="math inline">\(\kappa &gt; 0\)</span> is the speed of mean reversion - <span class="math inline">\(\theta\)</span> is the long-term mean - <span class="math inline">\(\sigma &gt; 0\)</span> is the volatility</p>
<p><strong>Analytical Solution</strong>: The Vasicek model has the explicit solution: <span class="math display">\[r_t = r_0 e^{-\kappa t} + \theta (1 - e^{-\kappa t}) + \sigma \int_0^t e^{-\kappa(t-s)} dW_s\]</span></p>
</section>
<section id="cox-ingersoll-ross-cir-model" class="level4" data-number="6.2.2">
<h4 data-number="6.2.2" class="anchored" data-anchor-id="cox-ingersoll-ross-cir-model"><span class="header-section-number">6.2.2</span> Cox-Ingersoll-Ross (CIR) Model</h4>
<p><strong>Model Specification</strong>: The CIR model ensures non-negative rates: <span class="math display">\[dr_t = \kappa(\theta - r_t) dt + \sigma \sqrt{r_t} dW_t\]</span></p>
<p>The square-root diffusion term prevents negative rates when <span class="math inline">\(2\kappa\theta \geq \sigma^2\)</span> (Feller condition).</p>
<div id="cell-fig-interest-rate-models" class="cell" data-fig-height="14" data-fig-width="18" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_vasicek(r0, kappa, theta, sigma, T, N, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate Vasicek interest rate model."""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    r[:, <span class="dv">0</span>] <span class="op">=</span> r0</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> sqrt_dt</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        r[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> (r[:, i] <span class="op">+</span> kappa <span class="op">*</span> (theta <span class="op">-</span> r[:, i]) <span class="op">*</span> dt <span class="op">+</span> sigma <span class="op">*</span> dW)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t, r</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_cir(r0, kappa, theta, sigma, T, N, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate CIR interest rate model using Euler scheme with absorption."""</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    r[:, <span class="dv">0</span>] <span class="op">=</span> r0</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> sqrt_dt</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        r_curr <span class="op">=</span> np.maximum(r[:, i], <span class="dv">0</span>)  <span class="co"># Ensure non-negative</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        r[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> (r_curr <span class="op">+</span> kappa <span class="op">*</span> (theta <span class="op">-</span> r_curr) <span class="op">*</span> dt <span class="op">+</span> </span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>                     sigma <span class="op">*</span> np.sqrt(r_curr) <span class="op">*</span> dW)</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>        r[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> np.maximum(r[:, i<span class="op">+</span><span class="dv">1</span>], <span class="dv">0</span>)  <span class="co"># Absorb at zero</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t, r</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vasicek_bond_price(r, tau, kappa, theta, sigma):</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Vasicek zero-coupon bond price."""</span></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>kappa <span class="op">*</span> tau)) <span class="op">/</span> kappa</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.exp((B <span class="op">-</span> tau) <span class="op">*</span> (kappa<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> theta <span class="op">-</span> sigma<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>) <span class="op">/</span> kappa<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> </span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>               sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> B<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">4</span> <span class="op">*</span> kappa))</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A <span class="op">*</span> np.exp(<span class="op">-</span>B <span class="op">*</span> r)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cir_bond_price(r, tau, kappa, theta, sigma):</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""CIR zero-coupon bond price (approximate)."""</span></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> np.sqrt(kappa<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    exp_gamma_tau <span class="op">=</span> np.exp(gamma <span class="op">*</span> tau)</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (exp_gamma_tau <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> ((gamma <span class="op">+</span> kappa) <span class="op">*</span> (exp_gamma_tau <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> gamma)</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> (<span class="dv">2</span> <span class="op">*</span> gamma <span class="op">*</span> exp_gamma_tau) <span class="op">/</span> ((gamma <span class="op">+</span> kappa) <span class="op">*</span> (exp_gamma_tau <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> gamma)</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> A<span class="op">**</span>(<span class="dv">2</span> <span class="op">*</span> kappa <span class="op">*</span> theta <span class="op">/</span> sigma<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A <span class="op">*</span> np.exp(<span class="op">-</span>B <span class="op">*</span> r)</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a><span class="co"># Model parameters</span></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>r0 <span class="op">=</span> <span class="fl">0.03</span></span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>kappa <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="fl">0.04</span></span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>sigma_vasicek <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>sigma_cir <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>n_paths <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">14</span>))</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate both models</span></span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a>t, r_vasicek <span class="op">=</span> simulate_vasicek(r0, kappa, theta, sigma_vasicek, T, N, n_paths)</span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a>t, r_cir <span class="op">=</span> simulate_cir(r0, kappa, theta, sigma_cir, T, N, n_paths)</span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample paths</span></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">50</span>, n_paths)):</span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, r_vasicek[i], alpha<span class="op">=</span><span class="fl">0.3</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t, r_cir[i], alpha<span class="op">=</span><span class="fl">0.3</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, r_vasicek[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'darkblue'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span>theta, color<span class="op">=</span><span class="st">'green'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>                  label<span class="op">=</span><span class="ss">f'Long-term mean θ=</span><span class="sc">{</span>theta<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Vasicek Model: dr = κ(θ-r)dt + σdW'</span>)</span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time (years)'</span>)</span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Interest Rate'</span>)</span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t, r_cir[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'darkred'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span>theta, color<span class="op">=</span><span class="st">'green'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb18-86"><a href="#cb18-86" aria-hidden="true" tabindex="-1"></a>                  label<span class="op">=</span><span class="ss">f'Long-term mean θ=</span><span class="sc">{</span>theta<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-87"><a href="#cb18-87" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'CIR Model: dr = κ(θ-r)dt + σ√r dW'</span>)</span>
<span id="cb18-88"><a href="#cb18-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time (years)'</span>)</span>
<span id="cb18-89"><a href="#cb18-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Interest Rate'</span>)</span>
<span id="cb18-90"><a href="#cb18-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb18-91"><a href="#cb18-91" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb18-92"><a href="#cb18-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-93"><a href="#cb18-93" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution evolution</span></span>
<span id="cb18-94"><a href="#cb18-94" aria-hidden="true" tabindex="-1"></a>times_to_plot <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">10</span>]</span>
<span id="cb18-95"><a href="#cb18-95" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'orange'</span>, <span class="st">'red'</span>]</span>
<span id="cb18-96"><a href="#cb18-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-97"><a href="#cb18-97" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (time_point, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(times_to_plot, colors)):</span>
<span id="cb18-98"><a href="#cb18-98" aria-hidden="true" tabindex="-1"></a>    time_idx <span class="op">=</span> <span class="bu">int</span>(time_point <span class="op">*</span> N <span class="op">/</span> T)</span>
<span id="cb18-99"><a href="#cb18-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-100"><a href="#cb18-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Vasicek distribution</span></span>
<span id="cb18-101"><a href="#cb18-101" aria-hidden="true" tabindex="-1"></a>    rates_vasicek <span class="op">=</span> r_vasicek[:, time_idx]</span>
<span id="cb18-102"><a href="#cb18-102" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].hist(rates_vasicek, bins<span class="op">=</span><span class="dv">40</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span>color, </span>
<span id="cb18-103"><a href="#cb18-103" aria-hidden="true" tabindex="-1"></a>                   label<span class="op">=</span><span class="ss">f't=</span><span class="sc">{</span>time_point<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-104"><a href="#cb18-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-105"><a href="#cb18-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Theoretical Vasicek distribution (Gaussian)</span></span>
<span id="cb18-106"><a href="#cb18-106" aria-hidden="true" tabindex="-1"></a>    mean_vasicek <span class="op">=</span> r0 <span class="op">*</span> np.exp(<span class="op">-</span>kappa <span class="op">*</span> time_point) <span class="op">+</span> theta <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>kappa <span class="op">*</span> time_point))</span>
<span id="cb18-107"><a href="#cb18-107" aria-hidden="true" tabindex="-1"></a>    var_vasicek <span class="op">=</span> sigma_vasicek<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> kappa <span class="op">*</span> time_point)) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> kappa)</span>
<span id="cb18-108"><a href="#cb18-108" aria-hidden="true" tabindex="-1"></a>    x_range <span class="op">=</span> np.linspace(rates_vasicek.<span class="bu">min</span>(), rates_vasicek.<span class="bu">max</span>(), <span class="dv">100</span>)</span>
<span id="cb18-109"><a href="#cb18-109" aria-hidden="true" tabindex="-1"></a>    theoretical_pdf <span class="op">=</span> stats.norm.pdf(x_range, mean_vasicek, np.sqrt(var_vasicek))</span>
<span id="cb18-110"><a href="#cb18-110" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(x_range, theoretical_pdf, color<span class="op">=</span>color, linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb18-111"><a href="#cb18-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-112"><a href="#cb18-112" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CIR distribution</span></span>
<span id="cb18-113"><a href="#cb18-113" aria-hidden="true" tabindex="-1"></a>    rates_cir <span class="op">=</span> r_cir[:, time_idx]</span>
<span id="cb18-114"><a href="#cb18-114" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">1</span>].hist(rates_cir, bins<span class="op">=</span><span class="dv">40</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, density<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span>color, </span>
<span id="cb18-115"><a href="#cb18-115" aria-hidden="true" tabindex="-1"></a>                   label<span class="op">=</span><span class="ss">f't=</span><span class="sc">{</span>time_point<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-116"><a href="#cb18-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-117"><a href="#cb18-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Vasicek Rate Distribution Evolution'</span>)</span>
<span id="cb18-118"><a href="#cb18-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Interest Rate'</span>)</span>
<span id="cb18-119"><a href="#cb18-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb18-120"><a href="#cb18-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb18-121"><a href="#cb18-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb18-122"><a href="#cb18-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-123"><a href="#cb18-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'CIR Rate Distribution Evolution'</span>)</span>
<span id="cb18-124"><a href="#cb18-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Interest Rate'</span>)</span>
<span id="cb18-125"><a href="#cb18-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb18-126"><a href="#cb18-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb18-127"><a href="#cb18-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb18-128"><a href="#cb18-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-129"><a href="#cb18-129" aria-hidden="true" tabindex="-1"></a><span class="co"># Term structure of interest rates</span></span>
<span id="cb18-130"><a href="#cb18-130" aria-hidden="true" tabindex="-1"></a>maturities <span class="op">=</span> np.linspace(<span class="fl">0.1</span>, <span class="dv">10</span>, <span class="dv">50</span>)</span>
<span id="cb18-131"><a href="#cb18-131" aria-hidden="true" tabindex="-1"></a>current_rate <span class="op">=</span> <span class="fl">0.035</span></span>
<span id="cb18-132"><a href="#cb18-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-133"><a href="#cb18-133" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate bond prices and yields</span></span>
<span id="cb18-134"><a href="#cb18-134" aria-hidden="true" tabindex="-1"></a>vasicek_bonds <span class="op">=</span> [vasicek_bond_price(current_rate, tau, kappa, theta, sigma_vasicek) </span>
<span id="cb18-135"><a href="#cb18-135" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> tau <span class="kw">in</span> maturities]</span>
<span id="cb18-136"><a href="#cb18-136" aria-hidden="true" tabindex="-1"></a>cir_bonds <span class="op">=</span> [cir_bond_price(current_rate, tau, kappa, theta, sigma_cir) </span>
<span id="cb18-137"><a href="#cb18-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> tau <span class="kw">in</span> maturities]</span>
<span id="cb18-138"><a href="#cb18-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-139"><a href="#cb18-139" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to yields: Y = -ln(P)/τ</span></span>
<span id="cb18-140"><a href="#cb18-140" aria-hidden="true" tabindex="-1"></a>vasicek_yields <span class="op">=</span> [<span class="op">-</span>np.log(P) <span class="op">/</span> tau <span class="cf">for</span> P, tau <span class="kw">in</span> <span class="bu">zip</span>(vasicek_bonds, maturities)]</span>
<span id="cb18-141"><a href="#cb18-141" aria-hidden="true" tabindex="-1"></a>cir_yields <span class="op">=</span> [<span class="op">-</span>np.log(P) <span class="op">/</span> tau <span class="cf">for</span> P, tau <span class="kw">in</span> <span class="bu">zip</span>(cir_bonds, maturities)]</span>
<span id="cb18-142"><a href="#cb18-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-143"><a href="#cb18-143" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(maturities, vasicek_yields, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Vasicek'</span>)</span>
<span id="cb18-144"><a href="#cb18-144" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(maturities, cir_yields, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'CIR'</span>)</span>
<span id="cb18-145"><a href="#cb18-145" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span>theta, color<span class="op">=</span><span class="st">'green'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, </span>
<span id="cb18-146"><a href="#cb18-146" aria-hidden="true" tabindex="-1"></a>                  label<span class="op">=</span><span class="ss">f'Long-term rate θ=</span><span class="sc">{</span>theta<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-147"><a href="#cb18-147" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Maturity (years)'</span>)</span>
<span id="cb18-148"><a href="#cb18-148" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Yield'</span>)</span>
<span id="cb18-149"><a href="#cb18-149" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="ss">f'Term Structure of Interest Rates (r₀=</span><span class="sc">{</span>current_rate<span class="sc">}</span><span class="ss">)'</span>)</span>
<span id="cb18-150"><a href="#cb18-150" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb18-151"><a href="#cb18-151" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb18-152"><a href="#cb18-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-153"><a href="#cb18-153" aria-hidden="true" tabindex="-1"></a><span class="co"># Bond price volatility</span></span>
<span id="cb18-154"><a href="#cb18-154" aria-hidden="true" tabindex="-1"></a>bond_vols_vasicek <span class="op">=</span> []</span>
<span id="cb18-155"><a href="#cb18-155" aria-hidden="true" tabindex="-1"></a>bond_vols_cir <span class="op">=</span> []</span>
<span id="cb18-156"><a href="#cb18-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-157"><a href="#cb18-157" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tau <span class="kw">in</span> maturities:</span>
<span id="cb18-158"><a href="#cb18-158" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate bond prices for all rate paths at current time</span></span>
<span id="cb18-159"><a href="#cb18-159" aria-hidden="true" tabindex="-1"></a>    prices_vasicek <span class="op">=</span> [vasicek_bond_price(r, tau, kappa, theta, sigma_vasicek) </span>
<span id="cb18-160"><a href="#cb18-160" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">for</span> r <span class="kw">in</span> r_vasicek[:, <span class="dv">0</span>]]  <span class="co"># Use initial rates</span></span>
<span id="cb18-161"><a href="#cb18-161" aria-hidden="true" tabindex="-1"></a>    prices_cir <span class="op">=</span> [cir_bond_price(r, tau, kappa, theta, sigma_cir) </span>
<span id="cb18-162"><a href="#cb18-162" aria-hidden="true" tabindex="-1"></a>                 <span class="cf">for</span> r <span class="kw">in</span> r_cir[:, <span class="dv">0</span>]]</span>
<span id="cb18-163"><a href="#cb18-163" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-164"><a href="#cb18-164" aria-hidden="true" tabindex="-1"></a>    bond_vols_vasicek.append(np.std(prices_vasicek))</span>
<span id="cb18-165"><a href="#cb18-165" aria-hidden="true" tabindex="-1"></a>    bond_vols_cir.append(np.std(prices_cir))</span>
<span id="cb18-166"><a href="#cb18-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-167"><a href="#cb18-167" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(maturities, bond_vols_vasicek, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Vasicek'</span>)</span>
<span id="cb18-168"><a href="#cb18-168" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(maturities, bond_vols_cir, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'CIR'</span>)</span>
<span id="cb18-169"><a href="#cb18-169" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Maturity (years)'</span>)</span>
<span id="cb18-170"><a href="#cb18-170" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Bond Price Volatility'</span>)</span>
<span id="cb18-171"><a href="#cb18-171" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Bond Price Volatility vs Maturity'</span>)</span>
<span id="cb18-172"><a href="#cb18-172" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb18-173"><a href="#cb18-173" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb18-174"><a href="#cb18-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-175"><a href="#cb18-175" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb18-176"><a href="#cb18-176" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-177"><a href="#cb18-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-178"><a href="#cb18-178" aria-hidden="true" tabindex="-1"></a><span class="co"># Summary statistics</span></span>
<span id="cb18-179"><a href="#cb18-179" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Model Comparison:"</span>)</span>
<span id="cb18-180"><a href="#cb18-180" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vasicek - Mean rate: </span><span class="sc">{</span>np<span class="sc">.</span>mean(r_vasicek)<span class="sc">:.4f}</span><span class="ss">, Std: </span><span class="sc">{</span>np<span class="sc">.</span>std(r_vasicek)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb18-181"><a href="#cb18-181" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"CIR - Mean rate: </span><span class="sc">{</span>np<span class="sc">.</span>mean(r_cir)<span class="sc">:.4f}</span><span class="ss">, Std: </span><span class="sc">{</span>np<span class="sc">.</span>std(r_cir)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb18-182"><a href="#cb18-182" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Negative rates in Vasicek: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(r_vasicek <span class="op">&lt;</span> <span class="dv">0</span>) <span class="op">/</span> r_vasicek<span class="sc">.</span>size<span class="sc">:.2%}</span><span class="ss">"</span>)</span>
<span id="cb18-183"><a href="#cb18-183" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Negative rates in CIR: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(r_cir <span class="op">&lt;</span> <span class="dv">0</span>) <span class="op">/</span> r_cir<span class="sc">.</span>size<span class="sc">:.2%}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-interest-rate-models" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-interest-rate-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-interest-rate-models-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-interest-rate-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: Interest rate models: Vasicek and CIR processes with term structure
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model Comparison:
Vasicek - Mean rate: 0.0377, Std: 0.0098
CIR - Mean rate: 0.0381, Std: 0.0096
Negative rates in Vasicek: 0.00%
Negative rates in CIR: 0.00%</code></pre>
</div>
</div>
</section>
</section>
<section id="stochastic-volatility-models" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="stochastic-volatility-models"><span class="header-section-number">6.3</span> Stochastic Volatility Models</h3>
<p>Real market data exhibits volatility clustering and mean reversion, motivating stochastic volatility models.</p>
<section id="heston-model" class="level4" data-number="6.3.1">
<h4 data-number="6.3.1" class="anchored" data-anchor-id="heston-model"><span class="header-section-number">6.3.1</span> Heston Model</h4>
<p><strong>Model Specification</strong>: The Heston model couples asset price with stochastic volatility: <span class="math display">\[dS_t = \mu S_t dt + \sqrt{V_t} S_t dW_t^{(1)}\]</span> <span class="math display">\[dV_t = \kappa(\theta - V_t) dt + \sigma_v \sqrt{V_t} dW_t^{(2)}\]</span></p>
<p>where <span class="math inline">\(dW_t^{(1)} dW_t^{(2)} = \rho dt\)</span> captures correlation between price and volatility shocks.</p>
<p><strong>Properties</strong>: - <strong>Volatility clustering</strong>: High volatility tends to be followed by high volatility - <strong>Leverage effect</strong>: Negative correlation <span class="math inline">\(\rho &lt; 0\)</span> captures the inverse relationship between returns and volatility - <strong>Fat tails</strong>: The model generates fat-tailed return distributions</p>
<div id="cell-fig-heston-model" class="cell" data-fig-height="12" data-fig-width="16" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_heston(S0, V0, mu, kappa, theta, sigma_v, rho, T, N, n_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate Heston model using Euler scheme."""</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    S[:, <span class="dv">0</span>] <span class="op">=</span> S0</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    V[:, <span class="dv">0</span>] <span class="op">=</span> V0</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate correlated Brownian increments</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        Z1 <span class="op">=</span> np.random.randn(n_paths)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        Z2 <span class="op">=</span> rho <span class="op">*</span> Z1 <span class="op">+</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> np.random.randn(n_paths)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        dW1 <span class="op">=</span> Z1 <span class="op">*</span> sqrt_dt</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        dW2 <span class="op">=</span> Z2 <span class="op">*</span> sqrt_dt</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update variance (with absorption at zero)</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        V_curr <span class="op">=</span> np.maximum(V[:, i], <span class="dv">0</span>)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        V[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> V_curr <span class="op">+</span> kappa <span class="op">*</span> (theta <span class="op">-</span> V_curr) <span class="op">*</span> dt <span class="op">+</span> sigma_v <span class="op">*</span> np.sqrt(V_curr) <span class="op">*</span> dW2</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        V[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> np.maximum(V[:, i<span class="op">+</span><span class="dv">1</span>], <span class="dv">0</span>)</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update stock price</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        S[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> S[:, i] <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> mu <span class="op">*</span> dt <span class="op">+</span> np.sqrt(V_curr) <span class="op">*</span> dW1)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S, V</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heston_option_pricing_mc(S0, V0, K, T, r, kappa, theta, sigma_v, rho, n_paths<span class="op">=</span><span class="dv">100000</span>):</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Monte Carlo option pricing under Heston model."""</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>    S, V <span class="op">=</span> simulate_heston(S0, V0, r, kappa, theta, sigma_v, rho, T, <span class="dv">252</span>, n_paths)</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate payoffs</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>    call_payoffs <span class="op">=</span> np.maximum(S[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    put_payoffs <span class="op">=</span> np.maximum(K <span class="op">-</span> S[:, <span class="op">-</span><span class="dv">1</span>], <span class="dv">0</span>)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Discount to present value</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>    call_price <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(call_payoffs)</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>    put_price <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(put_payoffs)</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> call_price, put_price, S, V</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Heston model parameters</span></span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>V0 <span class="op">=</span> <span class="fl">0.04</span>  <span class="co"># Initial variance (σ₀ = 20%)</span></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>kappa <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="fl">0.04</span>  <span class="co"># Long-term variance</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>sigma_v <span class="op">=</span> <span class="fl">0.3</span>  <span class="co"># Volatility of volatility</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="op">-</span><span class="fl">0.7</span>  <span class="co"># Leverage effect</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">252</span></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>n_paths <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">12</span>))</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate Heston paths</span></span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>S_heston, V_heston <span class="op">=</span> simulate_heston(S0, V0, mu, kappa, theta, sigma_v, rho, T, N, n_paths)</span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, T, N <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare with Black-Scholes (constant volatility)</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a>sigma_bs <span class="op">=</span> np.sqrt(theta)  <span class="co"># Use long-term volatility</span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a>S_bs <span class="op">=</span> np.zeros((n_paths, N <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a>S_bs[:, <span class="dv">0</span>] <span class="op">=</span> S0</span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true" tabindex="-1"></a>    dW <span class="op">=</span> np.random.randn(n_paths) <span class="op">*</span> np.sqrt(dt)</span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true" tabindex="-1"></a>    S_bs[:, i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> S_bs[:, i] <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> mu <span class="op">*</span> dt <span class="op">+</span> sigma_bs <span class="op">*</span> dW)</span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample paths comparison</span></span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">20</span>, n_paths)):</span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, S_heston[i], alpha<span class="op">=</span><span class="fl">0.4</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t, S_bs[i], alpha<span class="op">=</span><span class="fl">0.4</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t, S_heston[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'darkblue'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Heston Model: Stock Price Paths'</span>)</span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time'</span>)</span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Stock Price'</span>)</span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t, S_bs[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'darkred'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Black-Scholes: Stock Price Paths'</span>)</span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time'</span>)</span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Stock Price'</span>)</span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility paths</span></span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">20</span>, n_paths)):</span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, np.sqrt(V_heston[i]), alpha<span class="op">=</span><span class="fl">0.4</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t, np.sqrt(V_heston[<span class="dv">0</span>]), color<span class="op">=</span><span class="st">'darkgreen'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Sample path'</span>)</span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span>np.sqrt(theta), color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true" tabindex="-1"></a>                  label<span class="op">=</span><span class="ss">f'Long-term vol = </span><span class="sc">{</span>np<span class="sc">.</span>sqrt(theta)<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Heston Model: Volatility Paths'</span>)</span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time'</span>)</span>
<span id="cb20-101"><a href="#cb20-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Volatility'</span>)</span>
<span id="cb20-102"><a href="#cb20-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb20-103"><a href="#cb20-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-104"><a href="#cb20-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-105"><a href="#cb20-105" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility vs return correlation</span></span>
<span id="cb20-106"><a href="#cb20-106" aria-hidden="true" tabindex="-1"></a>returns_heston <span class="op">=</span> np.diff(np.log(S_heston), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-107"><a href="#cb20-107" aria-hidden="true" tabindex="-1"></a>vol_changes <span class="op">=</span> np.diff(np.sqrt(V_heston), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-108"><a href="#cb20-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-109"><a href="#cb20-109" aria-hidden="true" tabindex="-1"></a><span class="co"># Flatten for correlation calculation</span></span>
<span id="cb20-110"><a href="#cb20-110" aria-hidden="true" tabindex="-1"></a>returns_flat <span class="op">=</span> returns_heston.flatten()</span>
<span id="cb20-111"><a href="#cb20-111" aria-hidden="true" tabindex="-1"></a>vol_flat <span class="op">=</span> vol_changes.flatten()</span>
<span id="cb20-112"><a href="#cb20-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-113"><a href="#cb20-113" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample scatter plot</span></span>
<span id="cb20-114"><a href="#cb20-114" aria-hidden="true" tabindex="-1"></a>sample_size <span class="op">=</span> <span class="bu">min</span>(<span class="dv">5000</span>, <span class="bu">len</span>(returns_flat))</span>
<span id="cb20-115"><a href="#cb20-115" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.random.choice(<span class="bu">len</span>(returns_flat), sample_size, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-116"><a href="#cb20-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-117"><a href="#cb20-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].scatter(returns_flat[indices], vol_flat[indices], alpha<span class="op">=</span><span class="fl">0.3</span>, s<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-118"><a href="#cb20-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Log Returns'</span>)</span>
<span id="cb20-119"><a href="#cb20-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Volatility Changes'</span>)</span>
<span id="cb20-120"><a href="#cb20-120" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="ss">f'Return-Volatility Correlation</span><span class="ch">\n</span><span class="ss">(ρ = </span><span class="sc">{</span>np<span class="sc">.</span>corrcoef(returns_flat, vol_flat)[<span class="dv">0</span>,<span class="dv">1</span>]<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb20-121"><a href="#cb20-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-122"><a href="#cb20-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-123"><a href="#cb20-123" aria-hidden="true" tabindex="-1"></a><span class="co"># Return distributions comparison</span></span>
<span id="cb20-124"><a href="#cb20-124" aria-hidden="true" tabindex="-1"></a>returns_heston_terminal <span class="op">=</span> np.log(S_heston[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> S_heston[:, <span class="dv">0</span>])</span>
<span id="cb20-125"><a href="#cb20-125" aria-hidden="true" tabindex="-1"></a>returns_bs_terminal <span class="op">=</span> np.log(S_bs[:, <span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> S_bs[:, <span class="dv">0</span>])</span>
<span id="cb20-126"><a href="#cb20-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-127"><a href="#cb20-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].hist(returns_heston_terminal, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb20-128"><a href="#cb20-128" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'Heston'</span>)</span>
<span id="cb20-129"><a href="#cb20-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].hist(returns_bs_terminal, bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, density<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb20-130"><a href="#cb20-130" aria-hidden="true" tabindex="-1"></a>               color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'Black-Scholes'</span>)</span>
<span id="cb20-131"><a href="#cb20-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-132"><a href="#cb20-132" aria-hidden="true" tabindex="-1"></a><span class="co"># Theoretical normal distribution</span></span>
<span id="cb20-133"><a href="#cb20-133" aria-hidden="true" tabindex="-1"></a>x_range <span class="op">=</span> np.linspace(<span class="bu">min</span>(returns_heston_terminal.<span class="bu">min</span>(), returns_bs_terminal.<span class="bu">min</span>()),</span>
<span id="cb20-134"><a href="#cb20-134" aria-hidden="true" tabindex="-1"></a>                     <span class="bu">max</span>(returns_heston_terminal.<span class="bu">max</span>(), returns_bs_terminal.<span class="bu">max</span>()), <span class="dv">100</span>)</span>
<span id="cb20-135"><a href="#cb20-135" aria-hidden="true" tabindex="-1"></a>normal_pdf <span class="op">=</span> stats.norm.pdf(x_range, (mu <span class="op">-</span> <span class="fl">0.5</span><span class="op">*</span>sigma_bs<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T, sigma_bs<span class="op">*</span>np.sqrt(T))</span>
<span id="cb20-136"><a href="#cb20-136" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(x_range, normal_pdf, <span class="st">'k--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Normal'</span>)</span>
<span id="cb20-137"><a href="#cb20-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-138"><a href="#cb20-138" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Log Returns'</span>)</span>
<span id="cb20-139"><a href="#cb20-139" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Density'</span>)</span>
<span id="cb20-140"><a href="#cb20-140" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Return Distribution Comparison'</span>)</span>
<span id="cb20-141"><a href="#cb20-141" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb20-142"><a href="#cb20-142" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-143"><a href="#cb20-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-144"><a href="#cb20-144" aria-hidden="true" tabindex="-1"></a><span class="co"># Option pricing comparison</span></span>
<span id="cb20-145"><a href="#cb20-145" aria-hidden="true" tabindex="-1"></a>K_range <span class="op">=</span> np.linspace(<span class="dv">80</span>, <span class="dv">120</span>, <span class="dv">21</span>)</span>
<span id="cb20-146"><a href="#cb20-146" aria-hidden="true" tabindex="-1"></a>heston_calls <span class="op">=</span> []</span>
<span id="cb20-147"><a href="#cb20-147" aria-hidden="true" tabindex="-1"></a>bs_calls <span class="op">=</span> []</span>
<span id="cb20-148"><a href="#cb20-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-149"><a href="#cb20-149" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> K <span class="kw">in</span> K_range:</span>
<span id="cb20-150"><a href="#cb20-150" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Heston option price (Monte Carlo)</span></span>
<span id="cb20-151"><a href="#cb20-151" aria-hidden="true" tabindex="-1"></a>    heston_call, _, _, _ <span class="op">=</span> heston_option_pricing_mc(S0, V0, K, T, <span class="fl">0.05</span>, kappa, theta, sigma_v, rho, <span class="dv">20000</span>)</span>
<span id="cb20-152"><a href="#cb20-152" aria-hidden="true" tabindex="-1"></a>    heston_calls.append(heston_call)</span>
<span id="cb20-153"><a href="#cb20-153" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-154"><a href="#cb20-154" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Black-Scholes option price</span></span>
<span id="cb20-155"><a href="#cb20-155" aria-hidden="true" tabindex="-1"></a>    bs_call <span class="op">=</span> black_scholes_call(S0, K, T, <span class="fl">0.05</span>, sigma_bs)</span>
<span id="cb20-156"><a href="#cb20-156" aria-hidden="true" tabindex="-1"></a>    bs_calls.append(bs_call)</span>
<span id="cb20-157"><a href="#cb20-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-158"><a href="#cb20-158" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(K_range, heston_calls, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'Heston'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb20-159"><a href="#cb20-159" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].plot(K_range, bs_calls, <span class="st">'rs-'</span>, label<span class="op">=</span><span class="st">'Black-Scholes'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb20-160"><a href="#cb20-160" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Strike Price'</span>)</span>
<span id="cb20-161"><a href="#cb20-161" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Call Option Price'</span>)</span>
<span id="cb20-162"><a href="#cb20-162" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Option Prices: Heston vs Black-Scholes'</span>)</span>
<span id="cb20-163"><a href="#cb20-163" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].legend()</span>
<span id="cb20-164"><a href="#cb20-164" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-165"><a href="#cb20-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-166"><a href="#cb20-166" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb20-167"><a href="#cb20-167" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb20-168"><a href="#cb20-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-169"><a href="#cb20-169" aria-hidden="true" tabindex="-1"></a><span class="co"># Summary statistics</span></span>
<span id="cb20-170"><a href="#cb20-170" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Model Statistics:"</span>)</span>
<span id="cb20-171"><a href="#cb20-171" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Heston - Return mean: </span><span class="sc">{</span>np<span class="sc">.</span>mean(returns_heston_terminal)<span class="sc">:.4f}</span><span class="ss">, std: </span><span class="sc">{</span>np<span class="sc">.</span>std(returns_heston_terminal)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb20-172"><a href="#cb20-172" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Black-Scholes - Return mean: </span><span class="sc">{</span>np<span class="sc">.</span>mean(returns_bs_terminal)<span class="sc">:.4f}</span><span class="ss">, std: </span><span class="sc">{</span>np<span class="sc">.</span>std(returns_bs_terminal)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb20-173"><a href="#cb20-173" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Heston - Return skewness: </span><span class="sc">{</span>stats<span class="sc">.</span>skew(returns_heston_terminal)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb20-174"><a href="#cb20-174" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Black-Scholes - Return skewness: </span><span class="sc">{</span>stats<span class="sc">.</span>skew(returns_bs_terminal)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb20-175"><a href="#cb20-175" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Heston - Return kurtosis: </span><span class="sc">{</span>stats<span class="sc">.</span>kurtosis(returns_heston_terminal)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb20-176"><a href="#cb20-176" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Black-Scholes - Return kurtosis: </span><span class="sc">{</span>stats<span class="sc">.</span>kurtosis(returns_bs_terminal)<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-heston-model" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-heston-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-heston-model-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-heston-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12: Heston stochastic volatility model: Coupled dynamics and option pricing
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model Statistics:
Heston - Return mean: 0.0306, std: 0.2042
Black-Scholes - Return mean: 0.0303, std: 0.2000
Heston - Return skewness: -0.8718
Black-Scholes - Return skewness: -0.0430
Heston - Return kurtosis: 1.2808
Black-Scholes - Return kurtosis: 0.0571</code></pre>
</div>
</div>
<p>The financial applications demonstrate how SDEs provide the mathematical foundation for:</p>
<ol type="1">
<li><strong>Option pricing</strong>: From the classical Black-Scholes formula to sophisticated stochastic volatility models</li>
<li><strong>Interest rate modeling</strong>: Capturing mean reversion and ensuring realistic term structure dynamics<br>
</li>
<li><strong>Risk management</strong>: Providing frameworks for Value-at-Risk and scenario analysis</li>
<li><strong>Portfolio optimization</strong>: Incorporating stochastic dynamics into investment decisions</li>
</ol>
<p>These models form the backbone of modern quantitative finance and demonstrate the practical power of stochastic differential equation theory. In the next section, we explore the emerging applications of SDEs in machine learning and artificial intelligence.</p>
</section>
</section>
</section>
<section id="sec-ml-applications" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="sec-ml-applications"><span class="header-section-number">7</span> SDEs in Modern Machine Learning</h2>
<p>The renaissance of stochastic differential equations in machine learning represents one of the most exciting developments in contemporary AI research. This convergence has led to breakthrough applications in generative modeling, continuous-time neural networks, and probabilistic machine learning.</p>
<section id="neural-ordinary-differential-equations-nodes" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="neural-ordinary-differential-equations-nodes"><span class="header-section-number">7.1</span> Neural Ordinary Differential Equations (NODEs)</h3>
<p>The Neural ODE framework, introduced by Chen et al.&nbsp;(2018), revolutionized deep learning by treating neural networks as continuous-time dynamical systems.</p>
<p><strong>Mathematical Framework</strong>: Instead of discrete layers, Neural ODEs model the hidden state evolution as: <span class="math display">\[\frac{dh(t)}{dt} = f_\theta(h(t), t)\]</span></p>
<p>where <span class="math inline">\(f_\theta\)</span> is a neural network parameterized by <span class="math inline">\(\theta\)</span>, and the output is obtained by solving: <span class="math display">\[h(T) = h(0) + \int_0^T f_\theta(h(t), t) dt\]</span></p>
<p><strong>Key Advantages</strong>: - <strong>Memory efficiency</strong>: Constant memory cost during training - <strong>Adaptive computation</strong>: Automatic step size selection<br>
- <strong>Continuous depth</strong>: Networks with “infinite” layers - <strong>Invertible transformations</strong>: Normalizing flows applications</p>
</section>
<section id="neural-stochastic-differential-equations" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="neural-stochastic-differential-equations"><span class="header-section-number">7.2</span> Neural Stochastic Differential Equations</h3>
<p>Neural SDEs extend Neural ODEs by incorporating stochastic dynamics, providing better uncertainty quantification and more expressive models.</p>
<p><strong>Model Specification</strong>: Neural SDEs are defined as: <span class="math display">\[dh(t) = f_\theta(h(t), t) dt + g_\theta(h(t), t) dW(t)\]</span></p>
<p>where: - <span class="math inline">\(f_\theta\)</span> is the neural drift function - <span class="math inline">\(g_\theta\)</span> is the neural diffusion function<br>
- <span class="math inline">\(W(t)\)</span> represents Brownian motion</p>
<div id="cell-fig-neural-sdes" class="cell" data-fig-height="14" data-fig-width="18" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNeuralODE(nn.Module):</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simple Neural ODE implementation."""</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dim, hidden_dim):</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>            nn.Linear(input_dim, hidden_dim),</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>            nn.Tanh(),</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>            nn.Linear(hidden_dim, hidden_dim),</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>            nn.Tanh(),</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>            nn.Linear(hidden_dim, input_dim)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, t, x):</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.net(x)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNeuralSDE(nn.Module):</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simple Neural SDE implementation."""</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dim, hidden_dim):</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.drift_net <span class="op">=</span> nn.Sequential(</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            nn.Linear(input_dim, hidden_dim),</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            nn.Tanh(),</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            nn.Linear(hidden_dim, input_dim)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.diffusion_net <span class="op">=</span> nn.Sequential(</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            nn.Linear(input_dim, hidden_dim),</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>            nn.Tanh(),</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>            nn.Linear(hidden_dim, input_dim),</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>            nn.Softplus()  <span class="co"># Ensure positive diffusion</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, t, x):</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        drift <span class="op">=</span> <span class="va">self</span>.drift_net(x)</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        diffusion <span class="op">=</span> <span class="va">self</span>.diffusion_net(x)</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> drift, diffusion</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler_maruyama_neural_sde(sde_func, x0, t_span, dt<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Solve Neural SDE using Euler-Maruyama method."""</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>    t_start, t_end <span class="op">=</span> t_span</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    n_steps <span class="op">=</span> <span class="bu">int</span>((t_end <span class="op">-</span> t_start) <span class="op">/</span> dt)</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>    trajectory <span class="op">=</span> [x0]</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x0</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> t_start <span class="op">+</span> i <span class="op">*</span> dt</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>        drift, diffusion <span class="op">=</span> sde_func(t, x)</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Euler-Maruyama step</span></span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> torch.randn_like(x) <span class="op">*</span> np.sqrt(dt)</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> drift <span class="op">*</span> dt <span class="op">+</span> diffusion <span class="op">*</span> dW</span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a>        trajectory.append(x.clone())</span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack(trajectory)</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ode_solve_euler(ode_func, x0, t_span, dt<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simple Euler method for ODE solving."""</span></span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a>    t_start, t_end <span class="op">=</span> t_span</span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true" tabindex="-1"></a>    n_steps <span class="op">=</span> <span class="bu">int</span>((t_end <span class="op">-</span> t_start) <span class="op">/</span> dt)</span>
<span id="cb22-63"><a href="#cb22-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-64"><a href="#cb22-64" aria-hidden="true" tabindex="-1"></a>    trajectory <span class="op">=</span> [x0]</span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x0</span>
<span id="cb22-66"><a href="#cb22-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-67"><a href="#cb22-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_steps):</span>
<span id="cb22-68"><a href="#cb22-68" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> t_start <span class="op">+</span> i <span class="op">*</span> dt</span>
<span id="cb22-69"><a href="#cb22-69" aria-hidden="true" tabindex="-1"></a>        dx_dt <span class="op">=</span> ode_func(t, x)</span>
<span id="cb22-70"><a href="#cb22-70" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> dx_dt <span class="op">*</span> dt</span>
<span id="cb22-71"><a href="#cb22-71" aria-hidden="true" tabindex="-1"></a>        trajectory.append(x.clone())</span>
<span id="cb22-72"><a href="#cb22-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-73"><a href="#cb22-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack(trajectory)</span>
<span id="cb22-74"><a href="#cb22-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-75"><a href="#cb22-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic spiral data</span></span>
<span id="cb22-76"><a href="#cb22-76" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_spiral_data(n_samples<span class="op">=</span><span class="dv">1000</span>, noise<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb22-77"><a href="#cb22-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generate 2D spiral dataset."""</span></span>
<span id="cb22-78"><a href="#cb22-78" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> torch.linspace(<span class="dv">0</span>, <span class="dv">4</span><span class="op">*</span>np.pi, n_samples)</span>
<span id="cb22-79"><a href="#cb22-79" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> t <span class="op">*</span> torch.cos(t) <span class="op">+</span> noise <span class="op">*</span> torch.randn(n_samples)</span>
<span id="cb22-80"><a href="#cb22-80" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> t <span class="op">*</span> torch.sin(t) <span class="op">+</span> noise <span class="op">*</span> torch.randn(n_samples)</span>
<span id="cb22-81"><a href="#cb22-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack([x, y], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-82"><a href="#cb22-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-83"><a href="#cb22-83" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up models</span></span>
<span id="cb22-84"><a href="#cb22-84" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>)</span>
<span id="cb22-85"><a href="#cb22-85" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb22-86"><a href="#cb22-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-87"><a href="#cb22-87" aria-hidden="true" tabindex="-1"></a>input_dim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb22-88"><a href="#cb22-88" aria-hidden="true" tabindex="-1"></a>hidden_dim <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb22-89"><a href="#cb22-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-90"><a href="#cb22-90" aria-hidden="true" tabindex="-1"></a>neural_ode <span class="op">=</span> SimpleNeuralODE(input_dim, hidden_dim)</span>
<span id="cb22-91"><a href="#cb22-91" aria-hidden="true" tabindex="-1"></a>neural_sde <span class="op">=</span> SimpleNeuralSDE(input_dim, hidden_dim)</span>
<span id="cb22-92"><a href="#cb22-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-93"><a href="#cb22-93" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate training data</span></span>
<span id="cb22-94"><a href="#cb22-94" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> generate_spiral_data(<span class="dv">500</span>, <span class="fl">0.1</span>)</span>
<span id="cb22-95"><a href="#cb22-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-96"><a href="#cb22-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial conditions for forward simulation</span></span>
<span id="cb22-97"><a href="#cb22-97" aria-hidden="true" tabindex="-1"></a>x0_samples <span class="op">=</span> torch.randn(<span class="dv">10</span>, <span class="dv">2</span>) <span class="op">*</span> <span class="fl">0.5</span></span>
<span id="cb22-98"><a href="#cb22-98" aria-hidden="true" tabindex="-1"></a>t_span <span class="op">=</span> (<span class="fl">0.0</span>, <span class="fl">2.0</span>)</span>
<span id="cb22-99"><a href="#cb22-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-100"><a href="#cb22-100" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">14</span>))</span>
<span id="cb22-101"><a href="#cb22-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-102"><a href="#cb22-102" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot training data</span></span>
<span id="cb22-103"><a href="#cb22-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].scatter(data[:, <span class="dv">0</span>].numpy(), data[:, <span class="dv">1</span>].numpy(), alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb22-104"><a href="#cb22-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Training Data: Noisy Spiral'</span>)</span>
<span id="cb22-105"><a href="#cb22-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb22-106"><a href="#cb22-106" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb22-107"><a href="#cb22-107" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-108"><a href="#cb22-108" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].axis(<span class="st">'equal'</span>)</span>
<span id="cb22-109"><a href="#cb22-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-110"><a href="#cb22-110" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate Neural ODE trajectories</span></span>
<span id="cb22-111"><a href="#cb22-111" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb22-112"><a href="#cb22-112" aria-hidden="true" tabindex="-1"></a>    ode_trajectories <span class="op">=</span> []</span>
<span id="cb22-113"><a href="#cb22-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x0 <span class="kw">in</span> x0_samples:</span>
<span id="cb22-114"><a href="#cb22-114" aria-hidden="true" tabindex="-1"></a>        traj <span class="op">=</span> ode_solve_euler(neural_ode, x0.unsqueeze(<span class="dv">0</span>), t_span, dt<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb22-115"><a href="#cb22-115" aria-hidden="true" tabindex="-1"></a>        ode_trajectories.append(traj)</span>
<span id="cb22-116"><a href="#cb22-116" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(traj[:, <span class="dv">0</span>, <span class="dv">0</span>].numpy(), traj[:, <span class="dv">0</span>, <span class="dv">1</span>].numpy(), </span>
<span id="cb22-117"><a href="#cb22-117" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb22-118"><a href="#cb22-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-119"><a href="#cb22-119" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].scatter(x0_samples[:, <span class="dv">0</span>].numpy(), x0_samples[:, <span class="dv">1</span>].numpy(), </span>
<span id="cb22-120"><a href="#cb22-120" aria-hidden="true" tabindex="-1"></a>                  color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">50</span>, marker<span class="op">=</span><span class="st">'o'</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Initial points'</span>)</span>
<span id="cb22-121"><a href="#cb22-121" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Neural ODE Trajectories (Untrained)'</span>)</span>
<span id="cb22-122"><a href="#cb22-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb22-123"><a href="#cb22-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb22-124"><a href="#cb22-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb22-125"><a href="#cb22-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-126"><a href="#cb22-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axis(<span class="st">'equal'</span>)</span>
<span id="cb22-127"><a href="#cb22-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-128"><a href="#cb22-128" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate Neural SDE trajectories</span></span>
<span id="cb22-129"><a href="#cb22-129" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb22-130"><a href="#cb22-130" aria-hidden="true" tabindex="-1"></a>    torch.manual_seed(<span class="dv">42</span>)  <span class="co"># For reproducible stochastic trajectories</span></span>
<span id="cb22-131"><a href="#cb22-131" aria-hidden="true" tabindex="-1"></a>    sde_trajectories <span class="op">=</span> []</span>
<span id="cb22-132"><a href="#cb22-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x0 <span class="kw">in</span> x0_samples:</span>
<span id="cb22-133"><a href="#cb22-133" aria-hidden="true" tabindex="-1"></a>        traj <span class="op">=</span> euler_maruyama_neural_sde(neural_sde, x0.unsqueeze(<span class="dv">0</span>), t_span, dt<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb22-134"><a href="#cb22-134" aria-hidden="true" tabindex="-1"></a>        sde_trajectories.append(traj)</span>
<span id="cb22-135"><a href="#cb22-135" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(traj[:, <span class="dv">0</span>, <span class="dv">0</span>].numpy(), traj[:, <span class="dv">0</span>, <span class="dv">1</span>].numpy(), </span>
<span id="cb22-136"><a href="#cb22-136" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb22-137"><a href="#cb22-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-138"><a href="#cb22-138" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].scatter(x0_samples[:, <span class="dv">0</span>].numpy(), x0_samples[:, <span class="dv">1</span>].numpy(), </span>
<span id="cb22-139"><a href="#cb22-139" aria-hidden="true" tabindex="-1"></a>                  color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">50</span>, marker<span class="op">=</span><span class="st">'o'</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Initial points'</span>)</span>
<span id="cb22-140"><a href="#cb22-140" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Neural SDE Trajectories (Untrained)'</span>)</span>
<span id="cb22-141"><a href="#cb22-141" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb22-142"><a href="#cb22-142" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb22-143"><a href="#cb22-143" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb22-144"><a href="#cb22-144" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-145"><a href="#cb22-145" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axis(<span class="st">'equal'</span>)</span>
<span id="cb22-146"><a href="#cb22-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-147"><a href="#cb22-147" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare multiple SDE realizations from same initial condition</span></span>
<span id="cb22-148"><a href="#cb22-148" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb22-149"><a href="#cb22-149" aria-hidden="true" tabindex="-1"></a>    x0_single <span class="op">=</span> torch.tensor([[<span class="fl">0.0</span>, <span class="fl">0.0</span>]])</span>
<span id="cb22-150"><a href="#cb22-150" aria-hidden="true" tabindex="-1"></a>    n_realizations <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb22-151"><a href="#cb22-151" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-152"><a href="#cb22-152" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_realizations):</span>
<span id="cb22-153"><a href="#cb22-153" aria-hidden="true" tabindex="-1"></a>        torch.manual_seed(i)  <span class="co"># Different random seeds</span></span>
<span id="cb22-154"><a href="#cb22-154" aria-hidden="true" tabindex="-1"></a>        traj <span class="op">=</span> euler_maruyama_neural_sde(neural_sde, x0_single, t_span, dt<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb22-155"><a href="#cb22-155" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(traj[:, <span class="dv">0</span>, <span class="dv">0</span>].numpy(), traj[:, <span class="dv">0</span>, <span class="dv">1</span>].numpy(), </span>
<span id="cb22-156"><a href="#cb22-156" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb22-157"><a href="#cb22-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-158"><a href="#cb22-158" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].scatter([<span class="dv">0</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">100</span>, marker<span class="op">=</span><span class="st">'o'</span>, zorder<span class="op">=</span><span class="dv">5</span>, </span>
<span id="cb22-159"><a href="#cb22-159" aria-hidden="true" tabindex="-1"></a>                  label<span class="op">=</span><span class="st">'Common initial point'</span>)</span>
<span id="cb22-160"><a href="#cb22-160" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'SDE Uncertainty: Multiple Realizations'</span>)</span>
<span id="cb22-161"><a href="#cb22-161" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb22-162"><a href="#cb22-162" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb22-163"><a href="#cb22-163" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb22-164"><a href="#cb22-164" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-165"><a href="#cb22-165" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axis(<span class="st">'equal'</span>)</span>
<span id="cb22-166"><a href="#cb22-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-167"><a href="#cb22-167" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyze drift and diffusion components</span></span>
<span id="cb22-168"><a href="#cb22-168" aria-hidden="true" tabindex="-1"></a>x_grid <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb22-169"><a href="#cb22-169" aria-hidden="true" tabindex="-1"></a>y_grid <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb22-170"><a href="#cb22-170" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> torch.meshgrid(x_grid, y_grid, indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb22-171"><a href="#cb22-171" aria-hidden="true" tabindex="-1"></a>grid_points <span class="op">=</span> torch.stack([X.flatten(), Y.flatten()], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-172"><a href="#cb22-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-173"><a href="#cb22-173" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb22-174"><a href="#cb22-174" aria-hidden="true" tabindex="-1"></a>    drift_vals, diffusion_vals <span class="op">=</span> neural_sde(<span class="fl">0.0</span>, grid_points)</span>
<span id="cb22-175"><a href="#cb22-175" aria-hidden="true" tabindex="-1"></a>    drift_vals <span class="op">=</span> drift_vals.reshape(<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">2</span>)</span>
<span id="cb22-176"><a href="#cb22-176" aria-hidden="true" tabindex="-1"></a>    diffusion_vals <span class="op">=</span> diffusion_vals.reshape(<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">2</span>)</span>
<span id="cb22-177"><a href="#cb22-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-178"><a href="#cb22-178" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot drift field</span></span>
<span id="cb22-179"><a href="#cb22-179" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].quiver(X.numpy(), Y.numpy(), </span>
<span id="cb22-180"><a href="#cb22-180" aria-hidden="true" tabindex="-1"></a>                 drift_vals[:, :, <span class="dv">0</span>].numpy(), drift_vals[:, :, <span class="dv">1</span>].numpy(),</span>
<span id="cb22-181"><a href="#cb22-181" aria-hidden="true" tabindex="-1"></a>                 alpha<span class="op">=</span><span class="fl">0.7</span>, scale<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb22-182"><a href="#cb22-182" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Neural SDE Drift Field f_θ(x,t)'</span>)</span>
<span id="cb22-183"><a href="#cb22-183" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb22-184"><a href="#cb22-184" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb22-185"><a href="#cb22-185" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-186"><a href="#cb22-186" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].axis(<span class="st">'equal'</span>)</span>
<span id="cb22-187"><a href="#cb22-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-188"><a href="#cb22-188" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot diffusion magnitude</span></span>
<span id="cb22-189"><a href="#cb22-189" aria-hidden="true" tabindex="-1"></a>diffusion_magnitude <span class="op">=</span> torch.norm(diffusion_vals, dim<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb22-190"><a href="#cb22-190" aria-hidden="true" tabindex="-1"></a>im <span class="op">=</span> axes[<span class="dv">2</span>, <span class="dv">1</span>].contourf(X.numpy(), Y.numpy(), diffusion_magnitude.numpy(), </span>
<span id="cb22-191"><a href="#cb22-191" aria-hidden="true" tabindex="-1"></a>                        levels<span class="op">=</span><span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb22-192"><a href="#cb22-192" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Neural SDE Diffusion Magnitude |g_θ(x,t)|'</span>)</span>
<span id="cb22-193"><a href="#cb22-193" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb22-194"><a href="#cb22-194" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb22-195"><a href="#cb22-195" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im, ax<span class="op">=</span>axes[<span class="dv">2</span>, <span class="dv">1</span>])</span>
<span id="cb22-196"><a href="#cb22-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-197"><a href="#cb22-197" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-198"><a href="#cb22-198" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-199"><a href="#cb22-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-200"><a href="#cb22-200" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a simple training loop demonstration</span></span>
<span id="cb22-201"><a href="#cb22-201" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Neural SDE vs Neural ODE Comparison:"</span>)</span>
<span id="cb22-202"><a href="#cb22-202" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">50</span>)</span>
<span id="cb22-203"><a href="#cb22-203" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Key Differences:"</span>)</span>
<span id="cb22-204"><a href="#cb22-204" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"1. Deterministic vs Stochastic: ODEs produce deterministic trajectories,"</span>)</span>
<span id="cb22-205"><a href="#cb22-205" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   SDEs incorporate randomness and uncertainty"</span>)</span>
<span id="cb22-206"><a href="#cb22-206" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"2. Memory vs Uncertainty: ODEs are memory efficient, SDEs provide"</span>)</span>
<span id="cb22-207"><a href="#cb22-207" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   natural uncertainty quantification"</span>) </span>
<span id="cb22-208"><a href="#cb22-208" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"3. Training: SDEs require handling stochastic gradients and"</span>)</span>
<span id="cb22-209"><a href="#cb22-209" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   multiple trajectory sampling"</span>)</span>
<span id="cb22-210"><a href="#cb22-210" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"4. Applications: ODEs for normalizing flows, SDEs for generative"</span>)</span>
<span id="cb22-211"><a href="#cb22-211" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   modeling with uncertainty"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-neural-sdes" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-neural-sdes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-neural-sdes-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-neural-sdes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13: Neural SDEs: From deterministic ODEs to stochastic dynamics in deep learning
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Neural SDE vs Neural ODE Comparison:
==================================================
Key Differences:
1. Deterministic vs Stochastic: ODEs produce deterministic trajectories,
   SDEs incorporate randomness and uncertainty
2. Memory vs Uncertainty: ODEs are memory efficient, SDEs provide
   natural uncertainty quantification
3. Training: SDEs require handling stochastic gradients and
   multiple trajectory sampling
4. Applications: ODEs for normalizing flows, SDEs for generative
   modeling with uncertainty</code></pre>
</div>
</div>
</section>
<section id="gaussian-processes-and-sdes" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="gaussian-processes-and-sdes"><span class="header-section-number">7.3</span> Gaussian Processes and SDEs</h3>
<p>Gaussian Processes (GPs) provide a natural connection between SDEs and machine learning, as many GPs can be represented as solutions to linear SDEs.</p>
<p><strong>Connection</strong>: A GP with Matérn covariance function corresponds to the solution of the SDE: <span class="math display">\[d^n X(t) + a_{n-1} d^{n-1} X(t) + \cdots + a_1 dX(t) + a_0 X(t) dt = \sigma dW(t)\]</span></p>
<p>This connection enables: - <strong>Efficient GP inference</strong>: Converting GP regression to Kalman filtering - <strong>Streaming predictions</strong>: Online learning with infinite data - <strong>Scalable GPs</strong>: Linear complexity in time series length</p>
<div id="cell-fig-gp-sde-connection" class="cell" data-fig-height="12" data-fig-width="16" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> matern_32_sde_matrices(length_scale, sigma):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">    State-space representation of Matérn 3/2 GP.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">    dX/dt = F*X + L*w, where w is white noise</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    lam <span class="op">=</span> np.sqrt(<span class="dv">3</span>) <span class="op">/</span> length_scale</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">1</span>], </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>                  [<span class="op">-</span>lam<span class="op">**</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">2</span><span class="op">*</span>lam]])</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> np.array([[<span class="dv">0</span>], </span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>                  [sigma <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> lam <span class="op">*</span> np.sqrt(lam)]])</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>]])  <span class="co"># Observation matrix</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F, L, H</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_matern_sde(F, L, t_span, dt<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simulate Matérn process using SDE representation."""</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    t_start, t_end <span class="op">=</span> t_span</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    t_points <span class="op">=</span> np.arange(t_start, t_end <span class="op">+</span> dt, dt)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    n_steps <span class="op">=</span> <span class="bu">len</span>(t_points)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># State dimension</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    state_dim <span class="op">=</span> F.shape[<span class="dv">0</span>]</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    noise_dim <span class="op">=</span> L.shape[<span class="dv">1</span>]</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((n_steps, state_dim))</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    X[<span class="dv">0</span>] <span class="op">=</span> np.random.randn(state_dim)</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>    sqrt_dt <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_steps):</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>        dW <span class="op">=</span> np.random.randn(noise_dim) <span class="op">*</span> sqrt_dt</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>        X[i] <span class="op">=</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> F <span class="op">@</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> dt <span class="op">+</span> L <span class="op">@</span> dW</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t_points, X</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kalman_filter_gp(y_obs, t_obs, F, L, H, R, dt<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="co">    Kalman filter for GP inference using SDE representation.</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>    n_obs <span class="op">=</span> <span class="bu">len</span>(y_obs)</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>    state_dim <span class="op">=</span> F.shape[<span class="dv">0</span>]</span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>    x_pred <span class="op">=</span> np.zeros((n_obs, state_dim))</span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>    x_filt <span class="op">=</span> np.zeros((n_obs, state_dim))</span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>    P_pred <span class="op">=</span> np.zeros((n_obs, state_dim, state_dim))</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>    P_filt <span class="op">=</span> np.zeros((n_obs, state_dim, state_dim))</span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial conditions</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>    x_pred[<span class="dv">0</span>] <span class="op">=</span> np.zeros(state_dim)</span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a>    P_pred[<span class="dv">0</span>] <span class="op">=</span> np.eye(state_dim) <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process noise covariance</span></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> L <span class="op">@</span> L.T <span class="op">*</span> dt</span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_obs):</span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Predict step</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a>            dt_step <span class="op">=</span> t_obs[i] <span class="op">-</span> t_obs[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Simple Euler integration for transition</span></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true" tabindex="-1"></a>            x_pred[i] <span class="op">=</span> x_filt[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> F <span class="op">@</span> x_filt[i<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> dt_step</span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true" tabindex="-1"></a>            P_pred[i] <span class="op">=</span> P_filt[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> (F <span class="op">@</span> P_filt[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> P_filt[i<span class="op">-</span><span class="dv">1</span>] <span class="op">@</span> F.T <span class="op">+</span> Q) <span class="op">*</span> dt_step</span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update step</span></span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true" tabindex="-1"></a>        innovation <span class="op">=</span> y_obs[i] <span class="op">-</span> H <span class="op">@</span> x_pred[i]</span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> H <span class="op">@</span> P_pred[i] <span class="op">@</span> H.T <span class="op">+</span> R</span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true" tabindex="-1"></a>        K <span class="op">=</span> (P_pred[i] <span class="op">@</span> H.T <span class="op">/</span> S).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true" tabindex="-1"></a>        x_filt[i] <span class="op">=</span> x_pred[i] <span class="op">+</span> (K <span class="op">*</span> innovation).flatten()</span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true" tabindex="-1"></a>        P_filt[i] <span class="op">=</span> P_pred[i] <span class="op">-</span> K.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">@</span> H <span class="op">@</span> P_pred[i]</span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_filt, P_filt</span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic data</span></span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true" tabindex="-1"></a><span class="co"># GP parameters</span></span>
<span id="cb24-78"><a href="#cb24-78" aria-hidden="true" tabindex="-1"></a>length_scale <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb24-79"><a href="#cb24-79" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb24-80"><a href="#cb24-80" aria-hidden="true" tabindex="-1"></a>noise_std <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb24-81"><a href="#cb24-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-82"><a href="#cb24-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate true function using SDE simulation</span></span>
<span id="cb24-83"><a href="#cb24-83" aria-hidden="true" tabindex="-1"></a>F, L, H <span class="op">=</span> matern_32_sde_matrices(length_scale, sigma)</span>
<span id="cb24-84"><a href="#cb24-84" aria-hidden="true" tabindex="-1"></a>t_span <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">10</span>)</span>
<span id="cb24-85"><a href="#cb24-85" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb24-86"><a href="#cb24-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-87"><a href="#cb24-87" aria-hidden="true" tabindex="-1"></a>t_fine, X_true <span class="op">=</span> simulate_matern_sde(F, L, t_span, dt)</span>
<span id="cb24-88"><a href="#cb24-88" aria-hidden="true" tabindex="-1"></a>f_true <span class="op">=</span> H <span class="op">@</span> X_true.T  <span class="co"># Extract function values</span></span>
<span id="cb24-89"><a href="#cb24-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-90"><a href="#cb24-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Create sparse observations</span></span>
<span id="cb24-91"><a href="#cb24-91" aria-hidden="true" tabindex="-1"></a>n_obs <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb24-92"><a href="#cb24-92" aria-hidden="true" tabindex="-1"></a>obs_indices <span class="op">=</span> np.sort(np.random.choice(<span class="bu">len</span>(t_fine), n_obs, replace<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb24-93"><a href="#cb24-93" aria-hidden="true" tabindex="-1"></a>t_obs <span class="op">=</span> t_fine[obs_indices]</span>
<span id="cb24-94"><a href="#cb24-94" aria-hidden="true" tabindex="-1"></a>y_obs <span class="op">=</span> f_true[<span class="dv">0</span>, obs_indices] <span class="op">+</span> noise_std <span class="op">*</span> np.random.randn(n_obs)</span>
<span id="cb24-95"><a href="#cb24-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-96"><a href="#cb24-96" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">12</span>))</span>
<span id="cb24-97"><a href="#cb24-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-98"><a href="#cb24-98" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot true function and observations</span></span>
<span id="cb24-99"><a href="#cb24-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(t_fine, f_true[<span class="dv">0</span>], <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'True function'</span>)</span>
<span id="cb24-100"><a href="#cb24-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].scatter(t_obs, y_obs, color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">30</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Observations'</span>)</span>
<span id="cb24-101"><a href="#cb24-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Matérn 3/2 Process: True Function and Observations'</span>)</span>
<span id="cb24-102"><a href="#cb24-102" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb24-103"><a href="#cb24-103" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'f(t)'</span>)</span>
<span id="cb24-104"><a href="#cb24-104" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb24-105"><a href="#cb24-105" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb24-106"><a href="#cb24-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-107"><a href="#cb24-107" aria-hidden="true" tabindex="-1"></a><span class="co"># Kalman filter inference</span></span>
<span id="cb24-108"><a href="#cb24-108" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> noise_std<span class="op">**</span><span class="dv">2</span>  <span class="co"># Observation noise</span></span>
<span id="cb24-109"><a href="#cb24-109" aria-hidden="true" tabindex="-1"></a>x_filt, P_filt <span class="op">=</span> kalman_filter_gp(y_obs, t_obs, F, L, H, R, dt<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb24-110"><a href="#cb24-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-111"><a href="#cb24-111" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract posterior mean and variance at observation points</span></span>
<span id="cb24-112"><a href="#cb24-112" aria-hidden="true" tabindex="-1"></a>post_mean <span class="op">=</span> H <span class="op">@</span> x_filt.T</span>
<span id="cb24-113"><a href="#cb24-113" aria-hidden="true" tabindex="-1"></a>post_var <span class="op">=</span> np.array([H <span class="op">@</span> P <span class="op">@</span> H.T <span class="cf">for</span> P <span class="kw">in</span> P_filt])</span>
<span id="cb24-114"><a href="#cb24-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-115"><a href="#cb24-115" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_fine, f_true[<span class="dv">0</span>], <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'True function'</span>)</span>
<span id="cb24-116"><a href="#cb24-116" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].scatter(t_obs, y_obs, color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">30</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Observations'</span>)</span>
<span id="cb24-117"><a href="#cb24-117" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(t_obs, post_mean[<span class="dv">0</span>], <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'GP posterior mean'</span>)</span>
<span id="cb24-118"><a href="#cb24-118" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].fill_between(t_obs, </span>
<span id="cb24-119"><a href="#cb24-119" aria-hidden="true" tabindex="-1"></a>                       post_mean[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(post_var[:, <span class="dv">0</span>, <span class="dv">0</span>]),</span>
<span id="cb24-120"><a href="#cb24-120" aria-hidden="true" tabindex="-1"></a>                       post_mean[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(post_var[:, <span class="dv">0</span>, <span class="dv">0</span>]),</span>
<span id="cb24-121"><a href="#cb24-121" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'±2σ confidence'</span>)</span>
<span id="cb24-122"><a href="#cb24-122" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'GP Inference via Kalman Filter'</span>)</span>
<span id="cb24-123"><a href="#cb24-123" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb24-124"><a href="#cb24-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'f(t)'</span>)</span>
<span id="cb24-125"><a href="#cb24-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb24-126"><a href="#cb24-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb24-127"><a href="#cb24-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-128"><a href="#cb24-128" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare with standard GP regression using sklearn</span></span>
<span id="cb24-129"><a href="#cb24-129" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process <span class="im">import</span> GaussianProcessRegressor</span>
<span id="cb24-130"><a href="#cb24-130" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.gaussian_process.kernels <span class="im">import</span> Matern</span>
<span id="cb24-131"><a href="#cb24-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-132"><a href="#cb24-132" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard GP</span></span>
<span id="cb24-133"><a href="#cb24-133" aria-hidden="true" tabindex="-1"></a>kernel <span class="op">=</span> Matern(length_scale<span class="op">=</span>length_scale, nu<span class="op">=</span><span class="fl">1.5</span>) <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span></span>
<span id="cb24-134"><a href="#cb24-134" aria-hidden="true" tabindex="-1"></a>gp <span class="op">=</span> GaussianProcessRegressor(kernel<span class="op">=</span>kernel, alpha<span class="op">=</span>noise_std<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb24-135"><a href="#cb24-135" aria-hidden="true" tabindex="-1"></a>gp.fit(t_obs.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), y_obs)</span>
<span id="cb24-136"><a href="#cb24-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-137"><a href="#cb24-137" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict on fine grid</span></span>
<span id="cb24-138"><a href="#cb24-138" aria-hidden="true" tabindex="-1"></a>t_pred <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)</span>
<span id="cb24-139"><a href="#cb24-139" aria-hidden="true" tabindex="-1"></a>y_pred, y_std <span class="op">=</span> gp.predict(t_pred.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), return_std<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-140"><a href="#cb24-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-141"><a href="#cb24-141" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t_fine, f_true[<span class="dv">0</span>], <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'True function'</span>)</span>
<span id="cb24-142"><a href="#cb24-142" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].scatter(t_obs, y_obs, color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">30</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Observations'</span>)</span>
<span id="cb24-143"><a href="#cb24-143" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(t_pred, y_pred, <span class="st">'purple'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Standard GP mean'</span>)</span>
<span id="cb24-144"><a href="#cb24-144" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].fill_between(t_pred, y_pred <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>y_std, y_pred <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>y_std,</span>
<span id="cb24-145"><a href="#cb24-145" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'purple'</span>, label<span class="op">=</span><span class="st">'±2σ confidence'</span>)</span>
<span id="cb24-146"><a href="#cb24-146" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Standard GP Regression'</span>)</span>
<span id="cb24-147"><a href="#cb24-147" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb24-148"><a href="#cb24-148" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'f(t)'</span>)</span>
<span id="cb24-149"><a href="#cb24-149" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb24-150"><a href="#cb24-150" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb24-151"><a href="#cb24-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-152"><a href="#cb24-152" aria-hidden="true" tabindex="-1"></a><span class="co"># State evolution visualization</span></span>
<span id="cb24-153"><a href="#cb24-153" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(t_obs, x_filt[:, <span class="dv">0</span>], <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'State x₁ (function)'</span>)</span>
<span id="cb24-154"><a href="#cb24-154" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(t_obs, x_filt[:, <span class="dv">1</span>], <span class="st">'orange'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'State x₂ (derivative)'</span>)</span>
<span id="cb24-155"><a href="#cb24-155" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].fill_between(t_obs, </span>
<span id="cb24-156"><a href="#cb24-156" aria-hidden="true" tabindex="-1"></a>                       x_filt[:, <span class="dv">0</span>] <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(P_filt[:, <span class="dv">0</span>, <span class="dv">0</span>]),</span>
<span id="cb24-157"><a href="#cb24-157" aria-hidden="true" tabindex="-1"></a>                       x_filt[:, <span class="dv">0</span>] <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(P_filt[:, <span class="dv">0</span>, <span class="dv">0</span>]),</span>
<span id="cb24-158"><a href="#cb24-158" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'green'</span>)</span>
<span id="cb24-159"><a href="#cb24-159" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].fill_between(t_obs, </span>
<span id="cb24-160"><a href="#cb24-160" aria-hidden="true" tabindex="-1"></a>                       x_filt[:, <span class="dv">1</span>] <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(P_filt[:, <span class="dv">1</span>, <span class="dv">1</span>]),</span>
<span id="cb24-161"><a href="#cb24-161" aria-hidden="true" tabindex="-1"></a>                       x_filt[:, <span class="dv">1</span>] <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>np.sqrt(P_filt[:, <span class="dv">1</span>, <span class="dv">1</span>]),</span>
<span id="cb24-162"><a href="#cb24-162" aria-hidden="true" tabindex="-1"></a>                       alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb24-163"><a href="#cb24-163" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'State Space Evolution (Kalman Filter)'</span>)</span>
<span id="cb24-164"><a href="#cb24-164" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Time t'</span>)</span>
<span id="cb24-165"><a href="#cb24-165" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'State value'</span>)</span>
<span id="cb24-166"><a href="#cb24-166" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb24-167"><a href="#cb24-167" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb24-168"><a href="#cb24-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-169"><a href="#cb24-169" aria-hidden="true" tabindex="-1"></a><span class="co"># Phase space plot</span></span>
<span id="cb24-170"><a href="#cb24-170" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(X_true[:, <span class="dv">0</span>], X_true[:, <span class="dv">1</span>], <span class="st">'b-'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'True trajectory'</span>)</span>
<span id="cb24-171"><a href="#cb24-171" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].plot(x_filt[:, <span class="dv">0</span>], x_filt[:, <span class="dv">1</span>], <span class="st">'ro-'</span>, markersize<span class="op">=</span><span class="dv">4</span>, label<span class="op">=</span><span class="st">'Filtered states'</span>)</span>
<span id="cb24-172"><a href="#cb24-172" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_title(<span class="st">'Phase Space: Function vs Derivative'</span>)</span>
<span id="cb24-173"><a href="#cb24-173" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'f(t)'</span>)</span>
<span id="cb24-174"><a href="#cb24-174" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].set_ylabel(<span class="st">"f'(t)"</span>)</span>
<span id="cb24-175"><a href="#cb24-175" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].legend()</span>
<span id="cb24-176"><a href="#cb24-176" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb24-177"><a href="#cb24-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-178"><a href="#cb24-178" aria-hidden="true" tabindex="-1"></a><span class="co"># Computational comparison</span></span>
<span id="cb24-179"><a href="#cb24-179" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb24-180"><a href="#cb24-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-181"><a href="#cb24-181" aria-hidden="true" tabindex="-1"></a><span class="co"># Time standard GP</span></span>
<span id="cb24-182"><a href="#cb24-182" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb24-183"><a href="#cb24-183" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb24-184"><a href="#cb24-184" aria-hidden="true" tabindex="-1"></a>    gp.fit(t_obs.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), y_obs)</span>
<span id="cb24-185"><a href="#cb24-185" aria-hidden="true" tabindex="-1"></a>    y_pred, _ <span class="op">=</span> gp.predict(t_pred.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), return_std<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-186"><a href="#cb24-186" aria-hidden="true" tabindex="-1"></a>gp_time <span class="op">=</span> (time.time() <span class="op">-</span> start_time) <span class="op">/</span> <span class="dv">10</span></span>
<span id="cb24-187"><a href="#cb24-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-188"><a href="#cb24-188" aria-hidden="true" tabindex="-1"></a><span class="co"># Time Kalman filter approach  </span></span>
<span id="cb24-189"><a href="#cb24-189" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb24-190"><a href="#cb24-190" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb24-191"><a href="#cb24-191" aria-hidden="true" tabindex="-1"></a>    x_filt, P_filt <span class="op">=</span> kalman_filter_gp(y_obs, t_obs, F, L, H, R)</span>
<span id="cb24-192"><a href="#cb24-192" aria-hidden="true" tabindex="-1"></a>kf_time <span class="op">=</span> (time.time() <span class="op">-</span> start_time) <span class="op">/</span> <span class="dv">10</span></span>
<span id="cb24-193"><a href="#cb24-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-194"><a href="#cb24-194" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> [<span class="st">'Standard GP'</span>, <span class="st">'Kalman Filter GP'</span>]</span>
<span id="cb24-195"><a href="#cb24-195" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> [gp_time, kf_time]</span>
<span id="cb24-196"><a href="#cb24-196" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'purple'</span>, <span class="st">'green'</span>]</span>
<span id="cb24-197"><a href="#cb24-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-198"><a href="#cb24-198" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> axes[<span class="dv">2</span>, <span class="dv">1</span>].bar(methods, times, color<span class="op">=</span>colors, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb24-199"><a href="#cb24-199" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_title(<span class="st">'Computational Efficiency Comparison'</span>)</span>
<span id="cb24-200"><a href="#cb24-200" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Time (seconds)'</span>)</span>
<span id="cb24-201"><a href="#cb24-201" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb24-202"><a href="#cb24-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-203"><a href="#cb24-203" aria-hidden="true" tabindex="-1"></a><span class="co"># Add time labels on bars</span></span>
<span id="cb24-204"><a href="#cb24-204" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bar, time_val <span class="kw">in</span> <span class="bu">zip</span>(bars, times):</span>
<span id="cb24-205"><a href="#cb24-205" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> bar.get_height()</span>
<span id="cb24-206"><a href="#cb24-206" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">2</span>, <span class="dv">1</span>].text(bar.get_x() <span class="op">+</span> bar.get_width()<span class="op">/</span><span class="fl">2.</span>, height <span class="op">+</span> <span class="fl">0.001</span>,</span>
<span id="cb24-207"><a href="#cb24-207" aria-hidden="true" tabindex="-1"></a>                   <span class="ss">f'</span><span class="sc">{</span>time_val<span class="sc">:.4f}</span><span class="ss">s'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>)</span>
<span id="cb24-208"><a href="#cb24-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-209"><a href="#cb24-209" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb24-210"><a href="#cb24-210" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb24-211"><a href="#cb24-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-212"><a href="#cb24-212" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"GP-SDE Connection Benefits:"</span>)</span>
<span id="cb24-213"><a href="#cb24-213" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">40</span>)</span>
<span id="cb24-214"><a href="#cb24-214" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Standard GP time: </span><span class="sc">{</span>gp_time<span class="sc">:.4f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb24-215"><a href="#cb24-215" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Kalman Filter time: </span><span class="sc">{</span>kf_time<span class="sc">:.4f}</span><span class="ss"> seconds"</span>) </span>
<span id="cb24-216"><a href="#cb24-216" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Speedup factor: </span><span class="sc">{</span>gp_time<span class="op">/</span>kf_time<span class="sc">:.2f}</span><span class="ss">x"</span>)</span>
<span id="cb24-217"><a href="#cb24-217" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Key advantages of SDE representation:"</span>)</span>
<span id="cb24-218"><a href="#cb24-218" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"1. Linear complexity O(n) vs O(n³) for standard GP"</span>)</span>
<span id="cb24-219"><a href="#cb24-219" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"2. Online/streaming inference capability"</span>)</span>
<span id="cb24-220"><a href="#cb24-220" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"3. Natural handling of non-stationary processes"</span>)</span>
<span id="cb24-221"><a href="#cb24-221" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"4. Connection to control theory and signal processing"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-gp-sde-connection" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gp-sde-connection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-gp-sde-connection-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gp-sde-connection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;14: Gaussian Processes as SDE solutions: Efficient inference via state-space methods
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>GP-SDE Connection Benefits:
========================================
Standard GP time: 0.0043 seconds
Kalman Filter time: 0.0004 seconds
Speedup factor: 10.01x

Key advantages of SDE representation:
1. Linear complexity O(n) vs O(n³) for standard GP
2. Online/streaming inference capability
3. Natural handling of non-stationary processes
4. Connection to control theory and signal processing</code></pre>
</div>
</div>
</section>
<section id="neural-processes-bridging-gps-and-neural-networks" class="level3" data-number="7.4">
<h3 data-number="7.4" class="anchored" data-anchor-id="neural-processes-bridging-gps-and-neural-networks"><span class="header-section-number">7.4</span> Neural Processes: Bridging GPs and Neural Networks</h3>
<p>Neural Processes (NPs) combine the flexibility of neural networks with the uncertainty quantification of Gaussian Processes, representing a paradigm shift in meta-learning and few-shot prediction.</p>
<p><strong>Architecture</strong>: Neural Processes consist of: 1. <strong>Encoder</strong>: Maps context points to representations 2. <strong>Aggregator</strong>: Combines representations (often permutation-invariant)<br>
3. <strong>Decoder</strong>: Generates predictions at target points</p>
<p><strong>Mathematical Formulation</strong>: Given context set <span class="math inline">\(\mathcal{C} = \{(x_i, y_i)\}_{i=1}^n\)</span> and target inputs <span class="math inline">\(\mathbf{x}_*\)</span>, NPs model: <span class="math display">\[p(y_* | \mathbf{x}_*, \mathcal{C}) = \int p(y_* | \mathbf{x}_*, z) p(z | \mathcal{C}) dz\]</span></p>
<p>where <span class="math inline">\(z\)</span> is a latent representation capturing the underlying function.</p>
<p>The connection to SDEs emerges through: - <strong>Stochastic processes</strong>: NPs model distributions over functions - <strong>Uncertainty propagation</strong>: Similar to SDE solution uncertainty - <strong>Continuous-time extensions</strong>: Neural Process SDEs for temporal modeling</p>
</section>
<section id="diffusion-models-sdes-for-generative-ai" class="level3" data-number="7.5">
<h3 data-number="7.5" class="anchored" data-anchor-id="diffusion-models-sdes-for-generative-ai"><span class="header-section-number">7.5</span> Diffusion Models: SDEs for Generative AI</h3>
<p>Diffusion models represent one of the most successful applications of SDE theory in modern machine learning, powering state-of-the-art generative models for images, audio, and text.</p>
<p><strong>Mathematical Framework</strong>: Diffusion models are built on the theory of denoising diffusion processes, which can be formulated as SDEs. The framework consists of two processes:</p>
<ol type="1">
<li><p><strong>Forward Process (Noise Addition)</strong>: A fixed diffusion process that gradually adds Gaussian noise: <span class="math display">\[dX_t = -\frac{1}{2}\beta(t) X_t dt + \sqrt{\beta(t)} dW_t\]</span></p></li>
<li><p><strong>Reverse Process (Denoising)</strong>: A learned SDE that reverses the noise addition: <span class="math display">\[dX_t = \left[-\frac{1}{2}\beta(t) X_t - \beta(t) \nabla_{X_t} \log p_t(X_t)\right] dt + \sqrt{\beta(t)} dW_t\]</span></p></li>
</ol>
<p>where <span class="math inline">\(\beta(t)\)</span> is the noise schedule and <span class="math inline">\(\nabla_{X_t} \log p_t(X_t)\)</span> is the score function.</p>
<p><strong>Score-Based Generative Models</strong>: The key insight is that learning the score function <span class="math inline">\(\nabla_{X_t} \log p_t(X_t)\)</span> enables sample generation by solving the reverse SDE.</p>
<div class="cell" data-fig-height="16" data-fig-width="18" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> linear_beta_schedule(timesteps, beta_start<span class="op">=</span><span class="fl">0.0001</span>, beta_end<span class="op">=</span><span class="fl">0.02</span>):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Linear noise schedule for diffusion process."""</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.linspace(beta_start, beta_end, timesteps)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cosine_beta_schedule(timesteps, s<span class="op">=</span><span class="fl">0.008</span>):</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Cosine noise schedule for improved sampling."""</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> timesteps <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="dv">0</span>, timesteps, steps)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    alphas_cumprod <span class="op">=</span> np.cos(((x <span class="op">/</span> timesteps) <span class="op">+</span> s) <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> s) <span class="op">*</span> np.pi <span class="op">*</span> <span class="fl">0.5</span>) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    alphas_cumprod <span class="op">=</span> alphas_cumprod <span class="op">/</span> alphas_cumprod[<span class="dv">0</span>]</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    betas <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (alphas_cumprod[<span class="dv">1</span>:] <span class="op">/</span> alphas_cumprod[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.clip(betas, <span class="fl">0.0001</span>, <span class="fl">0.9999</span>)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleDiffusionModel:</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simplified diffusion model for demonstration."""</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, timesteps<span class="op">=</span><span class="dv">1000</span>, beta_schedule<span class="op">=</span><span class="st">'linear'</span>):</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.timesteps <span class="op">=</span> timesteps</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> beta_schedule <span class="op">==</span> <span class="st">'linear'</span>:</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.betas <span class="op">=</span> linear_beta_schedule(timesteps)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.betas <span class="op">=</span> cosine_beta_schedule(timesteps)</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> <span class="va">self</span>.betas</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas_cumprod <span class="op">=</span> np.cumprod(<span class="va">self</span>.alphas)</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas_cumprod_prev <span class="op">=</span> np.concatenate([np.array([<span class="fl">1.0</span>]), <span class="va">self</span>.alphas_cumprod[:<span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Precompute useful quantities</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sqrt_alphas_cumprod <span class="op">=</span> np.sqrt(<span class="va">self</span>.alphas_cumprod)</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sqrt_one_minus_alphas_cumprod <span class="op">=</span> np.sqrt(<span class="fl">1.0</span> <span class="op">-</span> <span class="va">self</span>.alphas_cumprod)</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> q_sample(<span class="va">self</span>, x_start, t, noise<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Forward diffusion process: q(x_t | x_0)."""</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> noise <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a>            noise <span class="op">=</span> np.random.randn(<span class="op">*</span>x_start.shape)</span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>        sqrt_alphas_cumprod_t <span class="op">=</span> <span class="va">self</span>.sqrt_alphas_cumprod[t]</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>        sqrt_one_minus_alphas_cumprod_t <span class="op">=</span> <span class="va">self</span>.sqrt_one_minus_alphas_cumprod[t]</span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (sqrt_alphas_cumprod_t <span class="op">*</span> x_start <span class="op">+</span> </span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a>                sqrt_one_minus_alphas_cumprod_t <span class="op">*</span> noise)</span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> p_sample_step(<span class="va">self</span>, model_output, x_t, t):</span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Single reverse diffusion step (simplified)."""</span></span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract noise prediction</span></span>
<span id="cb26-47"><a href="#cb26-47" aria-hidden="true" tabindex="-1"></a>        predicted_noise <span class="op">=</span> model_output</span>
<span id="cb26-48"><a href="#cb26-48" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-49"><a href="#cb26-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute coefficients</span></span>
<span id="cb26-50"><a href="#cb26-50" aria-hidden="true" tabindex="-1"></a>        alpha_t <span class="op">=</span> <span class="va">self</span>.alphas[t]</span>
<span id="cb26-51"><a href="#cb26-51" aria-hidden="true" tabindex="-1"></a>        alpha_cumprod_t <span class="op">=</span> <span class="va">self</span>.alphas_cumprod[t]</span>
<span id="cb26-52"><a href="#cb26-52" aria-hidden="true" tabindex="-1"></a>        alpha_cumprod_t_prev <span class="op">=</span> <span class="va">self</span>.alphas_cumprod_prev[t]</span>
<span id="cb26-53"><a href="#cb26-53" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-54"><a href="#cb26-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute mean of reverse process</span></span>
<span id="cb26-55"><a href="#cb26-55" aria-hidden="true" tabindex="-1"></a>        pred_original_sample <span class="op">=</span> (x_t <span class="op">-</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> alpha_cumprod_t) <span class="op">*</span> predicted_noise) <span class="op">/</span> np.sqrt(alpha_cumprod_t)</span>
<span id="cb26-56"><a href="#cb26-56" aria-hidden="true" tabindex="-1"></a>        pred_original_sample <span class="op">=</span> np.clip(pred_original_sample, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb26-57"><a href="#cb26-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-58"><a href="#cb26-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute coefficients for x_t</span></span>
<span id="cb26-59"><a href="#cb26-59" aria-hidden="true" tabindex="-1"></a>        pred_sample_direction <span class="op">=</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> alpha_cumprod_t_prev) <span class="op">*</span> predicted_noise</span>
<span id="cb26-60"><a href="#cb26-60" aria-hidden="true" tabindex="-1"></a>        pred_prev_sample <span class="op">=</span> np.sqrt(alpha_cumprod_t_prev) <span class="op">*</span> pred_original_sample <span class="op">+</span> pred_sample_direction</span>
<span id="cb26-61"><a href="#cb26-61" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-62"><a href="#cb26-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pred_prev_sample</span>
<span id="cb26-63"><a href="#cb26-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-64"><a href="#cb26-64" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_score_network(x, t, target_shape<span class="op">=</span>(<span class="dv">28</span>, <span class="dv">28</span>)):</span>
<span id="cb26-65"><a href="#cb26-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-66"><a href="#cb26-66" aria-hidden="true" tabindex="-1"></a><span class="co">    Simplified score network (noise predictor).</span></span>
<span id="cb26-67"><a href="#cb26-67" aria-hidden="true" tabindex="-1"></a><span class="co">    In practice, this would be a sophisticated neural network (U-Net, etc.)</span></span>
<span id="cb26-68"><a href="#cb26-68" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-69"><a href="#cb26-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For demonstration, just add some structured noise based on time</span></span>
<span id="cb26-70"><a href="#cb26-70" aria-hidden="true" tabindex="-1"></a>    noise_level <span class="op">=</span> t <span class="op">/</span> <span class="fl">1000.0</span></span>
<span id="cb26-71"><a href="#cb26-71" aria-hidden="true" tabindex="-1"></a>    spatial_pattern <span class="op">=</span> np.sin(np.arange(target_shape[<span class="dv">0</span>])[:, <span class="va">None</span>] <span class="op">*</span> <span class="fl">0.3</span>) <span class="op">*</span> np.cos(np.arange(target_shape[<span class="dv">1</span>])[<span class="va">None</span>, :] <span class="op">*</span> <span class="fl">0.3</span>)</span>
<span id="cb26-72"><a href="#cb26-72" aria-hidden="true" tabindex="-1"></a>    predicted_noise <span class="op">=</span> noise_level <span class="op">*</span> spatial_pattern <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> np.random.randn(<span class="op">*</span>target_shape)</span>
<span id="cb26-73"><a href="#cb26-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> predicted_noise</span>
<span id="cb26-74"><a href="#cb26-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-75"><a href="#cb26-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic 2D data (Swiss roll)</span></span>
<span id="cb26-76"><a href="#cb26-76" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_swiss_roll(n_samples<span class="op">=</span><span class="dv">1000</span>, noise<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb26-77"><a href="#cb26-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generate Swiss roll dataset."""</span></span>
<span id="cb26-78"><a href="#cb26-78" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="fl">1.5</span> <span class="op">*</span> np.pi <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> np.random.rand(n_samples))</span>
<span id="cb26-79"><a href="#cb26-79" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> t <span class="op">*</span> np.cos(t)</span>
<span id="cb26-80"><a href="#cb26-80" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> t <span class="op">*</span> np.sin(t)</span>
<span id="cb26-81"><a href="#cb26-81" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> np.column_stack([x, y])</span>
<span id="cb26-82"><a href="#cb26-82" aria-hidden="true" tabindex="-1"></a>    data <span class="op">+=</span> noise <span class="op">*</span> np.random.randn(n_samples, <span class="dv">2</span>)</span>
<span id="cb26-83"><a href="#cb26-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data</span>
<span id="cb26-84"><a href="#cb26-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-85"><a href="#cb26-85" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up diffusion model</span></span>
<span id="cb26-86"><a href="#cb26-86" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb26-87"><a href="#cb26-87" aria-hidden="true" tabindex="-1"></a>diffusion <span class="op">=</span> SimpleDiffusionModel(timesteps<span class="op">=</span><span class="dv">200</span>, beta_schedule<span class="op">=</span><span class="st">'cosine'</span>)</span>
<span id="cb26-88"><a href="#cb26-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-89"><a href="#cb26-89" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate training data</span></span>
<span id="cb26-90"><a href="#cb26-90" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb26-91"><a href="#cb26-91" aria-hidden="true" tabindex="-1"></a>data_2d <span class="op">=</span> generate_swiss_roll(n_samples, noise<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb26-92"><a href="#cb26-92" aria-hidden="true" tabindex="-1"></a>data_2d <span class="op">=</span> (data_2d <span class="op">-</span> data_2d.mean(axis<span class="op">=</span><span class="dv">0</span>)) <span class="op">/</span> data_2d.std(axis<span class="op">=</span><span class="dv">0</span>)  <span class="co"># Normalize</span></span>
<span id="cb26-93"><a href="#cb26-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-94"><a href="#cb26-94" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">16</span>))</span>
<span id="cb26-95"><a href="#cb26-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-96"><a href="#cb26-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Original data</span></span>
<span id="cb26-97"><a href="#cb26-97" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].scatter(data_2d[:, <span class="dv">0</span>], data_2d[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb26-98"><a href="#cb26-98" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Original Data'</span>)</span>
<span id="cb26-99"><a href="#cb26-99" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb26-100"><a href="#cb26-100" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb26-101"><a href="#cb26-101" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-102"><a href="#cb26-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-103"><a href="#cb26-103" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward diffusion process at different timesteps</span></span>
<span id="cb26-104"><a href="#cb26-104" aria-hidden="true" tabindex="-1"></a>timesteps_to_show <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">199</span>]</span>
<span id="cb26-105"><a href="#cb26-105" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'orange'</span>, <span class="st">'red'</span>, <span class="st">'purple'</span>]</span>
<span id="cb26-106"><a href="#cb26-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-107"><a href="#cb26-107" aria-hidden="true" tabindex="-1"></a><span class="co"># Show forward process</span></span>
<span id="cb26-108"><a href="#cb26-108" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (t, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(timesteps_to_show[<span class="dv">1</span>:], colors[<span class="dv">1</span>:])):</span>
<span id="cb26-109"><a href="#cb26-109" aria-hidden="true" tabindex="-1"></a>    noisy_data <span class="op">=</span> []</span>
<span id="cb26-110"><a href="#cb26-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> sample <span class="kw">in</span> data_2d:</span>
<span id="cb26-111"><a href="#cb26-111" aria-hidden="true" tabindex="-1"></a>        noisy_sample <span class="op">=</span> diffusion.q_sample(sample, t)</span>
<span id="cb26-112"><a href="#cb26-112" aria-hidden="true" tabindex="-1"></a>        noisy_data.append(noisy_sample)</span>
<span id="cb26-113"><a href="#cb26-113" aria-hidden="true" tabindex="-1"></a>    noisy_data <span class="op">=</span> np.array(noisy_data)</span>
<span id="cb26-114"><a href="#cb26-114" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-115"><a href="#cb26-115" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">4</span></span>
<span id="cb26-116"><a href="#cb26-116" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">4</span></span>
<span id="cb26-117"><a href="#cb26-117" aria-hidden="true" tabindex="-1"></a>    axes[row, col].scatter(noisy_data[:, <span class="dv">0</span>], noisy_data[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span>color)</span>
<span id="cb26-118"><a href="#cb26-118" aria-hidden="true" tabindex="-1"></a>    axes[row, col].set_title(<span class="ss">f'Forward Process t=</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb26-119"><a href="#cb26-119" aria-hidden="true" tabindex="-1"></a>    axes[row, col].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb26-120"><a href="#cb26-120" aria-hidden="true" tabindex="-1"></a>    axes[row, col].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb26-121"><a href="#cb26-121" aria-hidden="true" tabindex="-1"></a>    axes[row, col].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-122"><a href="#cb26-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-123"><a href="#cb26-123" aria-hidden="true" tabindex="-1"></a><span class="co"># Beta schedule visualization</span></span>
<span id="cb26-124"><a href="#cb26-124" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(diffusion.betas, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'β(t)'</span>)</span>
<span id="cb26-125"><a href="#cb26-125" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Noise Schedule β(t)'</span>)</span>
<span id="cb26-126"><a href="#cb26-126" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Timestep t'</span>)</span>
<span id="cb26-127"><a href="#cb26-127" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'β(t)'</span>)</span>
<span id="cb26-128"><a href="#cb26-128" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb26-129"><a href="#cb26-129" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-130"><a href="#cb26-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-131"><a href="#cb26-131" aria-hidden="true" tabindex="-1"></a><span class="co"># Alpha cumulative product</span></span>
<span id="cb26-132"><a href="#cb26-132" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(diffusion.alphas_cumprod, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'ᾱ(t)'</span>)</span>
<span id="cb26-133"><a href="#cb26-133" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Cumulative Product ᾱ(t)'</span>)</span>
<span id="cb26-134"><a href="#cb26-134" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Timestep t'</span>)</span>
<span id="cb26-135"><a href="#cb26-135" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'ᾱ(t)'</span>)</span>
<span id="cb26-136"><a href="#cb26-136" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].legend()</span>
<span id="cb26-137"><a href="#cb26-137" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-138"><a href="#cb26-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-139"><a href="#cb26-139" aria-hidden="true" tabindex="-1"></a><span class="co"># Signal-to-noise ratio</span></span>
<span id="cb26-140"><a href="#cb26-140" aria-hidden="true" tabindex="-1"></a>snr <span class="op">=</span> diffusion.alphas_cumprod <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> diffusion.alphas_cumprod)</span>
<span id="cb26-141"><a href="#cb26-141" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].semilogy(snr, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'SNR'</span>)</span>
<span id="cb26-142"><a href="#cb26-142" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_title(<span class="st">'Signal-to-Noise Ratio'</span>)</span>
<span id="cb26-143"><a href="#cb26-143" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_xlabel(<span class="st">'Timestep t'</span>)</span>
<span id="cb26-144"><a href="#cb26-144" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].set_ylabel(<span class="st">'SNR (log scale)'</span>)</span>
<span id="cb26-145"><a href="#cb26-145" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].legend()</span>
<span id="cb26-146"><a href="#cb26-146" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">2</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-147"><a href="#cb26-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-148"><a href="#cb26-148" aria-hidden="true" tabindex="-1"></a><span class="co"># Demonstrate reverse process (simplified)</span></span>
<span id="cb26-149"><a href="#cb26-149" aria-hidden="true" tabindex="-1"></a><span class="co"># Start from noise</span></span>
<span id="cb26-150"><a href="#cb26-150" aria-hidden="true" tabindex="-1"></a>final_noise <span class="op">=</span> np.random.randn(<span class="dv">100</span>, <span class="dv">2</span>)</span>
<span id="cb26-151"><a href="#cb26-151" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].scatter(final_noise[:, <span class="dv">0</span>], final_noise[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb26-152"><a href="#cb26-152" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].set_title(<span class="st">'Starting Noise (t=T)'</span>)</span>
<span id="cb26-153"><a href="#cb26-153" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb26-154"><a href="#cb26-154" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb26-155"><a href="#cb26-155" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">3</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-156"><a href="#cb26-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-157"><a href="#cb26-157" aria-hidden="true" tabindex="-1"></a><span class="co"># Simplified reverse sampling (without actual trained model)</span></span>
<span id="cb26-158"><a href="#cb26-158" aria-hidden="true" tabindex="-1"></a>current_samples <span class="op">=</span> final_noise.copy()</span>
<span id="cb26-159"><a href="#cb26-159" aria-hidden="true" tabindex="-1"></a>reverse_timesteps <span class="op">=</span> [<span class="dv">199</span>, <span class="dv">150</span>, <span class="dv">100</span>, <span class="dv">50</span>, <span class="dv">0</span>]</span>
<span id="cb26-160"><a href="#cb26-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-161"><a href="#cb26-161" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, t <span class="kw">in</span> <span class="bu">enumerate</span>(reverse_timesteps[<span class="dv">1</span>:]):</span>
<span id="cb26-162"><a href="#cb26-162" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate denoising step (in practice, this would use trained score network)</span></span>
<span id="cb26-163"><a href="#cb26-163" aria-hidden="true" tabindex="-1"></a>    noise_factor <span class="op">=</span> diffusion.sqrt_one_minus_alphas_cumprod[t]</span>
<span id="cb26-164"><a href="#cb26-164" aria-hidden="true" tabindex="-1"></a>    signal_factor <span class="op">=</span> diffusion.sqrt_alphas_cumprod[t]</span>
<span id="cb26-165"><a href="#cb26-165" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-166"><a href="#cb26-166" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple denoising: move towards data manifold</span></span>
<span id="cb26-167"><a href="#cb26-167" aria-hidden="true" tabindex="-1"></a>    target_samples <span class="op">=</span> data_2d[np.random.choice(<span class="bu">len</span>(data_2d), <span class="bu">len</span>(current_samples))]</span>
<span id="cb26-168"><a href="#cb26-168" aria-hidden="true" tabindex="-1"></a>    denoising_direction <span class="op">=</span> target_samples <span class="op">-</span> current_samples</span>
<span id="cb26-169"><a href="#cb26-169" aria-hidden="true" tabindex="-1"></a>    current_samples <span class="op">=</span> current_samples <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> denoising_direction <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> np.random.randn(<span class="op">*</span>current_samples.shape)</span>
<span id="cb26-170"><a href="#cb26-170" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-171"><a href="#cb26-171" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> i <span class="op">//</span> <span class="dv">4</span></span>
<span id="cb26-172"><a href="#cb26-172" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> i <span class="op">%</span> <span class="dv">4</span></span>
<span id="cb26-173"><a href="#cb26-173" aria-hidden="true" tabindex="-1"></a>    axes[row, col].scatter(current_samples[:, <span class="dv">0</span>], current_samples[:, <span class="dv">1</span>], </span>
<span id="cb26-174"><a href="#cb26-174" aria-hidden="true" tabindex="-1"></a>                          alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span>colors[i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb26-175"><a href="#cb26-175" aria-hidden="true" tabindex="-1"></a>    axes[row, col].set_title(<span class="ss">f'Reverse Process t=</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb26-176"><a href="#cb26-176" aria-hidden="true" tabindex="-1"></a>    axes[row, col].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb26-177"><a href="#cb26-177" aria-hidden="true" tabindex="-1"></a>    axes[row, col].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb26-178"><a href="#cb26-178" aria-hidden="true" tabindex="-1"></a>    axes[row, col].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-179"><a href="#cb26-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-180"><a href="#cb26-180" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare noise schedules</span></span>
<span id="cb26-181"><a href="#cb26-181" aria-hidden="true" tabindex="-1"></a>fig2, axes2 <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb26-182"><a href="#cb26-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-183"><a href="#cb26-183" aria-hidden="true" tabindex="-1"></a><span class="co"># Linear vs Cosine schedules</span></span>
<span id="cb26-184"><a href="#cb26-184" aria-hidden="true" tabindex="-1"></a>linear_betas <span class="op">=</span> linear_beta_schedule(<span class="dv">200</span>)</span>
<span id="cb26-185"><a href="#cb26-185" aria-hidden="true" tabindex="-1"></a>cosine_betas <span class="op">=</span> cosine_beta_schedule(<span class="dv">200</span>)</span>
<span id="cb26-186"><a href="#cb26-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-187"><a href="#cb26-187" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].plot(linear_betas, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Linear'</span>)</span>
<span id="cb26-188"><a href="#cb26-188" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].plot(cosine_betas, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Cosine'</span>)</span>
<span id="cb26-189"><a href="#cb26-189" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Noise Schedules Comparison'</span>)</span>
<span id="cb26-190"><a href="#cb26-190" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Timestep'</span>)</span>
<span id="cb26-191"><a href="#cb26-191" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'β(t)'</span>)</span>
<span id="cb26-192"><a href="#cb26-192" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].legend()</span>
<span id="cb26-193"><a href="#cb26-193" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-194"><a href="#cb26-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-195"><a href="#cb26-195" aria-hidden="true" tabindex="-1"></a><span class="co"># Corresponding alpha cumprod</span></span>
<span id="cb26-196"><a href="#cb26-196" aria-hidden="true" tabindex="-1"></a>linear_alphas_cumprod <span class="op">=</span> np.cumprod(<span class="fl">1.0</span> <span class="op">-</span> linear_betas)</span>
<span id="cb26-197"><a href="#cb26-197" aria-hidden="true" tabindex="-1"></a>cosine_alphas_cumprod <span class="op">=</span> np.cumprod(<span class="fl">1.0</span> <span class="op">-</span> cosine_betas)</span>
<span id="cb26-198"><a href="#cb26-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-199"><a href="#cb26-199" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].plot(linear_alphas_cumprod, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Linear'</span>)</span>
<span id="cb26-200"><a href="#cb26-200" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].plot(cosine_alphas_cumprod, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Cosine'</span>)</span>
<span id="cb26-201"><a href="#cb26-201" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Signal Preservation ᾱ(t)'</span>)</span>
<span id="cb26-202"><a href="#cb26-202" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Timestep'</span>)</span>
<span id="cb26-203"><a href="#cb26-203" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'ᾱ(t)'</span>)</span>
<span id="cb26-204"><a href="#cb26-204" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].legend()</span>
<span id="cb26-205"><a href="#cb26-205" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-206"><a href="#cb26-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-207"><a href="#cb26-207" aria-hidden="true" tabindex="-1"></a><span class="co"># Demonstrate ancestral sampling concept</span></span>
<span id="cb26-208"><a href="#cb26-208" aria-hidden="true" tabindex="-1"></a>x_start <span class="op">=</span> data_2d[<span class="dv">0</span>]  <span class="co"># Single sample</span></span>
<span id="cb26-209"><a href="#cb26-209" aria-hidden="true" tabindex="-1"></a>t_values <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">200</span>, <span class="dv">20</span>)</span>
<span id="cb26-210"><a href="#cb26-210" aria-hidden="true" tabindex="-1"></a>forward_trajectory <span class="op">=</span> []</span>
<span id="cb26-211"><a href="#cb26-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-212"><a href="#cb26-212" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t <span class="kw">in</span> t_values:</span>
<span id="cb26-213"><a href="#cb26-213" aria-hidden="true" tabindex="-1"></a>    x_t <span class="op">=</span> diffusion.q_sample(x_start, t)</span>
<span id="cb26-214"><a href="#cb26-214" aria-hidden="true" tabindex="-1"></a>    forward_trajectory.append(x_t)</span>
<span id="cb26-215"><a href="#cb26-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-216"><a href="#cb26-216" aria-hidden="true" tabindex="-1"></a>forward_trajectory <span class="op">=</span> np.array(forward_trajectory)</span>
<span id="cb26-217"><a href="#cb26-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-218"><a href="#cb26-218" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].plot(forward_trajectory[:, <span class="dv">0</span>], forward_trajectory[:, <span class="dv">1</span>], <span class="st">'bo-'</span>, </span>
<span id="cb26-219"><a href="#cb26-219" aria-hidden="true" tabindex="-1"></a>                markersize<span class="op">=</span><span class="dv">4</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb26-220"><a href="#cb26-220" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].scatter([x_start[<span class="dv">0</span>]], [x_start[<span class="dv">1</span>]], color<span class="op">=</span><span class="st">'red'</span>, s<span class="op">=</span><span class="dv">100</span>, </span>
<span id="cb26-221"><a href="#cb26-221" aria-hidden="true" tabindex="-1"></a>                   marker<span class="op">=</span><span class="st">'*'</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Original'</span>)</span>
<span id="cb26-222"><a href="#cb26-222" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Forward Diffusion Trajectory'</span>)</span>
<span id="cb26-223"><a href="#cb26-223" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb26-224"><a href="#cb26-224" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb26-225"><a href="#cb26-225" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].legend()</span>
<span id="cb26-226"><a href="#cb26-226" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-227"><a href="#cb26-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-228"><a href="#cb26-228" aria-hidden="true" tabindex="-1"></a><span class="co"># Score function illustration (simplified)</span></span>
<span id="cb26-229"><a href="#cb26-229" aria-hidden="true" tabindex="-1"></a>x_grid <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb26-230"><a href="#cb26-230" aria-hidden="true" tabindex="-1"></a>y_grid <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb26-231"><a href="#cb26-231" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x_grid, y_grid)</span>
<span id="cb26-232"><a href="#cb26-232" aria-hidden="true" tabindex="-1"></a>grid_points <span class="op">=</span> np.stack([X.flatten(), Y.flatten()], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-233"><a href="#cb26-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-234"><a href="#cb26-234" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximate score function (points toward data)</span></span>
<span id="cb26-235"><a href="#cb26-235" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> np.zeros_like(grid_points)</span>
<span id="cb26-236"><a href="#cb26-236" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, point <span class="kw">in</span> <span class="bu">enumerate</span>(grid_points):</span>
<span id="cb26-237"><a href="#cb26-237" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find nearest data points</span></span>
<span id="cb26-238"><a href="#cb26-238" aria-hidden="true" tabindex="-1"></a>    distances <span class="op">=</span> np.linalg.norm(data_2d <span class="op">-</span> point[<span class="va">None</span>, :], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-239"><a href="#cb26-239" aria-hidden="true" tabindex="-1"></a>    nearest_idx <span class="op">=</span> np.argmin(distances)</span>
<span id="cb26-240"><a href="#cb26-240" aria-hidden="true" tabindex="-1"></a>    nearest_point <span class="op">=</span> data_2d[nearest_idx]</span>
<span id="cb26-241"><a href="#cb26-241" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-242"><a href="#cb26-242" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Score points toward data manifold</span></span>
<span id="cb26-243"><a href="#cb26-243" aria-hidden="true" tabindex="-1"></a>    direction <span class="op">=</span> nearest_point <span class="op">-</span> point</span>
<span id="cb26-244"><a href="#cb26-244" aria-hidden="true" tabindex="-1"></a>    scores[i] <span class="op">=</span> direction <span class="op">/</span> (np.linalg.norm(direction) <span class="op">+</span> <span class="fl">1e-8</span>)</span>
<span id="cb26-245"><a href="#cb26-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-246"><a href="#cb26-246" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> scores.reshape(<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">2</span>)</span>
<span id="cb26-247"><a href="#cb26-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-248"><a href="#cb26-248" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">1</span>].quiver(X, Y, scores[:, :, <span class="dv">0</span>], scores[:, :, <span class="dv">1</span>], </span>
<span id="cb26-249"><a href="#cb26-249" aria-hidden="true" tabindex="-1"></a>                  alpha<span class="op">=</span><span class="fl">0.7</span>, scale<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb26-250"><a href="#cb26-250" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">1</span>].scatter(data_2d[:, <span class="dv">0</span>], data_2d[:, <span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>, s<span class="op">=</span><span class="dv">20</span>, c<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb26-251"><a href="#cb26-251" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Score Function ∇log p(x)'</span>)</span>
<span id="cb26-252"><a href="#cb26-252" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'x₁'</span>)</span>
<span id="cb26-253"><a href="#cb26-253" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'x₂'</span>)</span>
<span id="cb26-254"><a href="#cb26-254" aria-hidden="true" tabindex="-1"></a>axes2[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb26-255"><a href="#cb26-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-256"><a href="#cb26-256" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb26-257"><a href="#cb26-257" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb26-258"><a href="#cb26-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-259"><a href="#cb26-259" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb26-260"><a href="#cb26-260" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb26-261"><a href="#cb26-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-262"><a href="#cb26-262" aria-hidden="true" tabindex="-1"></a><span class="co"># Print key insights</span></span>
<span id="cb26-263"><a href="#cb26-263" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Diffusion Models: Key Insights"</span>)</span>
<span id="cb26-264"><a href="#cb26-264" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">40</span>)</span>
<span id="cb26-265"><a href="#cb26-265" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"1. Forward Process: Systematic noise addition following SDE"</span>)</span>
<span id="cb26-266"><a href="#cb26-266" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"2. Reverse Process: Learned denoising via score function estimation"</span>)</span>
<span id="cb26-267"><a href="#cb26-267" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"3. Training: Learn to predict noise added at each timestep"</span>)</span>
<span id="cb26-268"><a href="#cb26-268" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"4. Sampling: Reverse the diffusion process to generate new samples"</span>)</span>
<span id="cb26-269"><a href="#cb26-269" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"5. Score Function: ∇log p(x) guides the reverse process"</span>)</span>
<span id="cb26-270"><a href="#cb26-270" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Advantages over GANs:"</span>)</span>
<span id="cb26-271"><a href="#cb26-271" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- More stable training"</span>)</span>
<span id="cb26-272"><a href="#cb26-272" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Better mode coverage"</span>) </span>
<span id="cb26-273"><a href="#cb26-273" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Theoretical guarantees"</span>)</span>
<span id="cb26-274"><a href="#cb26-274" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Flexible sampling procedures"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Diffusion Models: Key Insights
========================================
1. Forward Process: Systematic noise addition following SDE
2. Reverse Process: Learned denoising via score function estimation
3. Training: Learn to predict noise added at each timestep
4. Sampling: Reverse the diffusion process to generate new samples
5. Score Function: ∇log p(x) guides the reverse process

Advantages over GANs:
- More stable training
- Better mode coverage
- Theoretical guarantees
- Flexible sampling procedures</code></pre>
</div>
<div id="fig-diffusion-models" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-fig-height="16" data-execution_count="16" data-fig-width="18">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-diffusion-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output cell-output-display">
<div id="fig-diffusion-models-1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-diffusion-models-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-diffusion-models-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-diffusion-models">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-diffusion-models-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Diffusion models: SDE-based generative modeling with forward and reverse processes
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div id="fig-diffusion-models-2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-diffusion-models-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-diffusion-models-output-2.png" id="fig-diffusion-models-2" class="img-fluid figure-img" data-ref-parent="fig-diffusion-models">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-diffusion-models-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-diffusion-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;15
</figcaption>
</figure>
</div>
</div>
<p><strong>Key Theoretical Results</strong>:</p>
<ol type="1">
<li><p><strong>Probability Flow ODE</strong>: Every SDE has a corresponding ODE with the same marginal distributions: <span class="math display">\[\frac{dX_t}{dt} = f(X_t, t) - \frac{1}{2}g^2(t) \nabla_{X_t} \log p_t(X_t)\]</span></p></li>
<li><p><strong>Score Matching</strong>: The score function can be learned by minimizing: <span class="math display">\[\mathbb{E}_{t,X_0,X_t}\left[\left\|\epsilon - \epsilon_\theta(X_t, t)\right\|^2\right]\]</span></p></li>
<li><p><strong>Sampling</strong>: Generation is achieved by numerically solving the reverse SDE or probability flow ODE.</p></li>
</ol>
<p><strong>Modern Applications</strong>: - <strong>Image Generation</strong>: DALL-E 2, Stable Diffusion, Imagen - <strong>Audio Synthesis</strong>: WaveGrad, DiffWave - <strong>Text Generation</strong>: Diffusion-LM - <strong>3D Shape Generation</strong>: Point-E, DreamFusion - <strong>Video Generation</strong>: Imagen Video, Make-A-Video</p>
</section>
<section id="stochastic-neural-differential-equations" class="level3" data-number="7.6">
<h3 data-number="7.6" class="anchored" data-anchor-id="stochastic-neural-differential-equations"><span class="header-section-number">7.6</span> Stochastic Neural Differential Equations</h3>
<p>Stochastic Neural Differential Equations (SNDEs) extend Neural Ordinary Differential Equations (NODEs) by incorporating stochasticity directly into the neural network dynamics. This allows them to model systems with inherent randomness, making them particularly suitable for tasks like time series forecasting with uncertainty, generative modeling, and reinforcement learning in stochastic environments.</p>
<p>The general form of a Neural SDE can be written as:</p>
<p><span class="math inline">\(dh_t = f_\theta(h_t, t) dt + g_\theta(h_t, t) dW_t\)</span></p>
<p>where: - <span class="math inline">\(h_t\)</span> is the hidden state of the neural network at time <span class="math inline">\(t\)</span>. - <span class="math inline">\(f_\theta(h_t, t)\)</span> is the drift function, typically parameterized by a neural network with parameters <span class="math inline">\(\theta\)</span>. - <span class="math inline">\(g_\theta(h_t, t)\)</span> is the diffusion function, also parameterized by a neural network with parameters <span class="math inline">\(\theta\)</span>. - <span class="math inline">\(dW_t\)</span> is a Wiener process (Brownian motion), representing the stochastic input.</p>
<p>This formulation allows the model to learn both the deterministic evolution and the noise characteristics of the underlying system.</p>
<section id="implementation-example-simple-neural-sde-in-pytorch" class="level4" data-number="7.6.1">
<h4 data-number="7.6.1" class="anchored" data-anchor-id="implementation-example-simple-neural-sde-in-pytorch"><span class="header-section-number">7.6.1</span> Implementation Example: Simple Neural SDE in PyTorch</h4>
<p>Here’s a basic PyTorch implementation of a Neural SDE, demonstrating how to define the drift and diffusion networks and simulate the process. For simplicity, we’ll use a fixed time step Euler-Maruyama solver.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the Neural SDE model</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NeuralSDE(nn.Module):</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_dim, hidden_dim, output_dim):</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(NeuralSDE, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.drift_net <span class="op">=</span> nn.Sequential(</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            nn.Linear(input_dim, hidden_dim),</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>            nn.ReLU(),</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>            nn.Linear(hidden_dim, output_dim)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.diffusion_net <span class="op">=</span> nn.Sequential(</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            nn.Linear(input_dim, hidden_dim),</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            nn.ReLU(),</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>            nn.Linear(hidden_dim, output_dim)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, h, t):</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># h: current hidden state, t: current time</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For simplicity, we'll ignore 't' in this basic example,</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># but it can be incorporated into the network inputs.</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>        drift <span class="op">=</span> <span class="va">self</span>.drift_net(h)</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>        diffusion <span class="op">=</span> <span class="va">self</span>.diffusion_net(h)</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> drift, diffusion</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Euler-Maruyama SDE solver</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sde_solver_euler_maruyama(model, h0, t_span, dt, num_paths<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>    h_paths <span class="op">=</span> []</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_paths):</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>        h_path <span class="op">=</span> [h0]</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>        h_current <span class="op">=</span> h0</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t_span) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>            t_current <span class="op">=</span> t_span[i]</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>            dW <span class="op">=</span> torch.randn_like(h_current) <span class="op">*</span> np.sqrt(dt)</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>            drift, diffusion <span class="op">=</span> model(h_current, t_current)</span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>            h_next <span class="op">=</span> h_current <span class="op">+</span> drift <span class="op">*</span> dt <span class="op">+</span> diffusion <span class="op">*</span> dW</span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>            h_path.append(h_next)</span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>            h_current <span class="op">=</span> h_next</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>        h_paths.append(torch.stack(h_path))</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack(h_paths)</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>input_dim <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>hidden_dim <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>output_dim <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>h0 <span class="op">=</span> torch.tensor([<span class="fl">0.5</span>], dtype<span class="op">=</span>torch.float32) <span class="co"># Initial state</span></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>T_end <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>num_steps <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T_end <span class="op">/</span> num_steps</span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>t_span <span class="op">=</span> np.linspace(<span class="dv">0</span>, T_end, num_steps <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>num_paths <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize Neural SDE model</span></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>sde_model <span class="op">=</span> NeuralSDE(input_dim, hidden_dim, output_dim)</span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate paths</span></span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">42</span>) <span class="co"># for reproducibility</span></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a>simulated_paths <span class="op">=</span> sde_solver_euler_maruyama(sde_model, h0, t_span, dt, num_paths)</span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_paths):</span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a>    plt.plot(t_span, simulated_paths[i].detach().numpy(), alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Simulated Paths from a Simple Neural SDE'</span>)</span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time'</span>)</span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Hidden State h(t)'</span>)</span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape of simulated paths: </span><span class="sc">{</span>simulated_paths<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example demonstrates the basic structure. In real-world applications, the drift and diffusion networks would be more complex, and training would involve defining a loss function (e.g., likelihood-based or score-matching) and using optimization algorithms to learn the parameters <span class="math inline">\(\theta\)</span>.</p>
<p><strong>Latent SDEs</strong>: Model latent dynamics with SDEs while observing through deterministic functions: <span class="math inline">\(dZ_t = f_\theta(Z_t, t) dt + g_\theta(Z_t, t) dW_t\)</span> <span class="math inline">\(X_t = h_\phi(Z_t) + \epsilon_t\)</span></p>
<p><strong>Neural SDE Training</strong>: Uses the reparameterization trick and efficient SDE solvers for gradient computation.</p>
<p><strong>Applications</strong>: Time series modeling, dynamics learning, uncertainty quantification in deep learning.</p>
<p>These modern developments demonstrate how classical SDE theory continues to drive innovation in machine learning, providing both theoretical foundations and practical algorithms for the next generation of AI systems.</p>
<p>Recent work has explored neural networks that directly parameterize SDE coefficients, enabling:</p>
<p><strong>Latent SDEs</strong>: Model latent dynamics with SDEs while observing through deterministic functions: <span class="math display">\[dZ_t = f_\theta(Z_t, t) dt + g_\theta(Z_t, t) dW_t\]</span> <span class="math display">\[X_t = h_\phi(Z_t) + \epsilon_t\]</span></p>
<p><strong>Neural SDE Training</strong>: Uses the reparameterization trick and efficient SDE solvers for gradient computation.</p>
<p><strong>Applications</strong>: Time series modeling, dynamics learning, uncertainty quantification in deep learning.</p>
<p>These modern developments demonstrate how classical SDE theory continues to drive innovation in machine learning, providing both theoretical foundations and practical algorithms for the next generation of AI systems.</p>
</section>
</section>
</section>
<section id="sec-conclusion" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="sec-conclusion"><span class="header-section-number">8</span> Conclusion and Future Directions</h2>
<p>This comprehensive exploration of stochastic differential equations reveals the profound mathematical elegance and practical power of this theoretical framework. From Itô’s revolutionary development of stochastic calculus in the 1940s to today’s cutting-edge applications in generative AI, SDEs have consistently provided the mathematical foundation for modeling and understanding complex random phenomena.</p>
<section id="key-contributions-and-insights" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="key-contributions-and-insights"><span class="header-section-number">8.1</span> Key Contributions and Insights</h3>
<p><strong>Mathematical Foundations</strong>: We have seen how the careful construction of stochastic integration and Itô’s lemma provides the rigorous mathematical framework necessary for analyzing continuous-time random processes. The fundamental insight that <span class="math inline">\((dW_t)^2 = dt\)</span> transforms our understanding of calculus in stochastic settings.</p>
<p><strong>Computational Methods</strong>: The development of numerical schemes like Euler-Maruyama and Milstein demonstrates how theoretical insights translate into practical computational tools. The trade-offs between accuracy, computational cost, and stability remain central to successful implementation.</p>
<p><strong>Financial Applications</strong>: The Black-Scholes model, interest rate models, and stochastic volatility frameworks showcase how SDE theory has revolutionized quantitative finance. These applications demonstrate the power of mathematical modeling in creating practical solutions to complex real-world problems.</p>
<p><strong>Machine Learning Renaissance</strong>: The emergence of Neural ODEs, diffusion models, and neural processes illustrates how classical mathematical theory continues to inspire breakthrough innovations in artificial intelligence. The connection between score-based generative models and SDE theory represents a particularly elegant synthesis of probability theory and deep learning.</p>
</section>
<section id="future-research-directions" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="future-research-directions"><span class="header-section-number">8.2</span> Future Research Directions</h3>
<p>Several exciting avenues for future research emerge from our exploration:</p>
<p><strong>Computational Advances</strong>: Development of more efficient numerical methods for high-dimensional SDEs, particularly for machine learning applications where computational scalability is crucial.</p>
<p><strong>Theoretical Extensions</strong>: Investigation of fractional SDEs, jump-diffusion processes, and SDEs on manifolds to capture more complex real-world phenomena.</p>
<p><strong>Machine Learning Integration</strong>: Deeper integration of SDE theory with modern machine learning, including applications to reinforcement learning, causal inference, and interpretable AI.</p>
<p><strong>Cross-Disciplinary Applications</strong>: Extension of SDE methods to new domains such as biology, climate science, and social networks, where stochastic modeling can provide new insights.</p>
</section>
<section id="final-reflections" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="final-reflections"><span class="header-section-number">8.3</span> Final Reflections</h3>
<p>The journey from Brownian motion to modern AI demonstrates the enduring value of rigorous mathematical theory. Stochastic differential equations exemplify how abstract mathematical concepts, developed through careful theoretical investigation, ultimately find profound practical applications that transform entire fields.</p>
<p>As we stand at the intersection of classical probability theory and modern artificial intelligence, SDEs continue to provide both the theoretical foundation and practical tools necessary for the next generation of scientific and technological breakthroughs. The mathematical elegance of Itô calculus, combined with the computational power of modern algorithms, ensures that stochastic differential equations will remain at the forefront of mathematical innovation for decades to come.</p>
</section>
</section>
<section id="sec-references" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="sec-references"><span class="header-section-number">9</span> References</h2>
<p>The comprehensive nature of this exploration draws upon decades of mathematical and computational research. Key references include foundational texts on stochastic calculus, numerical analysis, financial mathematics, and modern machine learning applications. The bibliography provides entry points for deeper investigation into each topic area covered in this treatise.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bachelier1900" class="csl-entry" role="listitem">
Bachelier, Louis. 1900. <span>“Th<span>é</span>orie de La Sp<span>é</span>culation.”</span> <em>Annales Scientifiques de l’<span>É</span>cole Normale Sup<span>é</span>rieure</em> 17: 21–86.
</div>
<div id="ref-chen2018" class="csl-entry" role="listitem">
Chen, Ricky T. Q., Yulia Rubanova, Jesse Bettencourt, and David Duvenaud. 2018. <span>“Neural Ordinary Differential Equations.”</span> <em>Advances in Neural Information Processing Systems</em> 31: 6571–83.
</div>
<div id="ref-cox1985" class="csl-entry" role="listitem">
Cox, John C., Jonathan E. Ingersoll Jr, and Stephen A. Ross. 1985. <span>“A Theory of the Term Structure of Interest Rates.”</span> <em>Econometrica: Journal of the Econometric Society</em> 53 (2): 385–407.
</div>
<div id="ref-gardiner2009" class="csl-entry" role="listitem">
Gardiner, Crispin W. 2009. <em>Stochastic Methods: A Handbook for the Natural and Social Sciences</em>. 4th ed. Springer Series in Synergetics. Springer.
</div>
<div id="ref-heston1993" class="csl-entry" role="listitem">
Heston, Steven L. 1993. <span>“A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options.”</span> <em>The Review of Financial Studies</em> 6 (2): 327–43.
</div>
<div id="ref-ito1951" class="csl-entry" role="listitem">
Itô, Kiyoshi. 1951. <span>“On Stochastic Differential Equations.”</span> <em>Memoirs of the American Mathematical Society</em> 4: 1–51.
</div>
<div id="ref-karatzas1991" class="csl-entry" role="listitem">
Karatzas, Ioannis, and Steven E. Shreve. 1991. <em>Brownian Motion and Stochastic Calculus</em>. 2nd ed. Vol. 113. Graduate Texts in Mathematics. Springer.
</div>
<div id="ref-mckean1969" class="csl-entry" role="listitem">
McKean, Henry P. 1969. <em>Stochastic Integrals</em>. New York: Academic Press.
</div>
<div id="ref-oksendal2003" class="csl-entry" role="listitem">
Øksendal, Bernt. 2003. <em>Stochastic Differential Equations: An Introduction with Applications</em>. 6th ed. Universitext. Springer.
</div>
<div id="ref-song2021" class="csl-entry" role="listitem">
Song, Yang, Jascha Sohl-Dickstein, Diederik P. Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. 2021. <span>“Score-Based Generative Modeling Through Stochastic Differential Equations.”</span> <em>International Conference on Learning Representations</em>.
</div>
<div id="ref-wiener1923" class="csl-entry" role="listitem">
Wiener, Norbert. 1923. <span>“Differential-Space.”</span> <em>Journal of Mathematics and Physics</em> 2 (1-4): 131–74.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>