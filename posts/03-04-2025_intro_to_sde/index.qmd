---
title: "An Introduction to Stochastic Differential Equations"
abstract: "This post provides an intuitive introduction to Stochastic Differential Equations (SDEs), the mathematical tool for modeling systems that evolve randomly over time. We'll cover the basics of Brownian motion, Itô calculus, and how SDEs are used in finance."
categories:
  - Mathematics
  - Finance
  - Python
author: "Jan Schlegel"
date: "2025-04-03"
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 3
number-sections: true
fig-width: 10
fig-height: 6
fig-dpi: 150
fig-format: png
jupyter: python3
---

![Stochastic differential equations provide the mathematical framework for modeling continuous-time random processes, with applications spanning from option pricing to generative AI models](img/sde_thumbnail.png)

```{python}
#| echo: false
#| output: false

import sys
import os
sys.path.append('/home/janhsc/Documents/projects/JHSchlegel.github.io/.venv/lib/python3.10/site-packages')
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
warnings.filterwarnings('ignore')

plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("husl")
plt.rcParams['figure.dpi'] = 150
```

## What are Stochastic Differential Equations?

Many things in the world don't evolve in a perfectly predictable way. Think about the price of a stock, the temperature of a room, or the position of a pollen grain in water. These systems have a general trend, but also a lot of random wobbles.

Stochastic Differential Equations (SDEs) are the mathematical language we use to describe such systems. They are like ordinary differential equations (ODEs), but with an added term for randomness.

A typical SDE looks like this:

$$ dX_t = \mu(t, X_t) dt + \sigma(t, X_t) dW_t $$

Let's break this down:
-   $dX_t$ is the tiny change in our variable $X$ over a tiny time interval.
-   $\mu(t, X_t) dt$ is the **drift** term. This is the deterministic part, like the expected growth rate of a stock. It's the "trend" the system follows.
-   $\sigma(t, X_t) dW_t$ is the **diffusion** term. This is the random part that makes the process wobble. $\sigma(t, X_t)$ is the volatility, and $dW_t$ represents a small chunk of a random process called Brownian motion.

## The Random Part: Brownian Motion

The heart of an SDE is the random process that drives it, which is almost always **Brownian motion** (or a Wiener process, $W_t$). Brownian motion is a mathematical model for random movement. It was originally used to describe the motion of pollen grains in water, but it's now used to model randomness in all sorts of fields.

Here are the key properties of Brownian motion:
1.  It starts at zero: $W_0 = 0$.
2.  The changes over any two non-overlapping time intervals are independent.
3.  The change $W_t - W_s$ over a time interval of length $t-s$ is normally distributed with mean 0 and variance $t-s$.
4.  Its path is continuous everywhere, but differentiable nowhere. This is a weird but crucial property!

The plot below shows a few simulated paths of Brownian motion. Notice how they are continuous, but also very jagged.

```{python}
#| label: fig-brownian-motion
#| fig-cap: "Sample paths of Brownian motion."
#| fig-width: 8
#| fig-height: 6

def simulate_brownian_motion(T, N, n_paths=5):
    """Efficiently simulate Brownian motion paths."""
    dt = T / N
    sqrt_dt = np.sqrt(dt)
    
    paths = np.zeros((n_paths, N + 1))
    
    for i in range(n_paths):
        for j in range(1, N + 1):
            paths[i, j] = paths[i, j-1] + sqrt_dt * np.random.randn()
    
    return paths

# Simulation parameters
T = 1.0
N = 500
n_paths = 5
t = np.linspace(0, T, N + 1)

np.random.seed(42)
paths = simulate_brownian_motion(T, N, n_paths)

plt.figure(figsize=(8, 6))
for i in range(n_paths):
    plt.plot(t, paths[i].T, alpha=0.8, linewidth=1.5)

plt.title('Sample Paths of Brownian Motion')
plt.xlabel('Time t')
plt.ylabel('W(t)')
plt.grid(True, alpha=0.3)
plt.show()
```

## The New Rules of Calculus: Itô Calculus

Because Brownian motion is not differentiable, we can't use the normal rules of calculus. We need a new set of rules called **Itô calculus**.

The most important result in Itô calculus is **Itô's Lemma**, which is like the chain rule for SDEs. If we have a function $f(t, X_t)$ where $X_t$ follows an SDE, Itô's Lemma tells us how to find the differential $df(t, X_t)$.

The key difference from normal calculus is that because of the randomness of $X_t$, we have to add an extra term related to the second derivative of $f$. In essence, Itô's Lemma is a Taylor expansion that doesn't throw away the second-order term involving the stochastic part. This is because the variance of Brownian motion grows with time, so its small-scale wobbles don't just disappear.

## SDEs in Finance: Modeling Asset Prices

SDEs are the bread and butter of quantitative finance. They are used to model the prices of stocks, bonds, currencies, and other financial assets.

### Geometric Brownian Motion

The most famous SDE in finance is the one used in the Black-Scholes model for option pricing. It's called **Geometric Brownian Motion (GBM)**:

$$ dS_t = \mu S_t dt + \sigma S_t dW_t $$

Here, $S_t$ is the stock price, $\mu$ is the expected return, and $\sigma$ is the volatility. The drift and diffusion terms are proportional to the current price $S_t$. This model has a nice property: the stock price will never be negative.

### Mean Reversion

Not all financial variables wander off to infinity. Interest rates, for example, tend to be pulled back to some long-term average. This is called **mean reversion**.

A popular model for this is the **Ornstein-Uhlenbeck (OU) process**:

$$ dX_t = \kappa(\theta - X_t) dt + \sigma dW_t $$

Here, $\theta$ is the long-term mean, and $\kappa$ is the speed of reversion. If $X_t$ is above $\theta$, the drift term becomes negative, pulling the process down. If it's below $\theta$, the drift becomes positive, pulling it up.

The plot below shows simulated paths for both GBM and a mean-reverting process.

```{python}
#| label: fig-sde-examples
#| fig-cap: "Sample paths for Geometric Brownian Motion and an Ornstein-Uhlenbeck process."
#| fig-width: 12
#| fig-height: 6

def simulate_gbm(S0, mu, sigma, T, N, n_paths=1):
    """Simulate geometric Brownian motion."""
    dt = T / N
    t = np.linspace(0, T, N + 1)
    dW = np.random.randn(n_paths, N) * np.sqrt(dt)
    W = np.cumsum(np.c_[np.zeros(n_paths), dW], axis=1)
    S = S0 * np.exp((mu - 0.5 * sigma**2) * t + sigma * W)
    return t, S

def simulate_ou(X0, theta, kappa, sigma, T, N, n_paths=1):
    """Simulate Ornstein-Uhlenbeck process."""
    dt = T / N
    t = np.linspace(0, T, N + 1)
    X = np.zeros((n_paths, N + 1))
    X[:, 0] = X0
    for i in range(N):
        dW = np.random.randn(n_paths) * np.sqrt(dt)
        X[:, i+1] = X[:, i] + kappa * (theta - X[:, i]) * dt + sigma * dW
    return t, X

# Parameters
T = 5.0
N = 1000
n_paths = 5

# GBM parameters
S0 = 100
mu = 0.05
sigma_gbm = 0.2

# OU parameters
X0 = 0.03
theta = 0.04
kappa = 1.0
sigma_ou = 0.02

np.random.seed(42)
t_gbm, S_gbm = simulate_gbm(S0, mu, sigma_gbm, T, N, n_paths)
t_ou, X_ou = simulate_ou(X0, theta, kappa, sigma_ou, T, N, n_paths)

fig, axes = plt.subplots(1, 2, figsize=(12, 6))

# GBM plot
for i in range(n_paths):
    axes[0].plot(t_gbm, S_gbm[i], alpha=0.8)
axes[0].set_title('Geometric Brownian Motion')
axes[0].set_xlabel('Time t')
axes[0].set_ylabel('S(t)')
axes[0].grid(True, alpha=0.3)

# OU plot
for i in range(n_paths):
    axes[1].plot(t_ou, X_ou[i], alpha=0.8)
axes[1].axhline(y=theta, color='r', linestyle='--', label=f'Mean (θ={theta})')
axes[1].set_title('Ornstein-Uhlenbeck (Mean Reversion)')
axes[1].set_xlabel('Time t')
axes[1].set_ylabel('X(t)')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Conclusion

Stochastic differential equations are a fundamental tool for anyone working in quantitative finance or other fields that deal with random processes. They provide a powerful way to model systems that evolve over time with some degree of uncertainty. While the underlying mathematics can be deep, the basic ideas of drift, diffusion, and Itô calculus are accessible and provide a strong foundation for understanding these models.
